digraph G {
0 [label="EXTERNAL"];
1 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 2"];
2 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 3"];
3 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 4"];
4 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 5"];
5 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 6"];
6 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 7"];
7 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 8"];
8 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 9"];
9 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 10"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 11"];
11 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 12"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 13"];
13 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 14"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 15"];
15 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 16"];
16 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 17"];
17 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 18"];
18 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 19"];
19 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 20"];
20 [label="MscorlibRef_v4_0_30316_17626 21"];
21 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 22"];
22 [label="'/*<bind>*/' 23"];
23 [label="'/*</bind>*/' 24"];
24 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 25"];
25 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 26"];
26 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 27"];
27 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 28"];
28 [label="EndString = '/*</bind>*/' 29"];
29 [label="StartString = '/*<bind>*/' 30"];
30 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 31"];
31 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 32"];
32 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 33"];
33 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 34"];
34 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 35"];
35 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 36"];
36 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 37"];
37 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 38"];
38 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 39"];
39 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 40"];
40 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 41"];
41 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 42"];
42 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 43"];
43 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 44"];
44 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 45"];
45 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 46"];
46 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 47"];
47 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 48"];
48 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 49"];
49 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 50"];
50 [label="param StatementParsingTests(this) 51"];
51 [label="param StatementParsingTests(ITestOutputHelper output) 52"];
52 [label="param StatementParsingTests(this) 53"];
53 [label="output 54"];
54 [label="param ParsingTests(ITestOutputHelper output) 55"];
55 [label="param ParsingTests(this) 56"];
56 [label="param CSharpTestBase(this) 57"];
57 [label="_node 58"];
58 [label="_treeEnumerator 59"];
59 [label="_output 60"];
60 [label="this._output 61"];
61 [label="param StatementParsingTests(this) 62"];
62 [label="param TestName(this) 63"];
63 [label="'a();' 64"];
64 [label="text = 'a();' 65"];
65 [label="text 66"];
66 [label="this.ParseStatement(text) 67"];
67 [label="param ParseStatement(string text) 68"];
68 [label="param ParseStatement(int offset = 0) 69"];
69 [label="param ParseStatement(ParseOptions options = null) 70"];
70 [label="param ParseStatement(this) 71"];
71 [label="text 72"];
72 [label="offset 73"];
73 [label="options 74"];
74 [label="SyntaxFactory.ParseStatement(text, offset, options) 75"];
75 [label="param ParseStatement(string text) 76"];
76 [label="param ParseStatement(int offset = 0) 77"];
77 [label="param ParseStatement(ParseOptions? options = null) 78"];
78 [label="param ParseStatement(bool consumeFullText = true) 79"];
79 [label="text 80"];
80 [label="offset 81"];
81 [label="(CSharpParseOptions?)options 82"];
82 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 83"];
83 [label="param MakeLexer(string text) 84"];
84 [label="param MakeLexer(int offset) 85"];
85 [label="param MakeLexer(CSharpParseOptions? options = null) 86"];
86 [label="text 87"];
87 [label="offset 88"];
88 [label="MakeSourceText(text, offset) 89"];
89 [label="param MakeSourceText(string text) 90"];
90 [label="param MakeSourceText(int offset) 91"];
91 [label="text 92"];
92 [label="Encoding.UTF8 93"];
93 [label="SourceText.From(text, Encoding.UTF8) 94"];
94 [label="SourceText.From(text, Encoding.UTF8) 95"];
95 [label="offset 96"];
96 [label="SourceText.From(text, Encoding.UTF8).GetSubText(offset) 97"];
97 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 98"];
98 [label="text: MakeSourceText(text, offset) 99"];
99 [label="new CSharpParseOptions() 100"];
100 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 101"];
101 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 102"];
102 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 103"];
103 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 104"];
104 [label="param CSharpParseOptions(this) 105"];
105 [label="languageVersion 106"];
106 [label="documentationMode 107"];
107 [label="kind 108"];
108 [label="preprocessorSymbols 109"];
109 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 110"];
110 [label="ImmutableDictionary<string, string>.Empty 111"];
111 [label="param CSharpParseOptions(LanguageVersion languageVersion) 112"];
112 [label="param CSharpParseOptions(DocumentationMode documentationMode) 113"];
113 [label="param CSharpParseOptions(SourceCodeKind kind) 114"];
114 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 115"];
115 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 116"];
116 [label="param CSharpParseOptions(this) 117"];
117 [label="kind 118"];
118 [label="documentationMode 119"];
119 [label="param CSharpParseOptions(this) 120"];
120 [label="_features 121"];
121 [label="public LanguageVersion LanguageVersion { get; private set; } 122"];
122 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 123"];
123 [label="this.SpecifiedLanguageVersion 124"];
124 [label="languageVersion 125"];
125 [label="languageVersion.MapSpecifiedToEffectiveVersion() 126"];
126 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 127"];
127 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 128"];
128 [label="return LanguageVersion.CSharp9; 129"];
129 [label="this.LanguageVersion 130"];
130 [label="preprocessorSymbols 131"];
131 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 132"];
132 [label="this.PreprocessorSymbols 133"];
133 [label="features 134"];
134 [label=".ToImmutableDictionary() 135"];
135 [label="features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty 136"];
136 [label="features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty 137"];
137 [label="_features 138"];
138 [label="public static CSharpParseOptions Default { get; } = new CSharpParseOptions(); 139"];
139 [label="8 140"];
140 [label="TokensLexed 141"];
141 [label="'<<<<<<<' 142"];
142 [label="42 143"];
143 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 144"];
144 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 145"];
145 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 146"];
146 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 147"];
147 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 148"];
148 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 149"];
149 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 150"];
150 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 151"];
151 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 152"];
152 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 153"];
153 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 154"];
154 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 155"];
155 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 156"];
156 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 157"];
157 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 158"];
158 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 159"];
159 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 160"];
160 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 161"];
161 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 162"];
162 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 163"];
163 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 164"];
164 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 165"];
165 [label="MaxCachedTokenSize = 42 166"];
166 [label="s_conflictMarkerLength = '<<<<<<<'.Length 167"];
167 [label="TriviaListInitialCapacity = 8 168"];
168 [label="options ?? CSharpParseOptions.Default 169"];
169 [label="options ?? CSharpParseOptions.Default 170"];
170 [label="options: options ?? CSharpParseOptions.Default 171"];
171 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 172"];
172 [label="param Lexer(SourceText text) 173"];
173 [label="param Lexer(CSharpParseOptions options) 174"];
174 [label="param Lexer(bool allowPreprocessorDirectives = true) 175"];
175 [label="param Lexer(bool interpolationFollowedByColon = false) 176"];
176 [label="param Lexer(this) 177"];
177 [label="text 178"];
178 [label="param AbstractLexer(SourceText text) 179"];
179 [label="param AbstractLexer(this) 180"];
180 [label="TextWindow 181"];
181 [label="_errors 182"];
182 [label="2048 183"];
183 [label="() => new char[DefaultWindowLength] 184"];
184 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 185"];
185 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 186"];
186 [label="DefaultWindowLength = 2048 187"];
187 [label="InvalidCharacter = char.MaxValue 188"];
188 [label="text 189"];
189 [label="new SlidingTextWindow(text) 190"];
190 [label="param SlidingTextWindow(SourceText text) 191"];
191 [label="param SlidingTextWindow(this) 192"];
192 [label="_text 193"];
193 [label="_basis 194"];
194 [label="_offset 195"];
195 [label="_textEnd 196"];
196 [label="_characterWindow 197"];
197 [label="_characterWindowCount 198"];
198 [label="_lexemeStart 199"];
199 [label="_strings 200"];
200 [label="_text 201"];
201 [label="0 202"];
202 [label="_basis 203"];
203 [label="0 204"];
204 [label="_offset 205"];
205 [label="_textEnd 206"];
206 [label="StringTable.GetInstance() 207"];
207 [label="_strings 208"];
208 [label="s_windowPool.Allocate() 209"];
209 [label="_characterWindow 210"];
210 [label="0 211"];
211 [label="_lexemeStart 212"];
212 [label="this.TextWindow 213"];
213 [label="_options 214"];
214 [label="_mode 215"];
215 [label="_builder 216"];
216 [label="_identBuffer 217"];
217 [label="_identLen 218"];
218 [label="_cache 219"];
219 [label="_allowPreprocessorDirectives 220"];
220 [label="_interpolationFollowedByColon 221"];
221 [label="_xmlParser 222"];
222 [label="_badTokenCount 223"];
223 [label="10 224"];
224 [label="new SyntaxListBuilder(10) 225"];
225 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 226"];
226 [label="10 227"];
227 [label="new SyntaxListBuilder(10) 228"];
228 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 229"];
229 [label="_createWhitespaceTriviaFunction 230"];
230 [label="_createQuickTokenFunction 231"];
231 [label="null 232"];
232 [label="options != null 233"];
233 [label="Debug.Assert(options != null) 234"];
234 [label="_options 235"];
235 [label="new StringBuilder() 236"];
236 [label="_builder 237"];
237 [label="32 238"];
238 [label="new char[32] 239"];
239 [label="_identBuffer 240"];
240 [label="512 241"];
241 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 242"];
242 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 243"];
243 [label="10 244"];
244 [label="MaxKeywordLength = 10 245"];
245 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 246"];
246 [label="new LexerCache() 247"];
247 [label="param LexerCache(this) 248"];
248 [label="_triviaMap 249"];
249 [label="_tokenMap 250"];
250 [label="_keywordKindMap 251"];
251 [label="TextKeyedCache<SyntaxTrivia>.GetInstance() 252"];
252 [label="_triviaMap 253"];
253 [label="TextKeyedCache<SyntaxToken>.GetInstance() 254"];
254 [label="_tokenMap 255"];
255 [label="s_keywordKindPool.Allocate() 256"];
256 [label="_keywordKindMap 257"];
257 [label="_cache 258"];
258 [label="_createQuickTokenFunction 259"];
259 [label="_allowPreprocessorDirectives 260"];
260 [label="_interpolationFollowedByColon 261"];
261 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 262"];
262 [label="lexer = MakeLexer(text, offset, (CSharpParseOptions?)options) 263"];
263 [label="lexer 264"];
264 [label="MakeParser(lexer) 265"];
265 [label="param MakeParser(InternalSyntax.Lexer lexer) 266"];
266 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 267"];
267 [label="lexer 268"];
268 [label="null 269"];
269 [label="oldTree: null 270"];
270 [label="null 271"];
271 [label="changes: null 272"];
272 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 273"];
273 [label="param LanguageParser(Lexer lexer) 274"];
274 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 275"];
275 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 276"];
276 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 277"];
277 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 278"];
278 [label="param LanguageParser(this) 279"];
279 [label="() => new BlendedNode[32] 280"];
280 [label="2 281"];
281 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 282"];
282 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 283"];
283 [label="lexer 284"];
284 [label="lexerMode 285"];
285 [label="oldTree 286"];
286 [label="changes 287"];
287 [label="false 288"];
288 [label="true 289"];
289 [label="cancellationToken 290"];
290 [label="param SyntaxParser(Lexer lexer) 291"];
291 [label="param SyntaxParser(LexerMode mode) 292"];
292 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 293"];
293 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 294"];
294 [label="param SyntaxParser(bool allowModeReset) 295"];
295 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 296"];
296 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 297"];
297 [label="param SyntaxParser(this) 298"];
298 [label="lexer 299"];
299 [label="_isIncremental 300"];
300 [label="_allowModeReset 301"];
301 [label="_mode 302"];
302 [label="_currentToken 303"];
303 [label="_lexedTokens 304"];
304 [label="_prevTokenTrailingTrivia 305"];
305 [label="_firstToken 306"];
306 [label="_tokenOffset 307"];
307 [label="_tokenCount 308"];
308 [label="_resetCount 309"];
309 [label="_resetStart 310"];
310 [label="_blendedTokens 311"];
311 [label="this.lexer 312"];
312 [label="_mode 313"];
313 [label="_allowModeReset 314"];
314 [label="this.cancellationToken 315"];
315 [label="default(BlendedNode) 316"];
316 [label="_currentNode 317"];
317 [label="null 318"];
318 [label="oldTree != null 319"];
319 [label="_isIncremental 320"];
320 [label="this.IsIncremental 321"];
321 [label="get\n            {\n                return _isIncremental;\n            } 322"];
322 [label="return _isIncremental; 323"];
323 [label="this.IsIncremental || allowModeReset 324"];
324 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 325"];
325 [label="default(Blender) 326"];
326 [label="_firstBlender 327"];
327 [label="32 328"];
328 [label="new ArrayElement<SyntaxToken>[32] 329"];
329 [label="_lexedTokens 330"];
330 [label="this.IsIncremental 331"];
331 [label="get\n            {\n                return _isIncremental;\n            } 332"];
332 [label="return _isIncremental; 333"];
333 [label="preLexIfNotIncremental && !this.IsIncremental 334"];
334 [label="preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled 335"];
335 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 336"];
336 [label="this.PreLex() 337"];
337 [label="param PreLex(this) 338"];
338 [label="4096 339"];
339 [label="32 340"];
340 [label="this.lexer.TextWindow.Text 341"];
341 [label="=> _text 342"];
342 [label="_text 343"];
343 [label="2 344"];
344 [label="this.lexer.TextWindow.Text.Length / 2 345"];
345 [label="Math.Max(32, this.lexer.TextWindow.Text.Length / 2) 346"];
346 [label="Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)) 347"];
347 [label="size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)) 348"];
348 [label="new ArrayElement<SyntaxToken>[size] 349"];
349 [label="_lexedTokens 350"];
350 [label="lexer = this.lexer 351"];
351 [label="mode = _mode 352"];
352 [label="0 353"];
353 [label="i = 0 354"];
354 [label="i < size 355"];
355 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 356"];
356 [label="mode 357"];
357 [label="lexer.Lex(mode) 358"];
358 [label="param Lex(LexerMode mode) 359"];
359 [label="param Lex(this) 360"];
360 [label="TokensLexed 361"];
361 [label="_mode 362"];
362 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 363"];
363 [label="this.QuickScanSyntaxToken() 364"];
364 [label="this.QuickScanSyntaxToken() 365"];
365 [label="param Start(this) 366"];
366 [label="TextWindow.Start() 367"];
367 [label="param Start(this) 368"];
368 [label="_lexemeStart 369"];
369 [label="null 370"];
370 [label="_errors 371"];
371 [label="get\n            {\n                return _offset;\n            } 372"];
372 [label="return _offset; 373"];
373 [label="this.QuickScanSyntaxToken() 374"];
374 [label="get\n            {\n                return _characterWindowCount;\n            } 375"];
375 [label="return _characterWindowCount; 376"];
376 [label="get\n            {\n                return _characterWindow;\n            } 377"];
377 [label="return _characterWindow; 378"];
378 [label="param AdvanceChar(int n) 379"];
379 [label="param AdvanceChar(this) 380"];
380 [label="_offset += n 381"];
381 [label="_offset 382"];
382 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 383"];
383 [label="_basis + _lexemeStart 384"];
384 [label="return _basis + _lexemeStart; 385"];
385 [label="this.QuickScanSyntaxToken() 386"];
386 [label="param Reset(int position) 387"];
387 [label="param Reset(this) 388"];
388 [label="position - _basis 389"];
389 [label="relative = position - _basis 390"];
390 [label="0 391"];
391 [label="relative >= 0 392"];
392 [label="relative <= _characterWindowCount 393"];
393 [label="relative >= 0 && relative <= _characterWindowCount 394"];
394 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 395"];
395 [label="_offset 396"];
396 [label="this.LexSyntaxToken() 397"];
397 [label="param LexSyntaxToken(this) 398"];
398 [label="_leadingTriviaCache.Clear() 399"];
399 [label="TextWindow.Position 400"];
400 [label="get\n            {\n                return _basis + _offset;\n            } 401"];
401 [label="_basis + _offset 402"];
402 [label="return _basis + _offset; 403"];
403 [label="0 404"];
404 [label="TextWindow.Position > 0 405"];
405 [label="afterFirstToken: TextWindow.Position > 0 406"];
406 [label="false 407"];
407 [label="isTrailing: false 408"];
408 [label="triviaList: ref _leadingTriviaCache 409"];
409 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 410"];
410 [label="param LexSyntaxTrivia(bool afterFirstToken) 411"];
411 [label="param LexSyntaxTrivia(bool isTrailing) 412"];
412 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 413"];
413 [label="param LexSyntaxTrivia(this) 414"];
414 [label="onlyWhitespaceOnLine = !isTrailing 415"];
415 [label="true 416"];
416 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 417"];
417 [label="this.Start() 418"];
418 [label="param Start(this) 419"];
419 [label="TextWindow.Start() 420"];
420 [label="param Start(this) 421"];
421 [label="null 422"];
422 [label="_errors 423"];
423 [label="TextWindow.PeekChar() 424"];
424 [label="param PeekChar(this) 425"];
425 [label="_offset >= _characterWindowCount 426"];
426 [label="MoreChars() 427"];
427 [label="param MoreChars(this) 428"];
428 [label="_offset >= _characterWindowCount 429"];
429 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 430"];
430 [label="this.Position 431"];
431 [label="get\n            {\n                return _basis + _offset;\n            } 432"];
432 [label="_basis + _offset 433"];
433 [label="return _basis + _offset; 434"];
434 [label="this.Position >= _textEnd 435"];
435 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 436"];
436 [label="4 437"];
437 [label="_characterWindowCount / 4 438"];
438 [label="_lexemeStart > (_characterWindowCount / 4) 439"];
439 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 440"];
440 [label="_characterWindowCount >= _characterWindow.Length 441"];
441 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 442"];
442 [label="_basis + _characterWindowCount 443"];
443 [label="_textEnd - (_basis + _characterWindowCount) 444"];
444 [label="_characterWindow.Length - _characterWindowCount 445"];
445 [label="Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount) 446"];
446 [label="amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount) 447"];
447 [label="_basis + _characterWindowCount 448"];
448 [label="_characterWindow 449"];
449 [label="_characterWindowCount 450"];
450 [label="amountToRead 451"];
451 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead) 452"];
452 [label="_characterWindowCount += amountToRead 453"];
453 [label="_characterWindowCount 454"];
454 [label="0 455"];
455 [label="amountToRead > 0 456"];
456 [label="return amountToRead > 0; 457"];
457 [label="_offset >= _characterWindowCount\n                && !MoreChars() 458"];
458 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 459"];
459 [label="_characterWindow[_offset] 460"];
460 [label="return _characterWindow[_offset]; 461"];
461 [label="ch = TextWindow.PeekChar() 462"];
462 [label="' ' 463"];
463 [label="ch == ' ' 464"];
464 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 465"];
465 [label="127 466"];
466 [label="ch > 127 467"];
467 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 468"];
468 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 469"];
469 [label="return; 470"];
470 [label="leading = _leadingTriviaCache 471"];
471 [label="default(TokenInfo) 472"];
472 [label="tokenInfo = default(TokenInfo) 473"];
473 [label="this.Start() 474"];
474 [label="param Start(this) 475"];
475 [label="TextWindow.Start() 476"];
476 [label="param Start(this) 477"];
477 [label="null 478"];
478 [label="_errors 479"];
479 [label="ref tokenInfo 480"];
480 [label="this.ScanSyntaxToken(ref tokenInfo) 481"];
481 [label="this.ScanSyntaxToken(ref tokenInfo) 482"];
482 [label="get\n            {\n                return _basis + _offset;\n            } 483"];
483 [label="_basis + _offset 484"];
484 [label="return _basis + _offset; 485"];
485 [label="_offset >= _characterWindowCount 486"];
486 [label="_offset >= _characterWindowCount\n                && !MoreChars() 487"];
487 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 488"];
488 [label="_characterWindow[_offset] 489"];
489 [label="return _characterWindow[_offset]; 490"];
490 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 491"];
491 [label="param ScanIdentifierOrKeyword(this) 492"];
492 [label="info.ContextualKind 493"];
493 [label="ref info 494"];
494 [label="this.ScanIdentifier(ref info) 495"];
495 [label="param ScanIdentifier(ref TokenInfo info) 496"];
496 [label="param ScanIdentifier(this) 497"];
497 [label="ref info 498"];
498 [label="ScanIdentifier_FastPath(ref info) 499"];
499 [label="ScanIdentifier_FastPath(ref info) 500"];
500 [label="param Intern(char[] array) 501"];
501 [label="param Intern(int start) 502"];
502 [label="param Intern(int length) 503"];
503 [label="param Intern(this) 504"];
504 [label="array 505"];
505 [label="start 506"];
506 [label="length 507"];
507 [label="_strings.Add(array, start, length) 508"];
508 [label="return _strings.Add(array, start, length); 509"];
509 [label="ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)) 510"];
510 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 511"];
511 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 512"];
512 [label="!info.IsVerbatim && !info.HasIdentifierEscapeSequence 513"];
513 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 514"];
514 [label="LexerMode.Directive 515"];
515 [label="this.ModeIs(LexerMode.Directive) 516"];
516 [label="param ModeIs(LexerMode mode) 517"];
517 [label="param ModeIs(this) 518"];
518 [label="_mode 519"];
519 [label="ModeOf(_mode) 520"];
520 [label="param ModeOf(LexerMode mode) 521"];
521 [label="mode & LexerMode.MaskLexMode 522"];
522 [label="return mode & LexerMode.MaskLexMode; 523"];
523 [label="ModeOf(_mode) == mode 524"];
524 [label="return ModeOf(_mode) == mode; 525"];
525 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 526"];
526 [label="info.Text 527"];
527 [label="out info.Kind 528"];
528 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 529"];
529 [label="param TryGetKeywordKind(string key) 530"];
530 [label="param TryGetKeywordKind(out SyntaxKind kind) 531"];
531 [label="param TryGetKeywordKind(this) 532"];
532 [label="key.Length > MaxKeywordLength 533"];
533 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 534"];
534 [label="new SyntaxKindEqualityComparer() 535"];
535 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 536"];
536 [label="key 537"];
537 [label="_keywordKindMap.GetOrMakeValue(key) 538"];
538 [label="_keywordKindMap.GetOrMakeValue(key) 539"];
539 [label="param GetKeywordKind(string text) 540"];
540 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 541"];
541 [label="return SyntaxKind.None; 542"];
542 [label="param GetContextualKeywordKind(string text) 543"];
543 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 544"];
544 [label="return SyntaxKind.None; 545"];
545 [label="_keywordKindMap.GetOrMakeValue(key) 546"];
546 [label="kind 547"];
547 [label="kind != SyntaxKind.None 548"];
548 [label="return kind != SyntaxKind.None; 549"];
549 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 550"];
550 [label="info.Kind 551"];
551 [label="info.ContextualKind 552"];
552 [label="info.Kind == SyntaxKind.None 553"];
553 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 554"];
554 [label="true 555"];
555 [label="return true; 556"];
556 [label="this.ScanSyntaxToken(ref tokenInfo) 557"];
557 [label="leading 558"];
558 [label="GetFullWidth(leading) 559"];
559 [label="param GetFullWidth(SyntaxListBuilder builder) 560"];
560 [label="0 561"];
561 [label="width = 0 562"];
562 [label="null 563"];
563 [label="builder != null 564"];
564 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 565"];
565 [label="0 566"];
566 [label="i = 0 567"];
567 [label="i < builder.Count 568"];
568 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 569"];
569 [label="return width; 570"];
570 [label="this.GetErrors(GetFullWidth(leading)) 571"];
571 [label="param GetErrors(int leadingTriviaWidth) 572"];
572 [label="param GetErrors(this) 573"];
573 [label="null 574"];
574 [label="_errors != null 575"];
575 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 576"];
576 [label="null 577"];
577 [label="return null; 578"];
578 [label="errors = this.GetErrors(GetFullWidth(leading)) 579"];
579 [label="_trailingTriviaCache.Clear() 580"];
580 [label="true 581"];
581 [label="afterFirstToken: true 582"];
582 [label="true 583"];
583 [label="isTrailing: true 584"];
584 [label="triviaList: ref _trailingTriviaCache 585"];
585 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 586"];
586 [label="trailing = _trailingTriviaCache 587"];
587 [label="ref tokenInfo 588"];
588 [label="leading 589"];
589 [label="trailing 590"];
590 [label="errors 591"];
591 [label="Create(ref tokenInfo, leading, trailing, errors) 592"];
592 [label="param Create(ref TokenInfo info) 593"];
593 [label="param Create(SyntaxListBuilder leading) 594"];
594 [label="param Create(SyntaxListBuilder trailing) 595"];
595 [label="param Create(SyntaxDiagnosticInfo[] errors) 596"];
596 [label="param Create(this) 597"];
597 [label="info.Kind != SyntaxKind.IdentifierToken 598"];
598 [label="null 599"];
599 [label="info.StringValue != null 600"];
600 [label="info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null 601"];
601 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null) 602"];
602 [label=".ToListNode() 603"];
603 [label="leadingNode = leading?.ToListNode() 604"];
604 [label=".ToListNode() 605"];
605 [label="trailingNode = trailing?.ToListNode() 606"];
606 [label="token 607"];
607 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 608"];
608 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 609"];
609 [label="'\\r\\n' 610"];
610 [label="CrLf 611"];
611 [label="EndOfLine(CrLf) 612"];
612 [label="param EndOfLine(string text) 613"];
613 [label="param EndOfLine(bool elastic = false) 614"];
614 [label="null 615"];
615 [label="trivia = null 616"];
616 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 617"];
617 [label="elastic 618"];
618 [label="SyntaxFactory.CarriageReturnLineFeed 619"];
619 [label="trivia 620"];
620 [label="null 621"];
621 [label="trivia != null 622"];
622 [label="if (trivia != null)\n            {\n                return trivia;\n            } 623"];
623 [label="typeof(SyntaxTrivia) 624"];
624 [label="r => new SyntaxTrivia(r) 625"];
625 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)) 626"];
626 [label="SyntaxKind.EndOfLineTrivia 627"];
627 [label="text 628"];
628 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 629"];
629 [label="param Create(SyntaxKind kind) 630"];
630 [label="param Create(string text) 631"];
631 [label="kind 632"];
632 [label="text 633"];
633 [label="new SyntaxTrivia(kind, text) 634"];
634 [label="param SyntaxTrivia(SyntaxKind kind) 635"];
635 [label="param SyntaxTrivia(string text) 636"];
636 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 637"];
637 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 638"];
638 [label="param SyntaxTrivia(this) 639"];
639 [label="kind 640"];
640 [label="diagnostics 641"];
641 [label="annotations 642"];
642 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 643"];
643 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 644"];
644 [label="text 645"];
645 [label="param CSharpSyntaxNode(SyntaxKind kind) 646"];
646 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 647"];
647 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 648"];
648 [label="param CSharpSyntaxNode(int fullWidth) 649"];
649 [label="param CSharpSyntaxNode(this) 650"];
650 [label="kind 651"];
651 [label="diagnostics 652"];
652 [label="annotations 653"];
653 [label="fullWidth 654"];
654 [label="param CSharpSyntaxNode(this) 655"];
655 [label="this 656"];
656 [label="GreenStats.NoteGreen(this) 657"];
657 [label="Text 658"];
658 [label="this.Text 659"];
659 [label="kind == SyntaxKind.PreprocessingMessageTrivia 660"];
660 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 661"];
661 [label="return new SyntaxTrivia(kind, text); 662"];
662 [label="trivia 663"];
663 [label="if (!elastic)\n            {\n                return trivia;\n            } 664"];
664 [label="return trivia; 665"];
665 [label="'\\n' 666"];
666 [label="EndOfLine('\\n') 667"];
667 [label="param EndOfLine(string text) 668"];
668 [label="param EndOfLine(bool elastic = false) 669"];
669 [label="null 670"];
670 [label="trivia = null 671"];
671 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 672"];
672 [label="elastic 673"];
673 [label="SyntaxFactory.LineFeed 674"];
674 [label="trivia 675"];
675 [label="null 676"];
676 [label="trivia != null 677"];
677 [label="if (trivia != null)\n            {\n                return trivia;\n            } 678"];
678 [label="SyntaxKind.EndOfLineTrivia 679"];
679 [label="text 680"];
680 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 681"];
681 [label="param Create(SyntaxKind kind) 682"];
682 [label="param Create(string text) 683"];
683 [label="kind 684"];
684 [label="text 685"];
685 [label="new SyntaxTrivia(kind, text) 686"];
686 [label="param SyntaxTrivia(SyntaxKind kind) 687"];
687 [label="param SyntaxTrivia(string text) 688"];
688 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 689"];
689 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 690"];
690 [label="param SyntaxTrivia(this) 691"];
691 [label="kind 692"];
692 [label="diagnostics 693"];
693 [label="annotations 694"];
694 [label="text 695"];
695 [label="param CSharpSyntaxNode(SyntaxKind kind) 696"];
696 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 697"];
697 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 698"];
698 [label="param CSharpSyntaxNode(int fullWidth) 699"];
699 [label="param CSharpSyntaxNode(this) 700"];
700 [label="kind 701"];
701 [label="diagnostics 702"];
702 [label="annotations 703"];
703 [label="fullWidth 704"];
704 [label="param CSharpSyntaxNode(this) 705"];
705 [label="this 706"];
706 [label="GreenStats.NoteGreen(this) 707"];
707 [label="Text 708"];
708 [label="this.Text 709"];
709 [label="kind == SyntaxKind.PreprocessingMessageTrivia 710"];
710 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 711"];
711 [label="return new SyntaxTrivia(kind, text); 712"];
712 [label="trivia 713"];
713 [label="if (!elastic)\n            {\n                return trivia;\n            } 714"];
714 [label="return trivia; 715"];
715 [label="'\\r' 716"];
716 [label="EndOfLine('\\r') 717"];
717 [label="param EndOfLine(string text) 718"];
718 [label="param EndOfLine(bool elastic = false) 719"];
719 [label="null 720"];
720 [label="trivia = null 721"];
721 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 722"];
722 [label="elastic 723"];
723 [label="SyntaxFactory.CarriageReturn 724"];
724 [label="trivia 725"];
725 [label="null 726"];
726 [label="trivia != null 727"];
727 [label="if (trivia != null)\n            {\n                return trivia;\n            } 728"];
728 [label="SyntaxKind.EndOfLineTrivia 729"];
729 [label="text 730"];
730 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 731"];
731 [label="param Create(SyntaxKind kind) 732"];
732 [label="param Create(string text) 733"];
733 [label="kind 734"];
734 [label="text 735"];
735 [label="new SyntaxTrivia(kind, text) 736"];
736 [label="param SyntaxTrivia(SyntaxKind kind) 737"];
737 [label="param SyntaxTrivia(string text) 738"];
738 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 739"];
739 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 740"];
740 [label="param SyntaxTrivia(this) 741"];
741 [label="kind 742"];
742 [label="diagnostics 743"];
743 [label="annotations 744"];
744 [label="text 745"];
745 [label="param CSharpSyntaxNode(SyntaxKind kind) 746"];
746 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 747"];
747 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 748"];
748 [label="param CSharpSyntaxNode(int fullWidth) 749"];
749 [label="param CSharpSyntaxNode(this) 750"];
750 [label="kind 751"];
751 [label="diagnostics 752"];
752 [label="annotations 753"];
753 [label="fullWidth 754"];
754 [label="param CSharpSyntaxNode(this) 755"];
755 [label="this 756"];
756 [label="GreenStats.NoteGreen(this) 757"];
757 [label="Text 758"];
758 [label="this.Text 759"];
759 [label="kind == SyntaxKind.PreprocessingMessageTrivia 760"];
760 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 761"];
761 [label="return new SyntaxTrivia(kind, text); 762"];
762 [label="trivia 763"];
763 [label="if (!elastic)\n            {\n                return trivia;\n            } 764"];
764 [label="return trivia; 765"];
765 [label="' ' 766"];
766 [label="Whitespace(' ') 767"];
767 [label="param Whitespace(string text) 768"];
768 [label="param Whitespace(bool elastic = false) 769"];
769 [label="SyntaxKind.WhitespaceTrivia 770"];
770 [label="text 771"];
771 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 772"];
772 [label="param Create(SyntaxKind kind) 773"];
773 [label="param Create(string text) 774"];
774 [label="kind 775"];
775 [label="text 776"];
776 [label="new SyntaxTrivia(kind, text) 777"];
777 [label="param SyntaxTrivia(SyntaxKind kind) 778"];
778 [label="param SyntaxTrivia(string text) 779"];
779 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 780"];
780 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 781"];
781 [label="param SyntaxTrivia(this) 782"];
782 [label="kind 783"];
783 [label="diagnostics 784"];
784 [label="annotations 785"];
785 [label="text 786"];
786 [label="param CSharpSyntaxNode(SyntaxKind kind) 787"];
787 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 788"];
788 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 789"];
789 [label="param CSharpSyntaxNode(int fullWidth) 790"];
790 [label="param CSharpSyntaxNode(this) 791"];
791 [label="kind 792"];
792 [label="diagnostics 793"];
793 [label="annotations 794"];
794 [label="fullWidth 795"];
795 [label="param CSharpSyntaxNode(this) 796"];
796 [label="this 797"];
797 [label="GreenStats.NoteGreen(this) 798"];
798 [label="Text 799"];
799 [label="this.Text 800"];
800 [label="kind == SyntaxKind.PreprocessingMessageTrivia 801"];
801 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 802"];
802 [label="return new SyntaxTrivia(kind, text); 803"];
803 [label="trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 804"];
804 [label="if (!elastic)\n            {\n                return trivia;\n            } 805"];
805 [label="return trivia; 806"];
806 [label="'\\t' 807"];
807 [label="Whitespace('\\t') 808"];
808 [label="param Whitespace(string text) 809"];
809 [label="param Whitespace(bool elastic = false) 810"];
810 [label="SyntaxKind.WhitespaceTrivia 811"];
811 [label="text 812"];
812 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 813"];
813 [label="param Create(SyntaxKind kind) 814"];
814 [label="param Create(string text) 815"];
815 [label="kind 816"];
816 [label="text 817"];
817 [label="new SyntaxTrivia(kind, text) 818"];
818 [label="param SyntaxTrivia(SyntaxKind kind) 819"];
819 [label="param SyntaxTrivia(string text) 820"];
820 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 821"];
821 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 822"];
822 [label="param SyntaxTrivia(this) 823"];
823 [label="kind 824"];
824 [label="diagnostics 825"];
825 [label="annotations 826"];
826 [label="text 827"];
827 [label="param CSharpSyntaxNode(SyntaxKind kind) 828"];
828 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 829"];
829 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 830"];
830 [label="param CSharpSyntaxNode(int fullWidth) 831"];
831 [label="param CSharpSyntaxNode(this) 832"];
832 [label="kind 833"];
833 [label="diagnostics 834"];
834 [label="annotations 835"];
835 [label="fullWidth 836"];
836 [label="param CSharpSyntaxNode(this) 837"];
837 [label="this 838"];
838 [label="GreenStats.NoteGreen(this) 839"];
839 [label="Text 840"];
840 [label="this.Text 841"];
841 [label="kind == SyntaxKind.PreprocessingMessageTrivia 842"];
842 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 843"];
843 [label="return new SyntaxTrivia(kind, text); 844"];
844 [label="trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 845"];
845 [label="if (!elastic)\n            {\n                return trivia;\n            } 846"];
846 [label="return trivia; 847"];
847 [label="CrLf 848"];
848 [label="true 849"];
849 [label="elastic: true 850"];
850 [label="EndOfLine(CrLf, elastic: true) 851"];
851 [label="param EndOfLine(string text) 852"];
852 [label="param EndOfLine(bool elastic = false) 853"];
853 [label="null 854"];
854 [label="trivia = null 855"];
855 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 856"];
856 [label="elastic 857"];
857 [label="SyntaxFactory.ElasticCarriageReturnLineFeed 858"];
858 [label="trivia 859"];
859 [label="null 860"];
860 [label="trivia != null 861"];
861 [label="if (trivia != null)\n            {\n                return trivia;\n            } 862"];
862 [label="SyntaxKind.EndOfLineTrivia 863"];
863 [label="text 864"];
864 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 865"];
865 [label="param Create(SyntaxKind kind) 866"];
866 [label="param Create(string text) 867"];
867 [label="kind 868"];
868 [label="text 869"];
869 [label="new SyntaxTrivia(kind, text) 870"];
870 [label="param SyntaxTrivia(SyntaxKind kind) 871"];
871 [label="param SyntaxTrivia(string text) 872"];
872 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 873"];
873 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 874"];
874 [label="param SyntaxTrivia(this) 875"];
875 [label="kind 876"];
876 [label="diagnostics 877"];
877 [label="annotations 878"];
878 [label="text 879"];
879 [label="param CSharpSyntaxNode(SyntaxKind kind) 880"];
880 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 881"];
881 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 882"];
882 [label="param CSharpSyntaxNode(int fullWidth) 883"];
883 [label="param CSharpSyntaxNode(this) 884"];
884 [label="kind 885"];
885 [label="diagnostics 886"];
886 [label="annotations 887"];
887 [label="fullWidth 888"];
888 [label="param CSharpSyntaxNode(this) 889"];
889 [label="this 890"];
890 [label="GreenStats.NoteGreen(this) 891"];
891 [label="Text 892"];
892 [label="this.Text 893"];
893 [label="kind == SyntaxKind.PreprocessingMessageTrivia 894"];
894 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 895"];
895 [label="return new SyntaxTrivia(kind, text); 896"];
896 [label="trivia 897"];
897 [label="if (!elastic)\n            {\n                return trivia;\n            } 898"];
898 [label="trivia 899"];
899 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 900"];
900 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 901"];
901 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 902"];
902 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 903"];
903 [label="param SetAnnotations(this) 904"];
904 [label="this.Kind 905"];
905 [label="get { return (SyntaxKind)this.RawKind; } 906"];
906 [label="return (SyntaxKind)this.RawKind; 907"];
907 [label="this.Text 908"];
908 [label="GetDiagnostics() 909"];
909 [label="annotations 910"];
910 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 911"];
911 [label="param SyntaxTrivia(SyntaxKind kind) 912"];
912 [label="param SyntaxTrivia(string text) 913"];
913 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 914"];
914 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 915"];
915 [label="param SyntaxTrivia(this) 916"];
916 [label="param CSharpSyntaxNode(this) 917"];
917 [label="param CSharpSyntaxNode(this) 918"];
918 [label="this 919"];
919 [label="Text 920"];
920 [label="kind == SyntaxKind.PreprocessingMessageTrivia 921"];
921 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 922"];
922 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 923"];
923 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 924"];
924 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 925"];
925 [label="'\\n' 926"];
926 [label="true 927"];
927 [label="elastic: true 928"];
928 [label="EndOfLine('\\n', elastic: true) 929"];
929 [label="param EndOfLine(string text) 930"];
930 [label="param EndOfLine(bool elastic = false) 931"];
931 [label="null 932"];
932 [label="trivia = null 933"];
933 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 934"];
934 [label="elastic 935"];
935 [label="SyntaxFactory.ElasticLineFeed 936"];
936 [label="trivia 937"];
937 [label="null 938"];
938 [label="trivia != null 939"];
939 [label="if (trivia != null)\n            {\n                return trivia;\n            } 940"];
940 [label="SyntaxKind.EndOfLineTrivia 941"];
941 [label="text 942"];
942 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 943"];
943 [label="param Create(SyntaxKind kind) 944"];
944 [label="param Create(string text) 945"];
945 [label="kind 946"];
946 [label="text 947"];
947 [label="new SyntaxTrivia(kind, text) 948"];
948 [label="param SyntaxTrivia(SyntaxKind kind) 949"];
949 [label="param SyntaxTrivia(string text) 950"];
950 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 951"];
951 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 952"];
952 [label="param SyntaxTrivia(this) 953"];
953 [label="kind 954"];
954 [label="diagnostics 955"];
955 [label="annotations 956"];
956 [label="text 957"];
957 [label="param CSharpSyntaxNode(SyntaxKind kind) 958"];
958 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 959"];
959 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 960"];
960 [label="param CSharpSyntaxNode(int fullWidth) 961"];
961 [label="param CSharpSyntaxNode(this) 962"];
962 [label="kind 963"];
963 [label="diagnostics 964"];
964 [label="annotations 965"];
965 [label="fullWidth 966"];
966 [label="param CSharpSyntaxNode(this) 967"];
967 [label="this 968"];
968 [label="GreenStats.NoteGreen(this) 969"];
969 [label="Text 970"];
970 [label="this.Text 971"];
971 [label="kind == SyntaxKind.PreprocessingMessageTrivia 972"];
972 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 973"];
973 [label="return new SyntaxTrivia(kind, text); 974"];
974 [label="trivia 975"];
975 [label="if (!elastic)\n            {\n                return trivia;\n            } 976"];
976 [label="trivia 977"];
977 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 978"];
978 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 979"];
979 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 980"];
980 [label="this.Kind 981"];
981 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 982"];
982 [label="param SyntaxTrivia(this) 983"];
983 [label="param CSharpSyntaxNode(this) 984"];
984 [label="this 985"];
985 [label="Text 986"];
986 [label="kind == SyntaxKind.PreprocessingMessageTrivia 987"];
987 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 988"];
988 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 989"];
989 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 990"];
990 [label="'\\r' 991"];
991 [label="true 992"];
992 [label="elastic: true 993"];
993 [label="EndOfLine('\\r', elastic: true) 994"];
994 [label="param EndOfLine(string text) 995"];
995 [label="param EndOfLine(bool elastic = false) 996"];
996 [label="null 997"];
997 [label="trivia = null 998"];
998 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 999"];
999 [label="elastic 1000"];
1000 [label="SyntaxFactory.ElasticCarriageReturn 1001"];
1001 [label="trivia 1002"];
1002 [label="null 1003"];
1003 [label="trivia != null 1004"];
1004 [label="if (trivia != null)\n            {\n                return trivia;\n            } 1005"];
1005 [label="SyntaxKind.EndOfLineTrivia 1006"];
1006 [label="text 1007"];
1007 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 1008"];
1008 [label="param Create(SyntaxKind kind) 1009"];
1009 [label="param Create(string text) 1010"];
1010 [label="kind 1011"];
1011 [label="text 1012"];
1012 [label="new SyntaxTrivia(kind, text) 1013"];
1013 [label="param SyntaxTrivia(SyntaxKind kind) 1014"];
1014 [label="param SyntaxTrivia(string text) 1015"];
1015 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 1016"];
1016 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 1017"];
1017 [label="param SyntaxTrivia(this) 1018"];
1018 [label="kind 1019"];
1019 [label="diagnostics 1020"];
1020 [label="annotations 1021"];
1021 [label="text 1022"];
1022 [label="param CSharpSyntaxNode(SyntaxKind kind) 1023"];
1023 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 1024"];
1024 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 1025"];
1025 [label="param CSharpSyntaxNode(int fullWidth) 1026"];
1026 [label="param CSharpSyntaxNode(this) 1027"];
1027 [label="kind 1028"];
1028 [label="diagnostics 1029"];
1029 [label="annotations 1030"];
1030 [label="fullWidth 1031"];
1031 [label="param CSharpSyntaxNode(this) 1032"];
1032 [label="this 1033"];
1033 [label="GreenStats.NoteGreen(this) 1034"];
1034 [label="Text 1035"];
1035 [label="this.Text 1036"];
1036 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1037"];
1037 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1038"];
1038 [label="return new SyntaxTrivia(kind, text); 1039"];
1039 [label="trivia 1040"];
1040 [label="if (!elastic)\n            {\n                return trivia;\n            } 1041"];
1041 [label="trivia 1042"];
1042 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 1043"];
1043 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1044"];
1044 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1045"];
1045 [label="this.Kind 1046"];
1046 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 1047"];
1047 [label="param SyntaxTrivia(this) 1048"];
1048 [label="param CSharpSyntaxNode(this) 1049"];
1049 [label="this 1050"];
1050 [label="Text 1051"];
1051 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1052"];
1052 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1053"];
1053 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 1054"];
1054 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 1055"];
1055 [label="' ' 1056"];
1056 [label="true 1057"];
1057 [label="elastic: true 1058"];
1058 [label="Whitespace(' ', elastic: true) 1059"];
1059 [label="param Whitespace(string text) 1060"];
1060 [label="param Whitespace(bool elastic = false) 1061"];
1061 [label="SyntaxKind.WhitespaceTrivia 1062"];
1062 [label="text 1063"];
1063 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 1064"];
1064 [label="param Create(SyntaxKind kind) 1065"];
1065 [label="param Create(string text) 1066"];
1066 [label="kind 1067"];
1067 [label="text 1068"];
1068 [label="new SyntaxTrivia(kind, text) 1069"];
1069 [label="param SyntaxTrivia(SyntaxKind kind) 1070"];
1070 [label="param SyntaxTrivia(string text) 1071"];
1071 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 1072"];
1072 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 1073"];
1073 [label="param SyntaxTrivia(this) 1074"];
1074 [label="kind 1075"];
1075 [label="diagnostics 1076"];
1076 [label="annotations 1077"];
1077 [label="text 1078"];
1078 [label="param CSharpSyntaxNode(SyntaxKind kind) 1079"];
1079 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 1080"];
1080 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 1081"];
1081 [label="param CSharpSyntaxNode(int fullWidth) 1082"];
1082 [label="param CSharpSyntaxNode(this) 1083"];
1083 [label="kind 1084"];
1084 [label="diagnostics 1085"];
1085 [label="annotations 1086"];
1086 [label="fullWidth 1087"];
1087 [label="param CSharpSyntaxNode(this) 1088"];
1088 [label="this 1089"];
1089 [label="GreenStats.NoteGreen(this) 1090"];
1090 [label="Text 1091"];
1091 [label="this.Text 1092"];
1092 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1093"];
1093 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1094"];
1094 [label="return new SyntaxTrivia(kind, text); 1095"];
1095 [label="trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 1096"];
1096 [label="if (!elastic)\n            {\n                return trivia;\n            } 1097"];
1097 [label="trivia 1098"];
1098 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 1099"];
1099 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1100"];
1100 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1101"];
1101 [label="this.Kind 1102"];
1102 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 1103"];
1103 [label="param SyntaxTrivia(this) 1104"];
1104 [label="param CSharpSyntaxNode(this) 1105"];
1105 [label="this 1106"];
1106 [label="Text 1107"];
1107 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1108"];
1108 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1109"];
1109 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 1110"];
1110 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 1111"];
1111 [label="'\\t' 1112"];
1112 [label="true 1113"];
1113 [label="elastic: true 1114"];
1114 [label="Whitespace('\\t', elastic: true) 1115"];
1115 [label="param Whitespace(string text) 1116"];
1116 [label="param Whitespace(bool elastic = false) 1117"];
1117 [label="SyntaxKind.WhitespaceTrivia 1118"];
1118 [label="text 1119"];
1119 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 1120"];
1120 [label="param Create(SyntaxKind kind) 1121"];
1121 [label="param Create(string text) 1122"];
1122 [label="kind 1123"];
1123 [label="text 1124"];
1124 [label="new SyntaxTrivia(kind, text) 1125"];
1125 [label="param SyntaxTrivia(SyntaxKind kind) 1126"];
1126 [label="param SyntaxTrivia(string text) 1127"];
1127 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 1128"];
1128 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 1129"];
1129 [label="param SyntaxTrivia(this) 1130"];
1130 [label="kind 1131"];
1131 [label="diagnostics 1132"];
1132 [label="annotations 1133"];
1133 [label="text 1134"];
1134 [label="param CSharpSyntaxNode(SyntaxKind kind) 1135"];
1135 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 1136"];
1136 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 1137"];
1137 [label="param CSharpSyntaxNode(int fullWidth) 1138"];
1138 [label="param CSharpSyntaxNode(this) 1139"];
1139 [label="kind 1140"];
1140 [label="diagnostics 1141"];
1141 [label="annotations 1142"];
1142 [label="fullWidth 1143"];
1143 [label="param CSharpSyntaxNode(this) 1144"];
1144 [label="this 1145"];
1145 [label="GreenStats.NoteGreen(this) 1146"];
1146 [label="Text 1147"];
1147 [label="this.Text 1148"];
1148 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1149"];
1149 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1150"];
1150 [label="return new SyntaxTrivia(kind, text); 1151"];
1151 [label="trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 1152"];
1152 [label="if (!elastic)\n            {\n                return trivia;\n            } 1153"];
1153 [label="trivia 1154"];
1154 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 1155"];
1155 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1156"];
1156 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1157"];
1157 [label="this.Kind 1158"];
1158 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 1159"];
1159 [label="param SyntaxTrivia(this) 1160"];
1160 [label="param CSharpSyntaxNode(this) 1161"];
1161 [label="this 1162"];
1162 [label="Text 1163"];
1163 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1164"];
1164 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1165"];
1165 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 1166"];
1166 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 1167"];
1167 [label="string.Empty 1168"];
1168 [label="true 1169"];
1169 [label="elastic: true 1170"];
1170 [label="Whitespace(string.Empty, elastic: true) 1171"];
1171 [label="param Whitespace(string text) 1172"];
1172 [label="param Whitespace(bool elastic = false) 1173"];
1173 [label="SyntaxKind.WhitespaceTrivia 1174"];
1174 [label="text 1175"];
1175 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 1176"];
1176 [label="param Create(SyntaxKind kind) 1177"];
1177 [label="param Create(string text) 1178"];
1178 [label="kind 1179"];
1179 [label="text 1180"];
1180 [label="new SyntaxTrivia(kind, text) 1181"];
1181 [label="param SyntaxTrivia(SyntaxKind kind) 1182"];
1182 [label="param SyntaxTrivia(string text) 1183"];
1183 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 1184"];
1184 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 1185"];
1185 [label="param SyntaxTrivia(this) 1186"];
1186 [label="kind 1187"];
1187 [label="diagnostics 1188"];
1188 [label="annotations 1189"];
1189 [label="text 1190"];
1190 [label="param CSharpSyntaxNode(SyntaxKind kind) 1191"];
1191 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 1192"];
1192 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 1193"];
1193 [label="param CSharpSyntaxNode(int fullWidth) 1194"];
1194 [label="param CSharpSyntaxNode(this) 1195"];
1195 [label="kind 1196"];
1196 [label="diagnostics 1197"];
1197 [label="annotations 1198"];
1198 [label="fullWidth 1199"];
1199 [label="param CSharpSyntaxNode(this) 1200"];
1200 [label="this 1201"];
1201 [label="GreenStats.NoteGreen(this) 1202"];
1202 [label="Text 1203"];
1203 [label="this.Text 1204"];
1204 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1205"];
1205 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1206"];
1206 [label="return new SyntaxTrivia(kind, text); 1207"];
1207 [label="trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 1208"];
1208 [label="if (!elastic)\n            {\n                return trivia;\n            } 1209"];
1209 [label="trivia 1210"];
1210 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 1211"];
1211 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1212"];
1212 [label="trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }) 1213"];
1213 [label="this.Kind 1214"];
1214 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 1215"];
1215 [label="param SyntaxTrivia(this) 1216"];
1216 [label="param CSharpSyntaxNode(this) 1217"];
1217 [label="this 1218"];
1218 [label="Text 1219"];
1219 [label="kind == SyntaxKind.PreprocessingMessageTrivia 1220"];
1220 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 1221"];
1221 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 1222"];
1222 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 1223"];
1223 [label="s_xmlCarriageReturnLineFeed 1224"];
1224 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 1225"];
1225 [label="ElasticTab = Whitespace('\\t', elastic: true) 1226"];
1226 [label="ElasticSpace = Whitespace(' ', elastic: true) 1227"];
1227 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 1228"];
1228 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 1229"];
1229 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 1230"];
1230 [label="Tab = Whitespace('\\t') 1231"];
1231 [label="Space = Whitespace(' ') 1232"];
1232 [label="CarriageReturn = EndOfLine('\\r') 1233"];
1233 [label="LineFeed = EndOfLine('\\n') 1234"];
1234 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 1235"];
1235 [label="CrLf = '\\r\\n' 1236"];
1236 [label="info.ContextualKind 1237"];
1237 [label="leadingNode 1238"];
1238 [label="info.Text 1239"];
1239 [label="info.StringValue 1240"];
1240 [label="trailingNode 1241"];
1241 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 1242"];
1242 [label="param Identifier(SyntaxKind contextualKind) 1243"];
1243 [label="param Identifier(GreenNode leading) 1244"];
1244 [label="param Identifier(string text) 1245"];
1245 [label="param Identifier(string valueText) 1246"];
1246 [label="param Identifier(GreenNode trailing) 1247"];
1247 [label="1 1248"];
1248 [label="(int)LastTokenWithWellKnownText + 1 1249"];
1249 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1250"];
1250 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1251"];
1251 [label="1 1252"];
1252 [label="(int)LastTokenWithWellKnownText + 1 1253"];
1253 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1254"];
1254 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1255"];
1255 [label="1 1256"];
1256 [label="(int)LastTokenWithWellKnownText + 1 1257"];
1257 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1258"];
1258 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1259"];
1259 [label="1 1260"];
1260 [label="(int)LastTokenWithWellKnownText + 1 1261"];
1261 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1262"];
1262 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 1263"];
1263 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 1264"];
1264 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 1265"];
1265 [label="typeof(SyntaxToken) 1266"];
1266 [label="r => new SyntaxToken(r) 1267"];
1267 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)) 1268"];
1268 [label="kind = FirstTokenWithWellKnownText 1269"];
1269 [label="kind <= LastTokenWithWellKnownText 1270"];
1270 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 1271"];
1271 [label="s_tokensWithNoTrivia[(int)kind] 1272"];
1272 [label="kind 1273"];
1273 [label="new SyntaxToken(kind) 1274"];
1274 [label="param SyntaxToken(SyntaxKind kind) 1275"];
1275 [label="param SyntaxToken(this) 1276"];
1276 [label="kind 1277"];
1277 [label="param CSharpSyntaxNode(SyntaxKind kind) 1278"];
1278 [label="param CSharpSyntaxNode(this) 1279"];
1279 [label="kind 1280"];
1280 [label="param CSharpSyntaxNode(this) 1281"];
1281 [label="this 1282"];
1282 [label="GreenStats.NoteGreen(this) 1283"];
1283 [label="this.Text 1284"];
1284 [label="get { return SyntaxFacts.GetText(this.Kind); } 1285"];
1285 [label="this.Kind 1286"];
1286 [label="get { return (SyntaxKind)this.RawKind; } 1287"];
1287 [label="return (SyntaxKind)this.RawKind; 1288"];
1288 [label="SyntaxFacts.GetText(this.Kind) 1289"];
1289 [label="param GetText(SyntaxKind kind) 1290"];
1290 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1291"];
1291 [label="'~' 1292"];
1292 [label="return '~'; 1293"];
1293 [label="return SyntaxFacts.GetText(this.Kind); 1294"];
1294 [label="FullWidth 1295"];
1295 [label="this.flags |= NodeFlags.IsNotMissing 1296"];
1296 [label="this.flags 1297"];
1297 [label="s_tokensWithNoTrivia[(int)kind].Value 1298"];
1298 [label="s_tokensWithElasticTrivia[(int)kind] 1299"];
1299 [label="kind 1300"];
1300 [label="SyntaxFactory.ElasticZeroSpace 1301"];
1301 [label="SyntaxFactory.ElasticZeroSpace 1302"];
1302 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1303"];
1303 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1304"];
1304 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1305"];
1305 [label="param SyntaxToken(SyntaxKind kind) 1306"];
1306 [label="param SyntaxToken(this) 1307"];
1307 [label="kind 1308"];
1308 [label="param SyntaxToken(this) 1309"];
1309 [label="param CSharpSyntaxNode(SyntaxKind kind) 1310"];
1310 [label="param CSharpSyntaxNode(this) 1311"];
1311 [label="kind 1312"];
1312 [label="param CSharpSyntaxNode(this) 1313"];
1313 [label="param CSharpSyntaxNode(this) 1314"];
1314 [label="this 1315"];
1315 [label="GreenStats.NoteGreen(this) 1316"];
1316 [label="this.Text 1317"];
1317 [label="get { return SyntaxFacts.GetText(this.Kind); } 1318"];
1318 [label="this.Kind 1319"];
1319 [label="get { return (SyntaxKind)this.RawKind; } 1320"];
1320 [label="return (SyntaxKind)this.RawKind; 1321"];
1321 [label="SyntaxFacts.GetText(this.Kind) 1322"];
1322 [label="param GetText(SyntaxKind kind) 1323"];
1323 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1324"];
1324 [label="'~' 1325"];
1325 [label="return '~'; 1326"];
1326 [label="return SyntaxFacts.GetText(this.Kind); 1327"];
1327 [label="FullWidth 1328"];
1328 [label="this.flags |= NodeFlags.IsNotMissing 1329"];
1329 [label="this.flags 1330"];
1330 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1331"];
1331 [label="s_tokensWithElasticTrivia[(int)kind].Value 1332"];
1332 [label="s_tokensWithSingleTrailingSpace[(int)kind] 1333"];
1333 [label="kind 1334"];
1334 [label="null 1335"];
1335 [label="SyntaxFactory.Space 1336"];
1336 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1337"];
1337 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1338"];
1338 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1339"];
1339 [label="param SyntaxToken(SyntaxKind kind) 1340"];
1340 [label="param SyntaxToken(this) 1341"];
1341 [label="kind 1342"];
1342 [label="param SyntaxToken(this) 1343"];
1343 [label="param CSharpSyntaxNode(SyntaxKind kind) 1344"];
1344 [label="param CSharpSyntaxNode(this) 1345"];
1345 [label="kind 1346"];
1346 [label="param CSharpSyntaxNode(this) 1347"];
1347 [label="param CSharpSyntaxNode(this) 1348"];
1348 [label="this 1349"];
1349 [label="GreenStats.NoteGreen(this) 1350"];
1350 [label="this.Text 1351"];
1351 [label="get { return SyntaxFacts.GetText(this.Kind); } 1352"];
1352 [label="this.Kind 1353"];
1353 [label="get { return (SyntaxKind)this.RawKind; } 1354"];
1354 [label="return (SyntaxKind)this.RawKind; 1355"];
1355 [label="SyntaxFacts.GetText(this.Kind) 1356"];
1356 [label="param GetText(SyntaxKind kind) 1357"];
1357 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1358"];
1358 [label="'~' 1359"];
1359 [label="return '~'; 1360"];
1360 [label="return SyntaxFacts.GetText(this.Kind); 1361"];
1361 [label="FullWidth 1362"];
1362 [label="this.flags |= NodeFlags.IsNotMissing 1363"];
1363 [label="this.flags 1364"];
1364 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1365"];
1365 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1366"];
1366 [label="s_tokensWithSingleTrailingCRLF[(int)kind] 1367"];
1367 [label="kind 1368"];
1368 [label="null 1369"];
1369 [label="SyntaxFactory.CarriageReturnLineFeed 1370"];
1370 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1371"];
1371 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1372"];
1372 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1373"];
1373 [label="param SyntaxToken(SyntaxKind kind) 1374"];
1374 [label="param SyntaxToken(this) 1375"];
1375 [label="kind 1376"];
1376 [label="param SyntaxToken(this) 1377"];
1377 [label="param CSharpSyntaxNode(SyntaxKind kind) 1378"];
1378 [label="param CSharpSyntaxNode(this) 1379"];
1379 [label="kind 1380"];
1380 [label="param CSharpSyntaxNode(this) 1381"];
1381 [label="param CSharpSyntaxNode(this) 1382"];
1382 [label="this 1383"];
1383 [label="GreenStats.NoteGreen(this) 1384"];
1384 [label="this.Text 1385"];
1385 [label="get { return SyntaxFacts.GetText(this.Kind); } 1386"];
1386 [label="this.Kind 1387"];
1387 [label="get { return (SyntaxKind)this.RawKind; } 1388"];
1388 [label="return (SyntaxKind)this.RawKind; 1389"];
1389 [label="SyntaxFacts.GetText(this.Kind) 1390"];
1390 [label="param GetText(SyntaxKind kind) 1391"];
1391 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1392"];
1392 [label="'~' 1393"];
1393 [label="return '~'; 1394"];
1394 [label="return SyntaxFacts.GetText(this.Kind); 1395"];
1395 [label="FullWidth 1396"];
1396 [label="this.flags |= NodeFlags.IsNotMissing 1397"];
1397 [label="this.flags 1398"];
1398 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1399"];
1399 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1400"];
1400 [label="kind 1401"];
1401 [label="s_tokensWithNoTrivia[(int)kind] 1402"];
1402 [label="kind 1403"];
1403 [label="new SyntaxToken(kind) 1404"];
1404 [label="param SyntaxToken(SyntaxKind kind) 1405"];
1405 [label="param SyntaxToken(this) 1406"];
1406 [label="kind 1407"];
1407 [label="param CSharpSyntaxNode(SyntaxKind kind) 1408"];
1408 [label="param CSharpSyntaxNode(this) 1409"];
1409 [label="kind 1410"];
1410 [label="param CSharpSyntaxNode(this) 1411"];
1411 [label="this 1412"];
1412 [label="GreenStats.NoteGreen(this) 1413"];
1413 [label="this.Text 1414"];
1414 [label="get { return SyntaxFacts.GetText(this.Kind); } 1415"];
1415 [label="this.Kind 1416"];
1416 [label="get { return (SyntaxKind)this.RawKind; } 1417"];
1417 [label="return (SyntaxKind)this.RawKind; 1418"];
1418 [label="SyntaxFacts.GetText(this.Kind) 1419"];
1419 [label="param GetText(SyntaxKind kind) 1420"];
1420 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 1421"];
1421 [label="'!' 1422"];
1422 [label="return '!'; 1423"];
1423 [label="return SyntaxFacts.GetText(this.Kind); 1424"];
1424 [label="FullWidth 1425"];
1425 [label="this.flags |= NodeFlags.IsNotMissing 1426"];
1426 [label="this.flags 1427"];
1427 [label="s_tokensWithNoTrivia[(int)kind].Value 1428"];
1428 [label="s_tokensWithElasticTrivia[(int)kind] 1429"];
1429 [label="kind 1430"];
1430 [label="SyntaxFactory.ElasticZeroSpace 1431"];
1431 [label="SyntaxFactory.ElasticZeroSpace 1432"];
1432 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1433"];
1433 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1434"];
1434 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 1435"];
1435 [label="param SyntaxToken(this) 1436"];
1436 [label="param SyntaxToken(this) 1437"];
1437 [label="param CSharpSyntaxNode(this) 1438"];
1438 [label="param CSharpSyntaxNode(this) 1439"];
1439 [label="this 1440"];
1440 [label="this.Text 1441"];
1441 [label="get { return SyntaxFacts.GetText(this.Kind); } 1442"];
1442 [label="this.Kind 1443"];
1443 [label="get { return (SyntaxKind)this.RawKind; } 1444"];
1444 [label="SyntaxFacts.GetText(this.Kind) 1445"];
1445 [label="'!' 1446"];
1446 [label="return '!'; 1447"];
1447 [label="s_tokensWithElasticTrivia[(int)kind].Value 1448"];
1448 [label="s_tokensWithSingleTrailingSpace[(int)kind] 1449"];
1449 [label="kind 1450"];
1450 [label="null 1451"];
1451 [label="SyntaxFactory.Space 1452"];
1452 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1453"];
1453 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1454"];
1454 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 1455"];
1455 [label="param SyntaxToken(this) 1456"];
1456 [label="param SyntaxToken(this) 1457"];
1457 [label="param CSharpSyntaxNode(this) 1458"];
1458 [label="param CSharpSyntaxNode(this) 1459"];
1459 [label="this 1460"];
1460 [label="this.Text 1461"];
1461 [label="get { return SyntaxFacts.GetText(this.Kind); } 1462"];
1462 [label="this.Kind 1463"];
1463 [label="get { return (SyntaxKind)this.RawKind; } 1464"];
1464 [label="SyntaxFacts.GetText(this.Kind) 1465"];
1465 [label="'!' 1466"];
1466 [label="return '!'; 1467"];
1467 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1468"];
1468 [label="s_tokensWithSingleTrailingCRLF[(int)kind] 1469"];
1469 [label="kind 1470"];
1470 [label="null 1471"];
1471 [label="SyntaxFactory.CarriageReturnLineFeed 1472"];
1472 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1473"];
1473 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1474"];
1474 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 1475"];
1475 [label="param SyntaxToken(this) 1476"];
1476 [label="param SyntaxToken(this) 1477"];
1477 [label="param CSharpSyntaxNode(this) 1478"];
1478 [label="param CSharpSyntaxNode(this) 1479"];
1479 [label="this 1480"];
1480 [label="this.Text 1481"];
1481 [label="get { return SyntaxFacts.GetText(this.Kind); } 1482"];
1482 [label="this.Kind 1483"];
1483 [label="get { return (SyntaxKind)this.RawKind; } 1484"];
1484 [label="SyntaxFacts.GetText(this.Kind) 1485"];
1485 [label="'!' 1486"];
1486 [label="return '!'; 1487"];
1487 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1488"];
1488 [label="'$' 1489"];
1489 [label="return '$'; 1490"];
1490 [label="return SyntaxFacts.GetText(this.Kind); 1491"];
1491 [label="FullWidth 1492"];
1492 [label="'$' 1493"];
1493 [label="return '$'; 1494"];
1494 [label="s_tokensWithElasticTrivia[(int)kind].Value 1495"];
1495 [label="'$' 1496"];
1496 [label="return '$'; 1497"];
1497 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1498"];
1498 [label="'$' 1499"];
1499 [label="return '$'; 1500"];
1500 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1501"];
1501 [label="'%' 1502"];
1502 [label="return '%'; 1503"];
1503 [label="return SyntaxFacts.GetText(this.Kind); 1504"];
1504 [label="FullWidth 1505"];
1505 [label="'%' 1506"];
1506 [label="return '%'; 1507"];
1507 [label="s_tokensWithElasticTrivia[(int)kind].Value 1508"];
1508 [label="'%' 1509"];
1509 [label="return '%'; 1510"];
1510 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1511"];
1511 [label="'%' 1512"];
1512 [label="return '%'; 1513"];
1513 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1514"];
1514 [label="'^' 1515"];
1515 [label="return '^'; 1516"];
1516 [label="return SyntaxFacts.GetText(this.Kind); 1517"];
1517 [label="FullWidth 1518"];
1518 [label="'^' 1519"];
1519 [label="return '^'; 1520"];
1520 [label="s_tokensWithElasticTrivia[(int)kind].Value 1521"];
1521 [label="'^' 1522"];
1522 [label="return '^'; 1523"];
1523 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1524"];
1524 [label="'^' 1525"];
1525 [label="return '^'; 1526"];
1526 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1527"];
1527 [label="'&' 1528"];
1528 [label="return '&'; 1529"];
1529 [label="return SyntaxFacts.GetText(this.Kind); 1530"];
1530 [label="FullWidth 1531"];
1531 [label="'&' 1532"];
1532 [label="return '&'; 1533"];
1533 [label="s_tokensWithElasticTrivia[(int)kind].Value 1534"];
1534 [label="'&' 1535"];
1535 [label="return '&'; 1536"];
1536 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1537"];
1537 [label="'&' 1538"];
1538 [label="return '&'; 1539"];
1539 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1540"];
1540 [label="'*' 1541"];
1541 [label="return '*'; 1542"];
1542 [label="return SyntaxFacts.GetText(this.Kind); 1543"];
1543 [label="FullWidth 1544"];
1544 [label="'*' 1545"];
1545 [label="return '*'; 1546"];
1546 [label="s_tokensWithElasticTrivia[(int)kind].Value 1547"];
1547 [label="'*' 1548"];
1548 [label="return '*'; 1549"];
1549 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1550"];
1550 [label="'*' 1551"];
1551 [label="return '*'; 1552"];
1552 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1553"];
1553 [label="'(' 1554"];
1554 [label="return '('; 1555"];
1555 [label="return SyntaxFacts.GetText(this.Kind); 1556"];
1556 [label="FullWidth 1557"];
1557 [label="'(' 1558"];
1558 [label="return '('; 1559"];
1559 [label="s_tokensWithElasticTrivia[(int)kind].Value 1560"];
1560 [label="'(' 1561"];
1561 [label="return '('; 1562"];
1562 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1563"];
1563 [label="'(' 1564"];
1564 [label="return '('; 1565"];
1565 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1566"];
1566 [label="')' 1567"];
1567 [label="return ')'; 1568"];
1568 [label="return SyntaxFacts.GetText(this.Kind); 1569"];
1569 [label="FullWidth 1570"];
1570 [label="')' 1571"];
1571 [label="return ')'; 1572"];
1572 [label="s_tokensWithElasticTrivia[(int)kind].Value 1573"];
1573 [label="')' 1574"];
1574 [label="return ')'; 1575"];
1575 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1576"];
1576 [label="')' 1577"];
1577 [label="return ')'; 1578"];
1578 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1579"];
1579 [label="'-' 1580"];
1580 [label="return '-'; 1581"];
1581 [label="return SyntaxFacts.GetText(this.Kind); 1582"];
1582 [label="FullWidth 1583"];
1583 [label="'-' 1584"];
1584 [label="return '-'; 1585"];
1585 [label="s_tokensWithElasticTrivia[(int)kind].Value 1586"];
1586 [label="'-' 1587"];
1587 [label="return '-'; 1588"];
1588 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1589"];
1589 [label="'-' 1590"];
1590 [label="return '-'; 1591"];
1591 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1592"];
1592 [label="'+' 1593"];
1593 [label="return '+'; 1594"];
1594 [label="return SyntaxFacts.GetText(this.Kind); 1595"];
1595 [label="FullWidth 1596"];
1596 [label="'+' 1597"];
1597 [label="return '+'; 1598"];
1598 [label="s_tokensWithElasticTrivia[(int)kind].Value 1599"];
1599 [label="'+' 1600"];
1600 [label="return '+'; 1601"];
1601 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1602"];
1602 [label="'+' 1603"];
1603 [label="return '+'; 1604"];
1604 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1605"];
1605 [label="'=' 1606"];
1606 [label="return '='; 1607"];
1607 [label="return SyntaxFacts.GetText(this.Kind); 1608"];
1608 [label="FullWidth 1609"];
1609 [label="'=' 1610"];
1610 [label="return '='; 1611"];
1611 [label="s_tokensWithElasticTrivia[(int)kind].Value 1612"];
1612 [label="'=' 1613"];
1613 [label="return '='; 1614"];
1614 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1615"];
1615 [label="'=' 1616"];
1616 [label="return '='; 1617"];
1617 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1618"];
1618 [label="'{' 1619"];
1619 [label="return '{'; 1620"];
1620 [label="return SyntaxFacts.GetText(this.Kind); 1621"];
1621 [label="FullWidth 1622"];
1622 [label="'{' 1623"];
1623 [label="return '{'; 1624"];
1624 [label="s_tokensWithElasticTrivia[(int)kind].Value 1625"];
1625 [label="'{' 1626"];
1626 [label="return '{'; 1627"];
1627 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1628"];
1628 [label="'{' 1629"];
1629 [label="return '{'; 1630"];
1630 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1631"];
1631 [label="'}' 1632"];
1632 [label="return '}'; 1633"];
1633 [label="return SyntaxFacts.GetText(this.Kind); 1634"];
1634 [label="FullWidth 1635"];
1635 [label="'}' 1636"];
1636 [label="return '}'; 1637"];
1637 [label="s_tokensWithElasticTrivia[(int)kind].Value 1638"];
1638 [label="'}' 1639"];
1639 [label="return '}'; 1640"];
1640 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1641"];
1641 [label="'}' 1642"];
1642 [label="return '}'; 1643"];
1643 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1644"];
1644 [label="'[' 1645"];
1645 [label="return '['; 1646"];
1646 [label="return SyntaxFacts.GetText(this.Kind); 1647"];
1647 [label="FullWidth 1648"];
1648 [label="'[' 1649"];
1649 [label="return '['; 1650"];
1650 [label="s_tokensWithElasticTrivia[(int)kind].Value 1651"];
1651 [label="'[' 1652"];
1652 [label="return '['; 1653"];
1653 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1654"];
1654 [label="'[' 1655"];
1655 [label="return '['; 1656"];
1656 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1657"];
1657 [label="']' 1658"];
1658 [label="return ']'; 1659"];
1659 [label="return SyntaxFacts.GetText(this.Kind); 1660"];
1660 [label="FullWidth 1661"];
1661 [label="']' 1662"];
1662 [label="return ']'; 1663"];
1663 [label="s_tokensWithElasticTrivia[(int)kind].Value 1664"];
1664 [label="']' 1665"];
1665 [label="return ']'; 1666"];
1666 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1667"];
1667 [label="']' 1668"];
1668 [label="return ']'; 1669"];
1669 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1670"];
1670 [label="'|' 1671"];
1671 [label="return '|'; 1672"];
1672 [label="return SyntaxFacts.GetText(this.Kind); 1673"];
1673 [label="FullWidth 1674"];
1674 [label="'|' 1675"];
1675 [label="return '|'; 1676"];
1676 [label="s_tokensWithElasticTrivia[(int)kind].Value 1677"];
1677 [label="'|' 1678"];
1678 [label="return '|'; 1679"];
1679 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1680"];
1680 [label="'|' 1681"];
1681 [label="return '|'; 1682"];
1682 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1683"];
1683 [label="'\\\\' 1684"];
1684 [label="return '\\\\'; 1685"];
1685 [label="return SyntaxFacts.GetText(this.Kind); 1686"];
1686 [label="FullWidth 1687"];
1687 [label="'\\\\' 1688"];
1688 [label="return '\\\\'; 1689"];
1689 [label="s_tokensWithElasticTrivia[(int)kind].Value 1690"];
1690 [label="'\\\\' 1691"];
1691 [label="return '\\\\'; 1692"];
1692 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1693"];
1693 [label="'\\\\' 1694"];
1694 [label="return '\\\\'; 1695"];
1695 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1696"];
1696 [label="':' 1697"];
1697 [label="return ':'; 1698"];
1698 [label="return SyntaxFacts.GetText(this.Kind); 1699"];
1699 [label="FullWidth 1700"];
1700 [label="':' 1701"];
1701 [label="return ':'; 1702"];
1702 [label="s_tokensWithElasticTrivia[(int)kind].Value 1703"];
1703 [label="':' 1704"];
1704 [label="return ':'; 1705"];
1705 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1706"];
1706 [label="':' 1707"];
1707 [label="return ':'; 1708"];
1708 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1709"];
1709 [label="';' 1710"];
1710 [label="return ';'; 1711"];
1711 [label="return SyntaxFacts.GetText(this.Kind); 1712"];
1712 [label="FullWidth 1713"];
1713 [label="';' 1714"];
1714 [label="return ';'; 1715"];
1715 [label="s_tokensWithElasticTrivia[(int)kind].Value 1716"];
1716 [label="';' 1717"];
1717 [label="return ';'; 1718"];
1718 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1719"];
1719 [label="';' 1720"];
1720 [label="return ';'; 1721"];
1721 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1722"];
1722 [label="'\\'' 1723"];
1723 [label="return '\\''; 1724"];
1724 [label="return SyntaxFacts.GetText(this.Kind); 1725"];
1725 [label="FullWidth 1726"];
1726 [label="'\\'' 1727"];
1727 [label="return '\\''; 1728"];
1728 [label="s_tokensWithElasticTrivia[(int)kind].Value 1729"];
1729 [label="'\\'' 1730"];
1730 [label="return '\\''; 1731"];
1731 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1732"];
1732 [label="'\\'' 1733"];
1733 [label="return '\\''; 1734"];
1734 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1735"];
1735 [label="''' 1736"];
1736 [label="return '''; 1737"];
1737 [label="return SyntaxFacts.GetText(this.Kind); 1738"];
1738 [label="FullWidth 1739"];
1739 [label="''' 1740"];
1740 [label="return '''; 1741"];
1741 [label="s_tokensWithElasticTrivia[(int)kind].Value 1742"];
1742 [label="''' 1743"];
1743 [label="return '''; 1744"];
1744 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1745"];
1745 [label="''' 1746"];
1746 [label="return '''; 1747"];
1747 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1748"];
1748 [label="'<' 1749"];
1749 [label="return '<'; 1750"];
1750 [label="return SyntaxFacts.GetText(this.Kind); 1751"];
1751 [label="FullWidth 1752"];
1752 [label="'<' 1753"];
1753 [label="return '<'; 1754"];
1754 [label="s_tokensWithElasticTrivia[(int)kind].Value 1755"];
1755 [label="'<' 1756"];
1756 [label="return '<'; 1757"];
1757 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1758"];
1758 [label="'<' 1759"];
1759 [label="return '<'; 1760"];
1760 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1761"];
1761 [label="',' 1762"];
1762 [label="return ','; 1763"];
1763 [label="return SyntaxFacts.GetText(this.Kind); 1764"];
1764 [label="FullWidth 1765"];
1765 [label="',' 1766"];
1766 [label="return ','; 1767"];
1767 [label="s_tokensWithElasticTrivia[(int)kind].Value 1768"];
1768 [label="',' 1769"];
1769 [label="return ','; 1770"];
1770 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1771"];
1771 [label="',' 1772"];
1772 [label="return ','; 1773"];
1773 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1774"];
1774 [label="'>' 1775"];
1775 [label="return '>'; 1776"];
1776 [label="return SyntaxFacts.GetText(this.Kind); 1777"];
1777 [label="FullWidth 1778"];
1778 [label="'>' 1779"];
1779 [label="return '>'; 1780"];
1780 [label="s_tokensWithElasticTrivia[(int)kind].Value 1781"];
1781 [label="'>' 1782"];
1782 [label="return '>'; 1783"];
1783 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1784"];
1784 [label="'>' 1785"];
1785 [label="return '>'; 1786"];
1786 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1787"];
1787 [label="'.' 1788"];
1788 [label="return '.'; 1789"];
1789 [label="return SyntaxFacts.GetText(this.Kind); 1790"];
1790 [label="FullWidth 1791"];
1791 [label="'.' 1792"];
1792 [label="return '.'; 1793"];
1793 [label="s_tokensWithElasticTrivia[(int)kind].Value 1794"];
1794 [label="'.' 1795"];
1795 [label="return '.'; 1796"];
1796 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1797"];
1797 [label="'.' 1798"];
1798 [label="return '.'; 1799"];
1799 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1800"];
1800 [label="'?' 1801"];
1801 [label="return '?'; 1802"];
1802 [label="return SyntaxFacts.GetText(this.Kind); 1803"];
1803 [label="FullWidth 1804"];
1804 [label="'?' 1805"];
1805 [label="return '?'; 1806"];
1806 [label="s_tokensWithElasticTrivia[(int)kind].Value 1807"];
1807 [label="'?' 1808"];
1808 [label="return '?'; 1809"];
1809 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1810"];
1810 [label="'?' 1811"];
1811 [label="return '?'; 1812"];
1812 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1813"];
1813 [label="'#' 1814"];
1814 [label="return '#'; 1815"];
1815 [label="return SyntaxFacts.GetText(this.Kind); 1816"];
1816 [label="FullWidth 1817"];
1817 [label="'#' 1818"];
1818 [label="return '#'; 1819"];
1819 [label="s_tokensWithElasticTrivia[(int)kind].Value 1820"];
1820 [label="'#' 1821"];
1821 [label="return '#'; 1822"];
1822 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1823"];
1823 [label="'#' 1824"];
1824 [label="return '#'; 1825"];
1825 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1826"];
1826 [label="'/' 1827"];
1827 [label="return '/'; 1828"];
1828 [label="return SyntaxFacts.GetText(this.Kind); 1829"];
1829 [label="FullWidth 1830"];
1830 [label="'/' 1831"];
1831 [label="return '/'; 1832"];
1832 [label="s_tokensWithElasticTrivia[(int)kind].Value 1833"];
1833 [label="'/' 1834"];
1834 [label="return '/'; 1835"];
1835 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1836"];
1836 [label="'/' 1837"];
1837 [label="return '/'; 1838"];
1838 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1839"];
1839 [label="'..' 1840"];
1840 [label="return '..'; 1841"];
1841 [label="return SyntaxFacts.GetText(this.Kind); 1842"];
1842 [label="FullWidth 1843"];
1843 [label="'..' 1844"];
1844 [label="return '..'; 1845"];
1845 [label="s_tokensWithElasticTrivia[(int)kind].Value 1846"];
1846 [label="'..' 1847"];
1847 [label="return '..'; 1848"];
1848 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1849"];
1849 [label="'..' 1850"];
1850 [label="return '..'; 1851"];
1851 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1852"];
1852 [label="return string.Empty; 1853"];
1853 [label="return SyntaxFacts.GetText(this.Kind); 1854"];
1854 [label="FullWidth 1855"];
1855 [label="return string.Empty; 1856"];
1856 [label="s_tokensWithElasticTrivia[(int)kind].Value 1857"];
1857 [label="return string.Empty; 1858"];
1858 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1859"];
1859 [label="return string.Empty; 1860"];
1860 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1861"];
1861 [label="'/>' 1862"];
1862 [label="return '/>'; 1863"];
1863 [label="return SyntaxFacts.GetText(this.Kind); 1864"];
1864 [label="FullWidth 1865"];
1865 [label="'/>' 1866"];
1866 [label="return '/>'; 1867"];
1867 [label="s_tokensWithElasticTrivia[(int)kind].Value 1868"];
1868 [label="'/>' 1869"];
1869 [label="return '/>'; 1870"];
1870 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1871"];
1871 [label="'/>' 1872"];
1872 [label="return '/>'; 1873"];
1873 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1874"];
1874 [label="'</' 1875"];
1875 [label="return '</'; 1876"];
1876 [label="return SyntaxFacts.GetText(this.Kind); 1877"];
1877 [label="FullWidth 1878"];
1878 [label="'</' 1879"];
1879 [label="return '</'; 1880"];
1880 [label="s_tokensWithElasticTrivia[(int)kind].Value 1881"];
1881 [label="'</' 1882"];
1882 [label="return '</'; 1883"];
1883 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1884"];
1884 [label="'</' 1885"];
1885 [label="return '</'; 1886"];
1886 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1887"];
1887 [label="'<!--' 1888"];
1888 [label="return '<!--'; 1889"];
1889 [label="return SyntaxFacts.GetText(this.Kind); 1890"];
1890 [label="FullWidth 1891"];
1891 [label="'<!--' 1892"];
1892 [label="return '<!--'; 1893"];
1893 [label="s_tokensWithElasticTrivia[(int)kind].Value 1894"];
1894 [label="'<!--' 1895"];
1895 [label="return '<!--'; 1896"];
1896 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1897"];
1897 [label="'<!--' 1898"];
1898 [label="return '<!--'; 1899"];
1899 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1900"];
1900 [label="'-->' 1901"];
1901 [label="return '-->'; 1902"];
1902 [label="return SyntaxFacts.GetText(this.Kind); 1903"];
1903 [label="FullWidth 1904"];
1904 [label="'-->' 1905"];
1905 [label="return '-->'; 1906"];
1906 [label="s_tokensWithElasticTrivia[(int)kind].Value 1907"];
1907 [label="'-->' 1908"];
1908 [label="return '-->'; 1909"];
1909 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1910"];
1910 [label="'-->' 1911"];
1911 [label="return '-->'; 1912"];
1912 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1913"];
1913 [label="'<![CDATA[' 1914"];
1914 [label="return '<![CDATA['; 1915"];
1915 [label="return SyntaxFacts.GetText(this.Kind); 1916"];
1916 [label="FullWidth 1917"];
1917 [label="'<![CDATA[' 1918"];
1918 [label="return '<![CDATA['; 1919"];
1919 [label="s_tokensWithElasticTrivia[(int)kind].Value 1920"];
1920 [label="'<![CDATA[' 1921"];
1921 [label="return '<![CDATA['; 1922"];
1922 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1923"];
1923 [label="'<![CDATA[' 1924"];
1924 [label="return '<![CDATA['; 1925"];
1925 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1926"];
1926 [label="']]>' 1927"];
1927 [label="return ']]>'; 1928"];
1928 [label="return SyntaxFacts.GetText(this.Kind); 1929"];
1929 [label="FullWidth 1930"];
1930 [label="']]>' 1931"];
1931 [label="return ']]>'; 1932"];
1932 [label="s_tokensWithElasticTrivia[(int)kind].Value 1933"];
1933 [label="']]>' 1934"];
1934 [label="return ']]>'; 1935"];
1935 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1936"];
1936 [label="']]>' 1937"];
1937 [label="return ']]>'; 1938"];
1938 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1939"];
1939 [label="'<?' 1940"];
1940 [label="return '<?'; 1941"];
1941 [label="return SyntaxFacts.GetText(this.Kind); 1942"];
1942 [label="FullWidth 1943"];
1943 [label="'<?' 1944"];
1944 [label="return '<?'; 1945"];
1945 [label="s_tokensWithElasticTrivia[(int)kind].Value 1946"];
1946 [label="'<?' 1947"];
1947 [label="return '<?'; 1948"];
1948 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1949"];
1949 [label="'<?' 1950"];
1950 [label="return '<?'; 1951"];
1951 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1952"];
1952 [label="'?>' 1953"];
1953 [label="return '?>'; 1954"];
1954 [label="return SyntaxFacts.GetText(this.Kind); 1955"];
1955 [label="FullWidth 1956"];
1956 [label="'?>' 1957"];
1957 [label="return '?>'; 1958"];
1958 [label="s_tokensWithElasticTrivia[(int)kind].Value 1959"];
1959 [label="'?>' 1960"];
1960 [label="return '?>'; 1961"];
1961 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1962"];
1962 [label="'?>' 1963"];
1963 [label="return '?>'; 1964"];
1964 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1965"];
1965 [label="'||' 1966"];
1966 [label="return '||'; 1967"];
1967 [label="return SyntaxFacts.GetText(this.Kind); 1968"];
1968 [label="FullWidth 1969"];
1969 [label="'||' 1970"];
1970 [label="return '||'; 1971"];
1971 [label="s_tokensWithElasticTrivia[(int)kind].Value 1972"];
1972 [label="'||' 1973"];
1973 [label="return '||'; 1974"];
1974 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1975"];
1975 [label="'||' 1976"];
1976 [label="return '||'; 1977"];
1977 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1978"];
1978 [label="'&&' 1979"];
1979 [label="return '&&'; 1980"];
1980 [label="return SyntaxFacts.GetText(this.Kind); 1981"];
1981 [label="FullWidth 1982"];
1982 [label="'&&' 1983"];
1983 [label="return '&&'; 1984"];
1984 [label="s_tokensWithElasticTrivia[(int)kind].Value 1985"];
1985 [label="'&&' 1986"];
1986 [label="return '&&'; 1987"];
1987 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 1988"];
1988 [label="'&&' 1989"];
1989 [label="return '&&'; 1990"];
1990 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 1991"];
1991 [label="'--' 1992"];
1992 [label="return '--'; 1993"];
1993 [label="return SyntaxFacts.GetText(this.Kind); 1994"];
1994 [label="FullWidth 1995"];
1995 [label="'--' 1996"];
1996 [label="return '--'; 1997"];
1997 [label="s_tokensWithElasticTrivia[(int)kind].Value 1998"];
1998 [label="'--' 1999"];
1999 [label="return '--'; 2000"];
2000 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2001"];
2001 [label="'--' 2002"];
2002 [label="return '--'; 2003"];
2003 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2004"];
2004 [label="'++' 2005"];
2005 [label="return '++'; 2006"];
2006 [label="return SyntaxFacts.GetText(this.Kind); 2007"];
2007 [label="FullWidth 2008"];
2008 [label="'++' 2009"];
2009 [label="return '++'; 2010"];
2010 [label="s_tokensWithElasticTrivia[(int)kind].Value 2011"];
2011 [label="'++' 2012"];
2012 [label="return '++'; 2013"];
2013 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2014"];
2014 [label="'++' 2015"];
2015 [label="return '++'; 2016"];
2016 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2017"];
2017 [label="'::' 2018"];
2018 [label="return '::'; 2019"];
2019 [label="return SyntaxFacts.GetText(this.Kind); 2020"];
2020 [label="FullWidth 2021"];
2021 [label="'::' 2022"];
2022 [label="return '::'; 2023"];
2023 [label="s_tokensWithElasticTrivia[(int)kind].Value 2024"];
2024 [label="'::' 2025"];
2025 [label="return '::'; 2026"];
2026 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2027"];
2027 [label="'::' 2028"];
2028 [label="return '::'; 2029"];
2029 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2030"];
2030 [label="'??' 2031"];
2031 [label="return '??'; 2032"];
2032 [label="return SyntaxFacts.GetText(this.Kind); 2033"];
2033 [label="FullWidth 2034"];
2034 [label="'??' 2035"];
2035 [label="return '??'; 2036"];
2036 [label="s_tokensWithElasticTrivia[(int)kind].Value 2037"];
2037 [label="'??' 2038"];
2038 [label="return '??'; 2039"];
2039 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2040"];
2040 [label="'??' 2041"];
2041 [label="return '??'; 2042"];
2042 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2043"];
2043 [label="'->' 2044"];
2044 [label="return '->'; 2045"];
2045 [label="return SyntaxFacts.GetText(this.Kind); 2046"];
2046 [label="FullWidth 2047"];
2047 [label="'->' 2048"];
2048 [label="return '->'; 2049"];
2049 [label="s_tokensWithElasticTrivia[(int)kind].Value 2050"];
2050 [label="'->' 2051"];
2051 [label="return '->'; 2052"];
2052 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2053"];
2053 [label="'->' 2054"];
2054 [label="return '->'; 2055"];
2055 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2056"];
2056 [label="'!=' 2057"];
2057 [label="return '!='; 2058"];
2058 [label="return SyntaxFacts.GetText(this.Kind); 2059"];
2059 [label="FullWidth 2060"];
2060 [label="'!=' 2061"];
2061 [label="return '!='; 2062"];
2062 [label="s_tokensWithElasticTrivia[(int)kind].Value 2063"];
2063 [label="'!=' 2064"];
2064 [label="return '!='; 2065"];
2065 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2066"];
2066 [label="'!=' 2067"];
2067 [label="return '!='; 2068"];
2068 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2069"];
2069 [label="'==' 2070"];
2070 [label="return '=='; 2071"];
2071 [label="return SyntaxFacts.GetText(this.Kind); 2072"];
2072 [label="FullWidth 2073"];
2073 [label="'==' 2074"];
2074 [label="return '=='; 2075"];
2075 [label="s_tokensWithElasticTrivia[(int)kind].Value 2076"];
2076 [label="'==' 2077"];
2077 [label="return '=='; 2078"];
2078 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2079"];
2079 [label="'==' 2080"];
2080 [label="return '=='; 2081"];
2081 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2082"];
2082 [label="'=>' 2083"];
2083 [label="return '=>'; 2084"];
2084 [label="return SyntaxFacts.GetText(this.Kind); 2085"];
2085 [label="FullWidth 2086"];
2086 [label="'=>' 2087"];
2087 [label="return '=>'; 2088"];
2088 [label="s_tokensWithElasticTrivia[(int)kind].Value 2089"];
2089 [label="'=>' 2090"];
2090 [label="return '=>'; 2091"];
2091 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2092"];
2092 [label="'=>' 2093"];
2093 [label="return '=>'; 2094"];
2094 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2095"];
2095 [label="'<=' 2096"];
2096 [label="return '<='; 2097"];
2097 [label="return SyntaxFacts.GetText(this.Kind); 2098"];
2098 [label="FullWidth 2099"];
2099 [label="'<=' 2100"];
2100 [label="return '<='; 2101"];
2101 [label="s_tokensWithElasticTrivia[(int)kind].Value 2102"];
2102 [label="'<=' 2103"];
2103 [label="return '<='; 2104"];
2104 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2105"];
2105 [label="'<=' 2106"];
2106 [label="return '<='; 2107"];
2107 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2108"];
2108 [label="'<<' 2109"];
2109 [label="return '<<'; 2110"];
2110 [label="return SyntaxFacts.GetText(this.Kind); 2111"];
2111 [label="FullWidth 2112"];
2112 [label="'<<' 2113"];
2113 [label="return '<<'; 2114"];
2114 [label="s_tokensWithElasticTrivia[(int)kind].Value 2115"];
2115 [label="'<<' 2116"];
2116 [label="return '<<'; 2117"];
2117 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2118"];
2118 [label="'<<' 2119"];
2119 [label="return '<<'; 2120"];
2120 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2121"];
2121 [label="'<<=' 2122"];
2122 [label="return '<<='; 2123"];
2123 [label="return SyntaxFacts.GetText(this.Kind); 2124"];
2124 [label="FullWidth 2125"];
2125 [label="'<<=' 2126"];
2126 [label="return '<<='; 2127"];
2127 [label="s_tokensWithElasticTrivia[(int)kind].Value 2128"];
2128 [label="'<<=' 2129"];
2129 [label="return '<<='; 2130"];
2130 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2131"];
2131 [label="'<<=' 2132"];
2132 [label="return '<<='; 2133"];
2133 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2134"];
2134 [label="'>=' 2135"];
2135 [label="return '>='; 2136"];
2136 [label="return SyntaxFacts.GetText(this.Kind); 2137"];
2137 [label="FullWidth 2138"];
2138 [label="'>=' 2139"];
2139 [label="return '>='; 2140"];
2140 [label="s_tokensWithElasticTrivia[(int)kind].Value 2141"];
2141 [label="'>=' 2142"];
2142 [label="return '>='; 2143"];
2143 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2144"];
2144 [label="'>=' 2145"];
2145 [label="return '>='; 2146"];
2146 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2147"];
2147 [label="'>>' 2148"];
2148 [label="return '>>'; 2149"];
2149 [label="return SyntaxFacts.GetText(this.Kind); 2150"];
2150 [label="FullWidth 2151"];
2151 [label="'>>' 2152"];
2152 [label="return '>>'; 2153"];
2153 [label="s_tokensWithElasticTrivia[(int)kind].Value 2154"];
2154 [label="'>>' 2155"];
2155 [label="return '>>'; 2156"];
2156 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2157"];
2157 [label="'>>' 2158"];
2158 [label="return '>>'; 2159"];
2159 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2160"];
2160 [label="'>>=' 2161"];
2161 [label="return '>>='; 2162"];
2162 [label="return SyntaxFacts.GetText(this.Kind); 2163"];
2163 [label="FullWidth 2164"];
2164 [label="'>>=' 2165"];
2165 [label="return '>>='; 2166"];
2166 [label="s_tokensWithElasticTrivia[(int)kind].Value 2167"];
2167 [label="'>>=' 2168"];
2168 [label="return '>>='; 2169"];
2169 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2170"];
2170 [label="'>>=' 2171"];
2171 [label="return '>>='; 2172"];
2172 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2173"];
2173 [label="'/=' 2174"];
2174 [label="return '/='; 2175"];
2175 [label="return SyntaxFacts.GetText(this.Kind); 2176"];
2176 [label="FullWidth 2177"];
2177 [label="'/=' 2178"];
2178 [label="return '/='; 2179"];
2179 [label="s_tokensWithElasticTrivia[(int)kind].Value 2180"];
2180 [label="'/=' 2181"];
2181 [label="return '/='; 2182"];
2182 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2183"];
2183 [label="'/=' 2184"];
2184 [label="return '/='; 2185"];
2185 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2186"];
2186 [label="'*=' 2187"];
2187 [label="return '*='; 2188"];
2188 [label="return SyntaxFacts.GetText(this.Kind); 2189"];
2189 [label="FullWidth 2190"];
2190 [label="'*=' 2191"];
2191 [label="return '*='; 2192"];
2192 [label="s_tokensWithElasticTrivia[(int)kind].Value 2193"];
2193 [label="'*=' 2194"];
2194 [label="return '*='; 2195"];
2195 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2196"];
2196 [label="'*=' 2197"];
2197 [label="return '*='; 2198"];
2198 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2199"];
2199 [label="'|=' 2200"];
2200 [label="return '|='; 2201"];
2201 [label="return SyntaxFacts.GetText(this.Kind); 2202"];
2202 [label="FullWidth 2203"];
2203 [label="'|=' 2204"];
2204 [label="return '|='; 2205"];
2205 [label="s_tokensWithElasticTrivia[(int)kind].Value 2206"];
2206 [label="'|=' 2207"];
2207 [label="return '|='; 2208"];
2208 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2209"];
2209 [label="'|=' 2210"];
2210 [label="return '|='; 2211"];
2211 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2212"];
2212 [label="'&=' 2213"];
2213 [label="return '&='; 2214"];
2214 [label="return SyntaxFacts.GetText(this.Kind); 2215"];
2215 [label="FullWidth 2216"];
2216 [label="'&=' 2217"];
2217 [label="return '&='; 2218"];
2218 [label="s_tokensWithElasticTrivia[(int)kind].Value 2219"];
2219 [label="'&=' 2220"];
2220 [label="return '&='; 2221"];
2221 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2222"];
2222 [label="'&=' 2223"];
2223 [label="return '&='; 2224"];
2224 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2225"];
2225 [label="'+=' 2226"];
2226 [label="return '+='; 2227"];
2227 [label="return SyntaxFacts.GetText(this.Kind); 2228"];
2228 [label="FullWidth 2229"];
2229 [label="'+=' 2230"];
2230 [label="return '+='; 2231"];
2231 [label="s_tokensWithElasticTrivia[(int)kind].Value 2232"];
2232 [label="'+=' 2233"];
2233 [label="return '+='; 2234"];
2234 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2235"];
2235 [label="'+=' 2236"];
2236 [label="return '+='; 2237"];
2237 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2238"];
2238 [label="'-=' 2239"];
2239 [label="return '-='; 2240"];
2240 [label="return SyntaxFacts.GetText(this.Kind); 2241"];
2241 [label="FullWidth 2242"];
2242 [label="'-=' 2243"];
2243 [label="return '-='; 2244"];
2244 [label="s_tokensWithElasticTrivia[(int)kind].Value 2245"];
2245 [label="'-=' 2246"];
2246 [label="return '-='; 2247"];
2247 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2248"];
2248 [label="'-=' 2249"];
2249 [label="return '-='; 2250"];
2250 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2251"];
2251 [label="'^=' 2252"];
2252 [label="return '^='; 2253"];
2253 [label="return SyntaxFacts.GetText(this.Kind); 2254"];
2254 [label="FullWidth 2255"];
2255 [label="'^=' 2256"];
2256 [label="return '^='; 2257"];
2257 [label="s_tokensWithElasticTrivia[(int)kind].Value 2258"];
2258 [label="'^=' 2259"];
2259 [label="return '^='; 2260"];
2260 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2261"];
2261 [label="'^=' 2262"];
2262 [label="return '^='; 2263"];
2263 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2264"];
2264 [label="'%=' 2265"];
2265 [label="return '%='; 2266"];
2266 [label="return SyntaxFacts.GetText(this.Kind); 2267"];
2267 [label="FullWidth 2268"];
2268 [label="'%=' 2269"];
2269 [label="return '%='; 2270"];
2270 [label="s_tokensWithElasticTrivia[(int)kind].Value 2271"];
2271 [label="'%=' 2272"];
2272 [label="return '%='; 2273"];
2273 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2274"];
2274 [label="'%=' 2275"];
2275 [label="return '%='; 2276"];
2276 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2277"];
2277 [label="'??=' 2278"];
2278 [label="return '??='; 2279"];
2279 [label="return SyntaxFacts.GetText(this.Kind); 2280"];
2280 [label="FullWidth 2281"];
2281 [label="'??=' 2282"];
2282 [label="return '??='; 2283"];
2283 [label="s_tokensWithElasticTrivia[(int)kind].Value 2284"];
2284 [label="'??=' 2285"];
2285 [label="return '??='; 2286"];
2286 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2287"];
2287 [label="'??=' 2288"];
2288 [label="return '??='; 2289"];
2289 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2290"];
2290 [label="'bool' 2291"];
2291 [label="return 'bool'; 2292"];
2292 [label="return SyntaxFacts.GetText(this.Kind); 2293"];
2293 [label="FullWidth 2294"];
2294 [label="'bool' 2295"];
2295 [label="return 'bool'; 2296"];
2296 [label="s_tokensWithElasticTrivia[(int)kind].Value 2297"];
2297 [label="'bool' 2298"];
2298 [label="return 'bool'; 2299"];
2299 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2300"];
2300 [label="'bool' 2301"];
2301 [label="return 'bool'; 2302"];
2302 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2303"];
2303 [label="'byte' 2304"];
2304 [label="return 'byte'; 2305"];
2305 [label="return SyntaxFacts.GetText(this.Kind); 2306"];
2306 [label="FullWidth 2307"];
2307 [label="'byte' 2308"];
2308 [label="return 'byte'; 2309"];
2309 [label="s_tokensWithElasticTrivia[(int)kind].Value 2310"];
2310 [label="'byte' 2311"];
2311 [label="return 'byte'; 2312"];
2312 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2313"];
2313 [label="'byte' 2314"];
2314 [label="return 'byte'; 2315"];
2315 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2316"];
2316 [label="'sbyte' 2317"];
2317 [label="return 'sbyte'; 2318"];
2318 [label="return SyntaxFacts.GetText(this.Kind); 2319"];
2319 [label="FullWidth 2320"];
2320 [label="'sbyte' 2321"];
2321 [label="return 'sbyte'; 2322"];
2322 [label="s_tokensWithElasticTrivia[(int)kind].Value 2323"];
2323 [label="'sbyte' 2324"];
2324 [label="return 'sbyte'; 2325"];
2325 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2326"];
2326 [label="'sbyte' 2327"];
2327 [label="return 'sbyte'; 2328"];
2328 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2329"];
2329 [label="'short' 2330"];
2330 [label="return 'short'; 2331"];
2331 [label="return SyntaxFacts.GetText(this.Kind); 2332"];
2332 [label="FullWidth 2333"];
2333 [label="'short' 2334"];
2334 [label="return 'short'; 2335"];
2335 [label="s_tokensWithElasticTrivia[(int)kind].Value 2336"];
2336 [label="'short' 2337"];
2337 [label="return 'short'; 2338"];
2338 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2339"];
2339 [label="'short' 2340"];
2340 [label="return 'short'; 2341"];
2341 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2342"];
2342 [label="'ushort' 2343"];
2343 [label="return 'ushort'; 2344"];
2344 [label="return SyntaxFacts.GetText(this.Kind); 2345"];
2345 [label="FullWidth 2346"];
2346 [label="'ushort' 2347"];
2347 [label="return 'ushort'; 2348"];
2348 [label="s_tokensWithElasticTrivia[(int)kind].Value 2349"];
2349 [label="'ushort' 2350"];
2350 [label="return 'ushort'; 2351"];
2351 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2352"];
2352 [label="'ushort' 2353"];
2353 [label="return 'ushort'; 2354"];
2354 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2355"];
2355 [label="'int' 2356"];
2356 [label="return 'int'; 2357"];
2357 [label="return SyntaxFacts.GetText(this.Kind); 2358"];
2358 [label="FullWidth 2359"];
2359 [label="'int' 2360"];
2360 [label="return 'int'; 2361"];
2361 [label="s_tokensWithElasticTrivia[(int)kind].Value 2362"];
2362 [label="'int' 2363"];
2363 [label="return 'int'; 2364"];
2364 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2365"];
2365 [label="'int' 2366"];
2366 [label="return 'int'; 2367"];
2367 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2368"];
2368 [label="'uint' 2369"];
2369 [label="return 'uint'; 2370"];
2370 [label="return SyntaxFacts.GetText(this.Kind); 2371"];
2371 [label="FullWidth 2372"];
2372 [label="'uint' 2373"];
2373 [label="return 'uint'; 2374"];
2374 [label="s_tokensWithElasticTrivia[(int)kind].Value 2375"];
2375 [label="'uint' 2376"];
2376 [label="return 'uint'; 2377"];
2377 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2378"];
2378 [label="'uint' 2379"];
2379 [label="return 'uint'; 2380"];
2380 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2381"];
2381 [label="'long' 2382"];
2382 [label="return 'long'; 2383"];
2383 [label="return SyntaxFacts.GetText(this.Kind); 2384"];
2384 [label="FullWidth 2385"];
2385 [label="'long' 2386"];
2386 [label="return 'long'; 2387"];
2387 [label="s_tokensWithElasticTrivia[(int)kind].Value 2388"];
2388 [label="'long' 2389"];
2389 [label="return 'long'; 2390"];
2390 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2391"];
2391 [label="'long' 2392"];
2392 [label="return 'long'; 2393"];
2393 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2394"];
2394 [label="'ulong' 2395"];
2395 [label="return 'ulong'; 2396"];
2396 [label="return SyntaxFacts.GetText(this.Kind); 2397"];
2397 [label="FullWidth 2398"];
2398 [label="'ulong' 2399"];
2399 [label="return 'ulong'; 2400"];
2400 [label="s_tokensWithElasticTrivia[(int)kind].Value 2401"];
2401 [label="'ulong' 2402"];
2402 [label="return 'ulong'; 2403"];
2403 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2404"];
2404 [label="'ulong' 2405"];
2405 [label="return 'ulong'; 2406"];
2406 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2407"];
2407 [label="'double' 2408"];
2408 [label="return 'double'; 2409"];
2409 [label="return SyntaxFacts.GetText(this.Kind); 2410"];
2410 [label="FullWidth 2411"];
2411 [label="'double' 2412"];
2412 [label="return 'double'; 2413"];
2413 [label="s_tokensWithElasticTrivia[(int)kind].Value 2414"];
2414 [label="'double' 2415"];
2415 [label="return 'double'; 2416"];
2416 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2417"];
2417 [label="'double' 2418"];
2418 [label="return 'double'; 2419"];
2419 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2420"];
2420 [label="'float' 2421"];
2421 [label="return 'float'; 2422"];
2422 [label="return SyntaxFacts.GetText(this.Kind); 2423"];
2423 [label="FullWidth 2424"];
2424 [label="'float' 2425"];
2425 [label="return 'float'; 2426"];
2426 [label="s_tokensWithElasticTrivia[(int)kind].Value 2427"];
2427 [label="'float' 2428"];
2428 [label="return 'float'; 2429"];
2429 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2430"];
2430 [label="'float' 2431"];
2431 [label="return 'float'; 2432"];
2432 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2433"];
2433 [label="'decimal' 2434"];
2434 [label="return 'decimal'; 2435"];
2435 [label="return SyntaxFacts.GetText(this.Kind); 2436"];
2436 [label="FullWidth 2437"];
2437 [label="'decimal' 2438"];
2438 [label="return 'decimal'; 2439"];
2439 [label="s_tokensWithElasticTrivia[(int)kind].Value 2440"];
2440 [label="'decimal' 2441"];
2441 [label="return 'decimal'; 2442"];
2442 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2443"];
2443 [label="'decimal' 2444"];
2444 [label="return 'decimal'; 2445"];
2445 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2446"];
2446 [label="'string' 2447"];
2447 [label="return 'string'; 2448"];
2448 [label="return SyntaxFacts.GetText(this.Kind); 2449"];
2449 [label="FullWidth 2450"];
2450 [label="'string' 2451"];
2451 [label="return 'string'; 2452"];
2452 [label="s_tokensWithElasticTrivia[(int)kind].Value 2453"];
2453 [label="'string' 2454"];
2454 [label="return 'string'; 2455"];
2455 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2456"];
2456 [label="'string' 2457"];
2457 [label="return 'string'; 2458"];
2458 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2459"];
2459 [label="'char' 2460"];
2460 [label="return 'char'; 2461"];
2461 [label="return SyntaxFacts.GetText(this.Kind); 2462"];
2462 [label="FullWidth 2463"];
2463 [label="'char' 2464"];
2464 [label="return 'char'; 2465"];
2465 [label="s_tokensWithElasticTrivia[(int)kind].Value 2466"];
2466 [label="'char' 2467"];
2467 [label="return 'char'; 2468"];
2468 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2469"];
2469 [label="'char' 2470"];
2470 [label="return 'char'; 2471"];
2471 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2472"];
2472 [label="'void' 2473"];
2473 [label="return 'void'; 2474"];
2474 [label="return SyntaxFacts.GetText(this.Kind); 2475"];
2475 [label="FullWidth 2476"];
2476 [label="'void' 2477"];
2477 [label="return 'void'; 2478"];
2478 [label="s_tokensWithElasticTrivia[(int)kind].Value 2479"];
2479 [label="'void' 2480"];
2480 [label="return 'void'; 2481"];
2481 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2482"];
2482 [label="'void' 2483"];
2483 [label="return 'void'; 2484"];
2484 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2485"];
2485 [label="'object' 2486"];
2486 [label="return 'object'; 2487"];
2487 [label="return SyntaxFacts.GetText(this.Kind); 2488"];
2488 [label="FullWidth 2489"];
2489 [label="'object' 2490"];
2490 [label="return 'object'; 2491"];
2491 [label="s_tokensWithElasticTrivia[(int)kind].Value 2492"];
2492 [label="'object' 2493"];
2493 [label="return 'object'; 2494"];
2494 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2495"];
2495 [label="'object' 2496"];
2496 [label="return 'object'; 2497"];
2497 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2498"];
2498 [label="'typeof' 2499"];
2499 [label="return 'typeof'; 2500"];
2500 [label="return SyntaxFacts.GetText(this.Kind); 2501"];
2501 [label="FullWidth 2502"];
2502 [label="'typeof' 2503"];
2503 [label="return 'typeof'; 2504"];
2504 [label="s_tokensWithElasticTrivia[(int)kind].Value 2505"];
2505 [label="'typeof' 2506"];
2506 [label="return 'typeof'; 2507"];
2507 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2508"];
2508 [label="'typeof' 2509"];
2509 [label="return 'typeof'; 2510"];
2510 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2511"];
2511 [label="'sizeof' 2512"];
2512 [label="return 'sizeof'; 2513"];
2513 [label="return SyntaxFacts.GetText(this.Kind); 2514"];
2514 [label="FullWidth 2515"];
2515 [label="'sizeof' 2516"];
2516 [label="return 'sizeof'; 2517"];
2517 [label="s_tokensWithElasticTrivia[(int)kind].Value 2518"];
2518 [label="'sizeof' 2519"];
2519 [label="return 'sizeof'; 2520"];
2520 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2521"];
2521 [label="'sizeof' 2522"];
2522 [label="return 'sizeof'; 2523"];
2523 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2524"];
2524 [label="'null' 2525"];
2525 [label="return 'null'; 2526"];
2526 [label="return SyntaxFacts.GetText(this.Kind); 2527"];
2527 [label="FullWidth 2528"];
2528 [label="'null' 2529"];
2529 [label="return 'null'; 2530"];
2530 [label="s_tokensWithElasticTrivia[(int)kind].Value 2531"];
2531 [label="'null' 2532"];
2532 [label="return 'null'; 2533"];
2533 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2534"];
2534 [label="'null' 2535"];
2535 [label="return 'null'; 2536"];
2536 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2537"];
2537 [label="'true' 2538"];
2538 [label="return 'true'; 2539"];
2539 [label="return SyntaxFacts.GetText(this.Kind); 2540"];
2540 [label="FullWidth 2541"];
2541 [label="'true' 2542"];
2542 [label="return 'true'; 2543"];
2543 [label="s_tokensWithElasticTrivia[(int)kind].Value 2544"];
2544 [label="'true' 2545"];
2545 [label="return 'true'; 2546"];
2546 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2547"];
2547 [label="'true' 2548"];
2548 [label="return 'true'; 2549"];
2549 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2550"];
2550 [label="'false' 2551"];
2551 [label="return 'false'; 2552"];
2552 [label="return SyntaxFacts.GetText(this.Kind); 2553"];
2553 [label="FullWidth 2554"];
2554 [label="'false' 2555"];
2555 [label="return 'false'; 2556"];
2556 [label="s_tokensWithElasticTrivia[(int)kind].Value 2557"];
2557 [label="'false' 2558"];
2558 [label="return 'false'; 2559"];
2559 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2560"];
2560 [label="'false' 2561"];
2561 [label="return 'false'; 2562"];
2562 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2563"];
2563 [label="'if' 2564"];
2564 [label="return 'if'; 2565"];
2565 [label="return SyntaxFacts.GetText(this.Kind); 2566"];
2566 [label="FullWidth 2567"];
2567 [label="'if' 2568"];
2568 [label="return 'if'; 2569"];
2569 [label="s_tokensWithElasticTrivia[(int)kind].Value 2570"];
2570 [label="'if' 2571"];
2571 [label="return 'if'; 2572"];
2572 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2573"];
2573 [label="'if' 2574"];
2574 [label="return 'if'; 2575"];
2575 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2576"];
2576 [label="'else' 2577"];
2577 [label="return 'else'; 2578"];
2578 [label="return SyntaxFacts.GetText(this.Kind); 2579"];
2579 [label="FullWidth 2580"];
2580 [label="'else' 2581"];
2581 [label="return 'else'; 2582"];
2582 [label="s_tokensWithElasticTrivia[(int)kind].Value 2583"];
2583 [label="'else' 2584"];
2584 [label="return 'else'; 2585"];
2585 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2586"];
2586 [label="'else' 2587"];
2587 [label="return 'else'; 2588"];
2588 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2589"];
2589 [label="'while' 2590"];
2590 [label="return 'while'; 2591"];
2591 [label="return SyntaxFacts.GetText(this.Kind); 2592"];
2592 [label="FullWidth 2593"];
2593 [label="'while' 2594"];
2594 [label="return 'while'; 2595"];
2595 [label="s_tokensWithElasticTrivia[(int)kind].Value 2596"];
2596 [label="'while' 2597"];
2597 [label="return 'while'; 2598"];
2598 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2599"];
2599 [label="'while' 2600"];
2600 [label="return 'while'; 2601"];
2601 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2602"];
2602 [label="'for' 2603"];
2603 [label="return 'for'; 2604"];
2604 [label="return SyntaxFacts.GetText(this.Kind); 2605"];
2605 [label="FullWidth 2606"];
2606 [label="'for' 2607"];
2607 [label="return 'for'; 2608"];
2608 [label="s_tokensWithElasticTrivia[(int)kind].Value 2609"];
2609 [label="'for' 2610"];
2610 [label="return 'for'; 2611"];
2611 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2612"];
2612 [label="'for' 2613"];
2613 [label="return 'for'; 2614"];
2614 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2615"];
2615 [label="'foreach' 2616"];
2616 [label="return 'foreach'; 2617"];
2617 [label="return SyntaxFacts.GetText(this.Kind); 2618"];
2618 [label="FullWidth 2619"];
2619 [label="'foreach' 2620"];
2620 [label="return 'foreach'; 2621"];
2621 [label="s_tokensWithElasticTrivia[(int)kind].Value 2622"];
2622 [label="'foreach' 2623"];
2623 [label="return 'foreach'; 2624"];
2624 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2625"];
2625 [label="'foreach' 2626"];
2626 [label="return 'foreach'; 2627"];
2627 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2628"];
2628 [label="'do' 2629"];
2629 [label="return 'do'; 2630"];
2630 [label="return SyntaxFacts.GetText(this.Kind); 2631"];
2631 [label="FullWidth 2632"];
2632 [label="'do' 2633"];
2633 [label="return 'do'; 2634"];
2634 [label="s_tokensWithElasticTrivia[(int)kind].Value 2635"];
2635 [label="'do' 2636"];
2636 [label="return 'do'; 2637"];
2637 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2638"];
2638 [label="'do' 2639"];
2639 [label="return 'do'; 2640"];
2640 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2641"];
2641 [label="'switch' 2642"];
2642 [label="return 'switch'; 2643"];
2643 [label="return SyntaxFacts.GetText(this.Kind); 2644"];
2644 [label="FullWidth 2645"];
2645 [label="'switch' 2646"];
2646 [label="return 'switch'; 2647"];
2647 [label="s_tokensWithElasticTrivia[(int)kind].Value 2648"];
2648 [label="'switch' 2649"];
2649 [label="return 'switch'; 2650"];
2650 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2651"];
2651 [label="'switch' 2652"];
2652 [label="return 'switch'; 2653"];
2653 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2654"];
2654 [label="'case' 2655"];
2655 [label="return 'case'; 2656"];
2656 [label="return SyntaxFacts.GetText(this.Kind); 2657"];
2657 [label="FullWidth 2658"];
2658 [label="'case' 2659"];
2659 [label="return 'case'; 2660"];
2660 [label="s_tokensWithElasticTrivia[(int)kind].Value 2661"];
2661 [label="'case' 2662"];
2662 [label="return 'case'; 2663"];
2663 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2664"];
2664 [label="'case' 2665"];
2665 [label="return 'case'; 2666"];
2666 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2667"];
2667 [label="'default' 2668"];
2668 [label="return 'default'; 2669"];
2669 [label="return SyntaxFacts.GetText(this.Kind); 2670"];
2670 [label="FullWidth 2671"];
2671 [label="'default' 2672"];
2672 [label="return 'default'; 2673"];
2673 [label="s_tokensWithElasticTrivia[(int)kind].Value 2674"];
2674 [label="'default' 2675"];
2675 [label="return 'default'; 2676"];
2676 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2677"];
2677 [label="'default' 2678"];
2678 [label="return 'default'; 2679"];
2679 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2680"];
2680 [label="'try' 2681"];
2681 [label="return 'try'; 2682"];
2682 [label="return SyntaxFacts.GetText(this.Kind); 2683"];
2683 [label="FullWidth 2684"];
2684 [label="'try' 2685"];
2685 [label="return 'try'; 2686"];
2686 [label="s_tokensWithElasticTrivia[(int)kind].Value 2687"];
2687 [label="'try' 2688"];
2688 [label="return 'try'; 2689"];
2689 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2690"];
2690 [label="'try' 2691"];
2691 [label="return 'try'; 2692"];
2692 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2693"];
2693 [label="'catch' 2694"];
2694 [label="return 'catch'; 2695"];
2695 [label="return SyntaxFacts.GetText(this.Kind); 2696"];
2696 [label="FullWidth 2697"];
2697 [label="'catch' 2698"];
2698 [label="return 'catch'; 2699"];
2699 [label="s_tokensWithElasticTrivia[(int)kind].Value 2700"];
2700 [label="'catch' 2701"];
2701 [label="return 'catch'; 2702"];
2702 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2703"];
2703 [label="'catch' 2704"];
2704 [label="return 'catch'; 2705"];
2705 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2706"];
2706 [label="'finally' 2707"];
2707 [label="return 'finally'; 2708"];
2708 [label="return SyntaxFacts.GetText(this.Kind); 2709"];
2709 [label="FullWidth 2710"];
2710 [label="'finally' 2711"];
2711 [label="return 'finally'; 2712"];
2712 [label="s_tokensWithElasticTrivia[(int)kind].Value 2713"];
2713 [label="'finally' 2714"];
2714 [label="return 'finally'; 2715"];
2715 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2716"];
2716 [label="'finally' 2717"];
2717 [label="return 'finally'; 2718"];
2718 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2719"];
2719 [label="'lock' 2720"];
2720 [label="return 'lock'; 2721"];
2721 [label="return SyntaxFacts.GetText(this.Kind); 2722"];
2722 [label="FullWidth 2723"];
2723 [label="'lock' 2724"];
2724 [label="return 'lock'; 2725"];
2725 [label="s_tokensWithElasticTrivia[(int)kind].Value 2726"];
2726 [label="'lock' 2727"];
2727 [label="return 'lock'; 2728"];
2728 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2729"];
2729 [label="'lock' 2730"];
2730 [label="return 'lock'; 2731"];
2731 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2732"];
2732 [label="'goto' 2733"];
2733 [label="return 'goto'; 2734"];
2734 [label="return SyntaxFacts.GetText(this.Kind); 2735"];
2735 [label="FullWidth 2736"];
2736 [label="'goto' 2737"];
2737 [label="return 'goto'; 2738"];
2738 [label="s_tokensWithElasticTrivia[(int)kind].Value 2739"];
2739 [label="'goto' 2740"];
2740 [label="return 'goto'; 2741"];
2741 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2742"];
2742 [label="'goto' 2743"];
2743 [label="return 'goto'; 2744"];
2744 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2745"];
2745 [label="'break' 2746"];
2746 [label="return 'break'; 2747"];
2747 [label="return SyntaxFacts.GetText(this.Kind); 2748"];
2748 [label="FullWidth 2749"];
2749 [label="'break' 2750"];
2750 [label="return 'break'; 2751"];
2751 [label="s_tokensWithElasticTrivia[(int)kind].Value 2752"];
2752 [label="'break' 2753"];
2753 [label="return 'break'; 2754"];
2754 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2755"];
2755 [label="'break' 2756"];
2756 [label="return 'break'; 2757"];
2757 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2758"];
2758 [label="'continue' 2759"];
2759 [label="return 'continue'; 2760"];
2760 [label="return SyntaxFacts.GetText(this.Kind); 2761"];
2761 [label="FullWidth 2762"];
2762 [label="'continue' 2763"];
2763 [label="return 'continue'; 2764"];
2764 [label="s_tokensWithElasticTrivia[(int)kind].Value 2765"];
2765 [label="'continue' 2766"];
2766 [label="return 'continue'; 2767"];
2767 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2768"];
2768 [label="'continue' 2769"];
2769 [label="return 'continue'; 2770"];
2770 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2771"];
2771 [label="'return' 2772"];
2772 [label="return 'return'; 2773"];
2773 [label="return SyntaxFacts.GetText(this.Kind); 2774"];
2774 [label="FullWidth 2775"];
2775 [label="'return' 2776"];
2776 [label="return 'return'; 2777"];
2777 [label="s_tokensWithElasticTrivia[(int)kind].Value 2778"];
2778 [label="'return' 2779"];
2779 [label="return 'return'; 2780"];
2780 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2781"];
2781 [label="'return' 2782"];
2782 [label="return 'return'; 2783"];
2783 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2784"];
2784 [label="'throw' 2785"];
2785 [label="return 'throw'; 2786"];
2786 [label="return SyntaxFacts.GetText(this.Kind); 2787"];
2787 [label="FullWidth 2788"];
2788 [label="'throw' 2789"];
2789 [label="return 'throw'; 2790"];
2790 [label="s_tokensWithElasticTrivia[(int)kind].Value 2791"];
2791 [label="'throw' 2792"];
2792 [label="return 'throw'; 2793"];
2793 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2794"];
2794 [label="'throw' 2795"];
2795 [label="return 'throw'; 2796"];
2796 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2797"];
2797 [label="'public' 2798"];
2798 [label="return 'public'; 2799"];
2799 [label="return SyntaxFacts.GetText(this.Kind); 2800"];
2800 [label="FullWidth 2801"];
2801 [label="'public' 2802"];
2802 [label="return 'public'; 2803"];
2803 [label="s_tokensWithElasticTrivia[(int)kind].Value 2804"];
2804 [label="'public' 2805"];
2805 [label="return 'public'; 2806"];
2806 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2807"];
2807 [label="'public' 2808"];
2808 [label="return 'public'; 2809"];
2809 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2810"];
2810 [label="'private' 2811"];
2811 [label="return 'private'; 2812"];
2812 [label="return SyntaxFacts.GetText(this.Kind); 2813"];
2813 [label="FullWidth 2814"];
2814 [label="'private' 2815"];
2815 [label="return 'private'; 2816"];
2816 [label="s_tokensWithElasticTrivia[(int)kind].Value 2817"];
2817 [label="'private' 2818"];
2818 [label="return 'private'; 2819"];
2819 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2820"];
2820 [label="'private' 2821"];
2821 [label="return 'private'; 2822"];
2822 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2823"];
2823 [label="'internal' 2824"];
2824 [label="return 'internal'; 2825"];
2825 [label="return SyntaxFacts.GetText(this.Kind); 2826"];
2826 [label="FullWidth 2827"];
2827 [label="'internal' 2828"];
2828 [label="return 'internal'; 2829"];
2829 [label="s_tokensWithElasticTrivia[(int)kind].Value 2830"];
2830 [label="'internal' 2831"];
2831 [label="return 'internal'; 2832"];
2832 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2833"];
2833 [label="'internal' 2834"];
2834 [label="return 'internal'; 2835"];
2835 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2836"];
2836 [label="'protected' 2837"];
2837 [label="return 'protected'; 2838"];
2838 [label="return SyntaxFacts.GetText(this.Kind); 2839"];
2839 [label="FullWidth 2840"];
2840 [label="'protected' 2841"];
2841 [label="return 'protected'; 2842"];
2842 [label="s_tokensWithElasticTrivia[(int)kind].Value 2843"];
2843 [label="'protected' 2844"];
2844 [label="return 'protected'; 2845"];
2845 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2846"];
2846 [label="'protected' 2847"];
2847 [label="return 'protected'; 2848"];
2848 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2849"];
2849 [label="'static' 2850"];
2850 [label="return 'static'; 2851"];
2851 [label="return SyntaxFacts.GetText(this.Kind); 2852"];
2852 [label="FullWidth 2853"];
2853 [label="'static' 2854"];
2854 [label="return 'static'; 2855"];
2855 [label="s_tokensWithElasticTrivia[(int)kind].Value 2856"];
2856 [label="'static' 2857"];
2857 [label="return 'static'; 2858"];
2858 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2859"];
2859 [label="'static' 2860"];
2860 [label="return 'static'; 2861"];
2861 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2862"];
2862 [label="'readonly' 2863"];
2863 [label="return 'readonly'; 2864"];
2864 [label="return SyntaxFacts.GetText(this.Kind); 2865"];
2865 [label="FullWidth 2866"];
2866 [label="'readonly' 2867"];
2867 [label="return 'readonly'; 2868"];
2868 [label="s_tokensWithElasticTrivia[(int)kind].Value 2869"];
2869 [label="'readonly' 2870"];
2870 [label="return 'readonly'; 2871"];
2871 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2872"];
2872 [label="'readonly' 2873"];
2873 [label="return 'readonly'; 2874"];
2874 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2875"];
2875 [label="'sealed' 2876"];
2876 [label="return 'sealed'; 2877"];
2877 [label="return SyntaxFacts.GetText(this.Kind); 2878"];
2878 [label="FullWidth 2879"];
2879 [label="'sealed' 2880"];
2880 [label="return 'sealed'; 2881"];
2881 [label="s_tokensWithElasticTrivia[(int)kind].Value 2882"];
2882 [label="'sealed' 2883"];
2883 [label="return 'sealed'; 2884"];
2884 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2885"];
2885 [label="'sealed' 2886"];
2886 [label="return 'sealed'; 2887"];
2887 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2888"];
2888 [label="'const' 2889"];
2889 [label="return 'const'; 2890"];
2890 [label="return SyntaxFacts.GetText(this.Kind); 2891"];
2891 [label="FullWidth 2892"];
2892 [label="'const' 2893"];
2893 [label="return 'const'; 2894"];
2894 [label="s_tokensWithElasticTrivia[(int)kind].Value 2895"];
2895 [label="'const' 2896"];
2896 [label="return 'const'; 2897"];
2897 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2898"];
2898 [label="'const' 2899"];
2899 [label="return 'const'; 2900"];
2900 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2901"];
2901 [label="'fixed' 2902"];
2902 [label="return 'fixed'; 2903"];
2903 [label="return SyntaxFacts.GetText(this.Kind); 2904"];
2904 [label="FullWidth 2905"];
2905 [label="'fixed' 2906"];
2906 [label="return 'fixed'; 2907"];
2907 [label="s_tokensWithElasticTrivia[(int)kind].Value 2908"];
2908 [label="'fixed' 2909"];
2909 [label="return 'fixed'; 2910"];
2910 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2911"];
2911 [label="'fixed' 2912"];
2912 [label="return 'fixed'; 2913"];
2913 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2914"];
2914 [label="'stackalloc' 2915"];
2915 [label="return 'stackalloc'; 2916"];
2916 [label="return SyntaxFacts.GetText(this.Kind); 2917"];
2917 [label="FullWidth 2918"];
2918 [label="'stackalloc' 2919"];
2919 [label="return 'stackalloc'; 2920"];
2920 [label="s_tokensWithElasticTrivia[(int)kind].Value 2921"];
2921 [label="'stackalloc' 2922"];
2922 [label="return 'stackalloc'; 2923"];
2923 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2924"];
2924 [label="'stackalloc' 2925"];
2925 [label="return 'stackalloc'; 2926"];
2926 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2927"];
2927 [label="'volatile' 2928"];
2928 [label="return 'volatile'; 2929"];
2929 [label="return SyntaxFacts.GetText(this.Kind); 2930"];
2930 [label="FullWidth 2931"];
2931 [label="'volatile' 2932"];
2932 [label="return 'volatile'; 2933"];
2933 [label="s_tokensWithElasticTrivia[(int)kind].Value 2934"];
2934 [label="'volatile' 2935"];
2935 [label="return 'volatile'; 2936"];
2936 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2937"];
2937 [label="'volatile' 2938"];
2938 [label="return 'volatile'; 2939"];
2939 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2940"];
2940 [label="'new' 2941"];
2941 [label="return 'new'; 2942"];
2942 [label="return SyntaxFacts.GetText(this.Kind); 2943"];
2943 [label="FullWidth 2944"];
2944 [label="'new' 2945"];
2945 [label="return 'new'; 2946"];
2946 [label="s_tokensWithElasticTrivia[(int)kind].Value 2947"];
2947 [label="'new' 2948"];
2948 [label="return 'new'; 2949"];
2949 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2950"];
2950 [label="'new' 2951"];
2951 [label="return 'new'; 2952"];
2952 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2953"];
2953 [label="'override' 2954"];
2954 [label="return 'override'; 2955"];
2955 [label="return SyntaxFacts.GetText(this.Kind); 2956"];
2956 [label="FullWidth 2957"];
2957 [label="'override' 2958"];
2958 [label="return 'override'; 2959"];
2959 [label="s_tokensWithElasticTrivia[(int)kind].Value 2960"];
2960 [label="'override' 2961"];
2961 [label="return 'override'; 2962"];
2962 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2963"];
2963 [label="'override' 2964"];
2964 [label="return 'override'; 2965"];
2965 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2966"];
2966 [label="'abstract' 2967"];
2967 [label="return 'abstract'; 2968"];
2968 [label="return SyntaxFacts.GetText(this.Kind); 2969"];
2969 [label="FullWidth 2970"];
2970 [label="'abstract' 2971"];
2971 [label="return 'abstract'; 2972"];
2972 [label="s_tokensWithElasticTrivia[(int)kind].Value 2973"];
2973 [label="'abstract' 2974"];
2974 [label="return 'abstract'; 2975"];
2975 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2976"];
2976 [label="'abstract' 2977"];
2977 [label="return 'abstract'; 2978"];
2978 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2979"];
2979 [label="'virtual' 2980"];
2980 [label="return 'virtual'; 2981"];
2981 [label="return SyntaxFacts.GetText(this.Kind); 2982"];
2982 [label="FullWidth 2983"];
2983 [label="'virtual' 2984"];
2984 [label="return 'virtual'; 2985"];
2985 [label="s_tokensWithElasticTrivia[(int)kind].Value 2986"];
2986 [label="'virtual' 2987"];
2987 [label="return 'virtual'; 2988"];
2988 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 2989"];
2989 [label="'virtual' 2990"];
2990 [label="return 'virtual'; 2991"];
2991 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 2992"];
2992 [label="'event' 2993"];
2993 [label="return 'event'; 2994"];
2994 [label="return SyntaxFacts.GetText(this.Kind); 2995"];
2995 [label="FullWidth 2996"];
2996 [label="'event' 2997"];
2997 [label="return 'event'; 2998"];
2998 [label="s_tokensWithElasticTrivia[(int)kind].Value 2999"];
2999 [label="'event' 3000"];
3000 [label="return 'event'; 3001"];
3001 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3002"];
3002 [label="'event' 3003"];
3003 [label="return 'event'; 3004"];
3004 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3005"];
3005 [label="'extern' 3006"];
3006 [label="return 'extern'; 3007"];
3007 [label="return SyntaxFacts.GetText(this.Kind); 3008"];
3008 [label="FullWidth 3009"];
3009 [label="'extern' 3010"];
3010 [label="return 'extern'; 3011"];
3011 [label="s_tokensWithElasticTrivia[(int)kind].Value 3012"];
3012 [label="'extern' 3013"];
3013 [label="return 'extern'; 3014"];
3014 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3015"];
3015 [label="'extern' 3016"];
3016 [label="return 'extern'; 3017"];
3017 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3018"];
3018 [label="'ref' 3019"];
3019 [label="return 'ref'; 3020"];
3020 [label="return SyntaxFacts.GetText(this.Kind); 3021"];
3021 [label="FullWidth 3022"];
3022 [label="'ref' 3023"];
3023 [label="return 'ref'; 3024"];
3024 [label="s_tokensWithElasticTrivia[(int)kind].Value 3025"];
3025 [label="'ref' 3026"];
3026 [label="return 'ref'; 3027"];
3027 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3028"];
3028 [label="'ref' 3029"];
3029 [label="return 'ref'; 3030"];
3030 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3031"];
3031 [label="'out' 3032"];
3032 [label="return 'out'; 3033"];
3033 [label="return SyntaxFacts.GetText(this.Kind); 3034"];
3034 [label="FullWidth 3035"];
3035 [label="'out' 3036"];
3036 [label="return 'out'; 3037"];
3037 [label="s_tokensWithElasticTrivia[(int)kind].Value 3038"];
3038 [label="'out' 3039"];
3039 [label="return 'out'; 3040"];
3040 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3041"];
3041 [label="'out' 3042"];
3042 [label="return 'out'; 3043"];
3043 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3044"];
3044 [label="'in' 3045"];
3045 [label="return 'in'; 3046"];
3046 [label="return SyntaxFacts.GetText(this.Kind); 3047"];
3047 [label="FullWidth 3048"];
3048 [label="'in' 3049"];
3049 [label="return 'in'; 3050"];
3050 [label="s_tokensWithElasticTrivia[(int)kind].Value 3051"];
3051 [label="'in' 3052"];
3052 [label="return 'in'; 3053"];
3053 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3054"];
3054 [label="'in' 3055"];
3055 [label="return 'in'; 3056"];
3056 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3057"];
3057 [label="'is' 3058"];
3058 [label="return 'is'; 3059"];
3059 [label="return SyntaxFacts.GetText(this.Kind); 3060"];
3060 [label="FullWidth 3061"];
3061 [label="'is' 3062"];
3062 [label="return 'is'; 3063"];
3063 [label="s_tokensWithElasticTrivia[(int)kind].Value 3064"];
3064 [label="'is' 3065"];
3065 [label="return 'is'; 3066"];
3066 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3067"];
3067 [label="'is' 3068"];
3068 [label="return 'is'; 3069"];
3069 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3070"];
3070 [label="'as' 3071"];
3071 [label="return 'as'; 3072"];
3072 [label="return SyntaxFacts.GetText(this.Kind); 3073"];
3073 [label="FullWidth 3074"];
3074 [label="'as' 3075"];
3075 [label="return 'as'; 3076"];
3076 [label="s_tokensWithElasticTrivia[(int)kind].Value 3077"];
3077 [label="'as' 3078"];
3078 [label="return 'as'; 3079"];
3079 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3080"];
3080 [label="'as' 3081"];
3081 [label="return 'as'; 3082"];
3082 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3083"];
3083 [label="'params' 3084"];
3084 [label="return 'params'; 3085"];
3085 [label="return SyntaxFacts.GetText(this.Kind); 3086"];
3086 [label="FullWidth 3087"];
3087 [label="'params' 3088"];
3088 [label="return 'params'; 3089"];
3089 [label="s_tokensWithElasticTrivia[(int)kind].Value 3090"];
3090 [label="'params' 3091"];
3091 [label="return 'params'; 3092"];
3092 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3093"];
3093 [label="'params' 3094"];
3094 [label="return 'params'; 3095"];
3095 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3096"];
3096 [label="'__arglist' 3097"];
3097 [label="return '__arglist'; 3098"];
3098 [label="return SyntaxFacts.GetText(this.Kind); 3099"];
3099 [label="FullWidth 3100"];
3100 [label="'__arglist' 3101"];
3101 [label="return '__arglist'; 3102"];
3102 [label="s_tokensWithElasticTrivia[(int)kind].Value 3103"];
3103 [label="'__arglist' 3104"];
3104 [label="return '__arglist'; 3105"];
3105 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3106"];
3106 [label="'__arglist' 3107"];
3107 [label="return '__arglist'; 3108"];
3108 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3109"];
3109 [label="'__makeref' 3110"];
3110 [label="return '__makeref'; 3111"];
3111 [label="return SyntaxFacts.GetText(this.Kind); 3112"];
3112 [label="FullWidth 3113"];
3113 [label="'__makeref' 3114"];
3114 [label="return '__makeref'; 3115"];
3115 [label="s_tokensWithElasticTrivia[(int)kind].Value 3116"];
3116 [label="'__makeref' 3117"];
3117 [label="return '__makeref'; 3118"];
3118 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3119"];
3119 [label="'__makeref' 3120"];
3120 [label="return '__makeref'; 3121"];
3121 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3122"];
3122 [label="'__reftype' 3123"];
3123 [label="return '__reftype'; 3124"];
3124 [label="return SyntaxFacts.GetText(this.Kind); 3125"];
3125 [label="FullWidth 3126"];
3126 [label="'__reftype' 3127"];
3127 [label="return '__reftype'; 3128"];
3128 [label="s_tokensWithElasticTrivia[(int)kind].Value 3129"];
3129 [label="'__reftype' 3130"];
3130 [label="return '__reftype'; 3131"];
3131 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3132"];
3132 [label="'__reftype' 3133"];
3133 [label="return '__reftype'; 3134"];
3134 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3135"];
3135 [label="'__refvalue' 3136"];
3136 [label="return '__refvalue'; 3137"];
3137 [label="return SyntaxFacts.GetText(this.Kind); 3138"];
3138 [label="FullWidth 3139"];
3139 [label="'__refvalue' 3140"];
3140 [label="return '__refvalue'; 3141"];
3141 [label="s_tokensWithElasticTrivia[(int)kind].Value 3142"];
3142 [label="'__refvalue' 3143"];
3143 [label="return '__refvalue'; 3144"];
3144 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3145"];
3145 [label="'__refvalue' 3146"];
3146 [label="return '__refvalue'; 3147"];
3147 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3148"];
3148 [label="'this' 3149"];
3149 [label="return 'this'; 3150"];
3150 [label="return SyntaxFacts.GetText(this.Kind); 3151"];
3151 [label="FullWidth 3152"];
3152 [label="'this' 3153"];
3153 [label="return 'this'; 3154"];
3154 [label="s_tokensWithElasticTrivia[(int)kind].Value 3155"];
3155 [label="'this' 3156"];
3156 [label="return 'this'; 3157"];
3157 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3158"];
3158 [label="'this' 3159"];
3159 [label="return 'this'; 3160"];
3160 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3161"];
3161 [label="'base' 3162"];
3162 [label="return 'base'; 3163"];
3163 [label="return SyntaxFacts.GetText(this.Kind); 3164"];
3164 [label="FullWidth 3165"];
3165 [label="'base' 3166"];
3166 [label="return 'base'; 3167"];
3167 [label="s_tokensWithElasticTrivia[(int)kind].Value 3168"];
3168 [label="'base' 3169"];
3169 [label="return 'base'; 3170"];
3170 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3171"];
3171 [label="'base' 3172"];
3172 [label="return 'base'; 3173"];
3173 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3174"];
3174 [label="'namespace' 3175"];
3175 [label="return 'namespace'; 3176"];
3176 [label="return SyntaxFacts.GetText(this.Kind); 3177"];
3177 [label="FullWidth 3178"];
3178 [label="'namespace' 3179"];
3179 [label="return 'namespace'; 3180"];
3180 [label="s_tokensWithElasticTrivia[(int)kind].Value 3181"];
3181 [label="'namespace' 3182"];
3182 [label="return 'namespace'; 3183"];
3183 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3184"];
3184 [label="'namespace' 3185"];
3185 [label="return 'namespace'; 3186"];
3186 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3187"];
3187 [label="'using' 3188"];
3188 [label="return 'using'; 3189"];
3189 [label="return SyntaxFacts.GetText(this.Kind); 3190"];
3190 [label="FullWidth 3191"];
3191 [label="'using' 3192"];
3192 [label="return 'using'; 3193"];
3193 [label="s_tokensWithElasticTrivia[(int)kind].Value 3194"];
3194 [label="'using' 3195"];
3195 [label="return 'using'; 3196"];
3196 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3197"];
3197 [label="'using' 3198"];
3198 [label="return 'using'; 3199"];
3199 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3200"];
3200 [label="'class' 3201"];
3201 [label="return 'class'; 3202"];
3202 [label="return SyntaxFacts.GetText(this.Kind); 3203"];
3203 [label="FullWidth 3204"];
3204 [label="'class' 3205"];
3205 [label="return 'class'; 3206"];
3206 [label="s_tokensWithElasticTrivia[(int)kind].Value 3207"];
3207 [label="'class' 3208"];
3208 [label="return 'class'; 3209"];
3209 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3210"];
3210 [label="'class' 3211"];
3211 [label="return 'class'; 3212"];
3212 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3213"];
3213 [label="'struct' 3214"];
3214 [label="return 'struct'; 3215"];
3215 [label="return SyntaxFacts.GetText(this.Kind); 3216"];
3216 [label="FullWidth 3217"];
3217 [label="'struct' 3218"];
3218 [label="return 'struct'; 3219"];
3219 [label="s_tokensWithElasticTrivia[(int)kind].Value 3220"];
3220 [label="'struct' 3221"];
3221 [label="return 'struct'; 3222"];
3222 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3223"];
3223 [label="'struct' 3224"];
3224 [label="return 'struct'; 3225"];
3225 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3226"];
3226 [label="'interface' 3227"];
3227 [label="return 'interface'; 3228"];
3228 [label="return SyntaxFacts.GetText(this.Kind); 3229"];
3229 [label="FullWidth 3230"];
3230 [label="'interface' 3231"];
3231 [label="return 'interface'; 3232"];
3232 [label="s_tokensWithElasticTrivia[(int)kind].Value 3233"];
3233 [label="'interface' 3234"];
3234 [label="return 'interface'; 3235"];
3235 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3236"];
3236 [label="'interface' 3237"];
3237 [label="return 'interface'; 3238"];
3238 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3239"];
3239 [label="'enum' 3240"];
3240 [label="return 'enum'; 3241"];
3241 [label="return SyntaxFacts.GetText(this.Kind); 3242"];
3242 [label="FullWidth 3243"];
3243 [label="'enum' 3244"];
3244 [label="return 'enum'; 3245"];
3245 [label="s_tokensWithElasticTrivia[(int)kind].Value 3246"];
3246 [label="'enum' 3247"];
3247 [label="return 'enum'; 3248"];
3248 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3249"];
3249 [label="'enum' 3250"];
3250 [label="return 'enum'; 3251"];
3251 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3252"];
3252 [label="'delegate' 3253"];
3253 [label="return 'delegate'; 3254"];
3254 [label="return SyntaxFacts.GetText(this.Kind); 3255"];
3255 [label="FullWidth 3256"];
3256 [label="'delegate' 3257"];
3257 [label="return 'delegate'; 3258"];
3258 [label="s_tokensWithElasticTrivia[(int)kind].Value 3259"];
3259 [label="'delegate' 3260"];
3260 [label="return 'delegate'; 3261"];
3261 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3262"];
3262 [label="'delegate' 3263"];
3263 [label="return 'delegate'; 3264"];
3264 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3265"];
3265 [label="'checked' 3266"];
3266 [label="return 'checked'; 3267"];
3267 [label="return SyntaxFacts.GetText(this.Kind); 3268"];
3268 [label="FullWidth 3269"];
3269 [label="'checked' 3270"];
3270 [label="return 'checked'; 3271"];
3271 [label="s_tokensWithElasticTrivia[(int)kind].Value 3272"];
3272 [label="'checked' 3273"];
3273 [label="return 'checked'; 3274"];
3274 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3275"];
3275 [label="'checked' 3276"];
3276 [label="return 'checked'; 3277"];
3277 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3278"];
3278 [label="'unchecked' 3279"];
3279 [label="return 'unchecked'; 3280"];
3280 [label="return SyntaxFacts.GetText(this.Kind); 3281"];
3281 [label="FullWidth 3282"];
3282 [label="'unchecked' 3283"];
3283 [label="return 'unchecked'; 3284"];
3284 [label="s_tokensWithElasticTrivia[(int)kind].Value 3285"];
3285 [label="'unchecked' 3286"];
3286 [label="return 'unchecked'; 3287"];
3287 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3288"];
3288 [label="'unchecked' 3289"];
3289 [label="return 'unchecked'; 3290"];
3290 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3291"];
3291 [label="'unsafe' 3292"];
3292 [label="return 'unsafe'; 3293"];
3293 [label="return SyntaxFacts.GetText(this.Kind); 3294"];
3294 [label="FullWidth 3295"];
3295 [label="'unsafe' 3296"];
3296 [label="return 'unsafe'; 3297"];
3297 [label="s_tokensWithElasticTrivia[(int)kind].Value 3298"];
3298 [label="'unsafe' 3299"];
3299 [label="return 'unsafe'; 3300"];
3300 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3301"];
3301 [label="'unsafe' 3302"];
3302 [label="return 'unsafe'; 3303"];
3303 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3304"];
3304 [label="'operator' 3305"];
3305 [label="return 'operator'; 3306"];
3306 [label="return SyntaxFacts.GetText(this.Kind); 3307"];
3307 [label="FullWidth 3308"];
3308 [label="'operator' 3309"];
3309 [label="return 'operator'; 3310"];
3310 [label="s_tokensWithElasticTrivia[(int)kind].Value 3311"];
3311 [label="'operator' 3312"];
3312 [label="return 'operator'; 3313"];
3313 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3314"];
3314 [label="'operator' 3315"];
3315 [label="return 'operator'; 3316"];
3316 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3317"];
3317 [label="'explicit' 3318"];
3318 [label="return 'explicit'; 3319"];
3319 [label="return SyntaxFacts.GetText(this.Kind); 3320"];
3320 [label="FullWidth 3321"];
3321 [label="'explicit' 3322"];
3322 [label="return 'explicit'; 3323"];
3323 [label="s_tokensWithElasticTrivia[(int)kind].Value 3324"];
3324 [label="'explicit' 3325"];
3325 [label="return 'explicit'; 3326"];
3326 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3327"];
3327 [label="'explicit' 3328"];
3328 [label="return 'explicit'; 3329"];
3329 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3330"];
3330 [label="'implicit' 3331"];
3331 [label="return 'implicit'; 3332"];
3332 [label="return SyntaxFacts.GetText(this.Kind); 3333"];
3333 [label="FullWidth 3334"];
3334 [label="'implicit' 3335"];
3335 [label="return 'implicit'; 3336"];
3336 [label="s_tokensWithElasticTrivia[(int)kind].Value 3337"];
3337 [label="'implicit' 3338"];
3338 [label="return 'implicit'; 3339"];
3339 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3340"];
3340 [label="'implicit' 3341"];
3341 [label="return 'implicit'; 3342"];
3342 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3343"];
3343 [label="'yield' 3344"];
3344 [label="return 'yield'; 3345"];
3345 [label="return SyntaxFacts.GetText(this.Kind); 3346"];
3346 [label="FullWidth 3347"];
3347 [label="'yield' 3348"];
3348 [label="return 'yield'; 3349"];
3349 [label="s_tokensWithElasticTrivia[(int)kind].Value 3350"];
3350 [label="'yield' 3351"];
3351 [label="return 'yield'; 3352"];
3352 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3353"];
3353 [label="'yield' 3354"];
3354 [label="return 'yield'; 3355"];
3355 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3356"];
3356 [label="'partial' 3357"];
3357 [label="return 'partial'; 3358"];
3358 [label="return SyntaxFacts.GetText(this.Kind); 3359"];
3359 [label="FullWidth 3360"];
3360 [label="'partial' 3361"];
3361 [label="return 'partial'; 3362"];
3362 [label="s_tokensWithElasticTrivia[(int)kind].Value 3363"];
3363 [label="'partial' 3364"];
3364 [label="return 'partial'; 3365"];
3365 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3366"];
3366 [label="'partial' 3367"];
3367 [label="return 'partial'; 3368"];
3368 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3369"];
3369 [label="'alias' 3370"];
3370 [label="return 'alias'; 3371"];
3371 [label="return SyntaxFacts.GetText(this.Kind); 3372"];
3372 [label="FullWidth 3373"];
3373 [label="'alias' 3374"];
3374 [label="return 'alias'; 3375"];
3375 [label="s_tokensWithElasticTrivia[(int)kind].Value 3376"];
3376 [label="'alias' 3377"];
3377 [label="return 'alias'; 3378"];
3378 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3379"];
3379 [label="'alias' 3380"];
3380 [label="return 'alias'; 3381"];
3381 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3382"];
3382 [label="'global' 3383"];
3383 [label="return 'global'; 3384"];
3384 [label="return SyntaxFacts.GetText(this.Kind); 3385"];
3385 [label="FullWidth 3386"];
3386 [label="'global' 3387"];
3387 [label="return 'global'; 3388"];
3388 [label="s_tokensWithElasticTrivia[(int)kind].Value 3389"];
3389 [label="'global' 3390"];
3390 [label="return 'global'; 3391"];
3391 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3392"];
3392 [label="'global' 3393"];
3393 [label="return 'global'; 3394"];
3394 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3395"];
3395 [label="'assembly' 3396"];
3396 [label="return 'assembly'; 3397"];
3397 [label="return SyntaxFacts.GetText(this.Kind); 3398"];
3398 [label="FullWidth 3399"];
3399 [label="'assembly' 3400"];
3400 [label="return 'assembly'; 3401"];
3401 [label="s_tokensWithElasticTrivia[(int)kind].Value 3402"];
3402 [label="'assembly' 3403"];
3403 [label="return 'assembly'; 3404"];
3404 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3405"];
3405 [label="'assembly' 3406"];
3406 [label="return 'assembly'; 3407"];
3407 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3408"];
3408 [label="'module' 3409"];
3409 [label="return 'module'; 3410"];
3410 [label="return SyntaxFacts.GetText(this.Kind); 3411"];
3411 [label="FullWidth 3412"];
3412 [label="'module' 3413"];
3413 [label="return 'module'; 3414"];
3414 [label="s_tokensWithElasticTrivia[(int)kind].Value 3415"];
3415 [label="'module' 3416"];
3416 [label="return 'module'; 3417"];
3417 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3418"];
3418 [label="'module' 3419"];
3419 [label="return 'module'; 3420"];
3420 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3421"];
3421 [label="'type' 3422"];
3422 [label="return 'type'; 3423"];
3423 [label="return SyntaxFacts.GetText(this.Kind); 3424"];
3424 [label="FullWidth 3425"];
3425 [label="'type' 3426"];
3426 [label="return 'type'; 3427"];
3427 [label="s_tokensWithElasticTrivia[(int)kind].Value 3428"];
3428 [label="'type' 3429"];
3429 [label="return 'type'; 3430"];
3430 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3431"];
3431 [label="'type' 3432"];
3432 [label="return 'type'; 3433"];
3433 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3434"];
3434 [label="'field' 3435"];
3435 [label="return 'field'; 3436"];
3436 [label="return SyntaxFacts.GetText(this.Kind); 3437"];
3437 [label="FullWidth 3438"];
3438 [label="'field' 3439"];
3439 [label="return 'field'; 3440"];
3440 [label="s_tokensWithElasticTrivia[(int)kind].Value 3441"];
3441 [label="'field' 3442"];
3442 [label="return 'field'; 3443"];
3443 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3444"];
3444 [label="'field' 3445"];
3445 [label="return 'field'; 3446"];
3446 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3447"];
3447 [label="'method' 3448"];
3448 [label="return 'method'; 3449"];
3449 [label="return SyntaxFacts.GetText(this.Kind); 3450"];
3450 [label="FullWidth 3451"];
3451 [label="'method' 3452"];
3452 [label="return 'method'; 3453"];
3453 [label="s_tokensWithElasticTrivia[(int)kind].Value 3454"];
3454 [label="'method' 3455"];
3455 [label="return 'method'; 3456"];
3456 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3457"];
3457 [label="'method' 3458"];
3458 [label="return 'method'; 3459"];
3459 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3460"];
3460 [label="'param' 3461"];
3461 [label="return 'param'; 3462"];
3462 [label="return SyntaxFacts.GetText(this.Kind); 3463"];
3463 [label="FullWidth 3464"];
3464 [label="'param' 3465"];
3465 [label="return 'param'; 3466"];
3466 [label="s_tokensWithElasticTrivia[(int)kind].Value 3467"];
3467 [label="'param' 3468"];
3468 [label="return 'param'; 3469"];
3469 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3470"];
3470 [label="'param' 3471"];
3471 [label="return 'param'; 3472"];
3472 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3473"];
3473 [label="'property' 3474"];
3474 [label="return 'property'; 3475"];
3475 [label="return SyntaxFacts.GetText(this.Kind); 3476"];
3476 [label="FullWidth 3477"];
3477 [label="'property' 3478"];
3478 [label="return 'property'; 3479"];
3479 [label="s_tokensWithElasticTrivia[(int)kind].Value 3480"];
3480 [label="'property' 3481"];
3481 [label="return 'property'; 3482"];
3482 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3483"];
3483 [label="'property' 3484"];
3484 [label="return 'property'; 3485"];
3485 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3486"];
3486 [label="'typevar' 3487"];
3487 [label="return 'typevar'; 3488"];
3488 [label="return SyntaxFacts.GetText(this.Kind); 3489"];
3489 [label="FullWidth 3490"];
3490 [label="'typevar' 3491"];
3491 [label="return 'typevar'; 3492"];
3492 [label="s_tokensWithElasticTrivia[(int)kind].Value 3493"];
3493 [label="'typevar' 3494"];
3494 [label="return 'typevar'; 3495"];
3495 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3496"];
3496 [label="'typevar' 3497"];
3497 [label="return 'typevar'; 3498"];
3498 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3499"];
3499 [label="'get' 3500"];
3500 [label="return 'get'; 3501"];
3501 [label="return SyntaxFacts.GetText(this.Kind); 3502"];
3502 [label="FullWidth 3503"];
3503 [label="'get' 3504"];
3504 [label="return 'get'; 3505"];
3505 [label="s_tokensWithElasticTrivia[(int)kind].Value 3506"];
3506 [label="'get' 3507"];
3507 [label="return 'get'; 3508"];
3508 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3509"];
3509 [label="'get' 3510"];
3510 [label="return 'get'; 3511"];
3511 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3512"];
3512 [label="'set' 3513"];
3513 [label="return 'set'; 3514"];
3514 [label="return SyntaxFacts.GetText(this.Kind); 3515"];
3515 [label="FullWidth 3516"];
3516 [label="'set' 3517"];
3517 [label="return 'set'; 3518"];
3518 [label="s_tokensWithElasticTrivia[(int)kind].Value 3519"];
3519 [label="'set' 3520"];
3520 [label="return 'set'; 3521"];
3521 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3522"];
3522 [label="'set' 3523"];
3523 [label="return 'set'; 3524"];
3524 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3525"];
3525 [label="'add' 3526"];
3526 [label="return 'add'; 3527"];
3527 [label="return SyntaxFacts.GetText(this.Kind); 3528"];
3528 [label="FullWidth 3529"];
3529 [label="'add' 3530"];
3530 [label="return 'add'; 3531"];
3531 [label="s_tokensWithElasticTrivia[(int)kind].Value 3532"];
3532 [label="'add' 3533"];
3533 [label="return 'add'; 3534"];
3534 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3535"];
3535 [label="'add' 3536"];
3536 [label="return 'add'; 3537"];
3537 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3538"];
3538 [label="'remove' 3539"];
3539 [label="return 'remove'; 3540"];
3540 [label="return SyntaxFacts.GetText(this.Kind); 3541"];
3541 [label="FullWidth 3542"];
3542 [label="'remove' 3543"];
3543 [label="return 'remove'; 3544"];
3544 [label="s_tokensWithElasticTrivia[(int)kind].Value 3545"];
3545 [label="'remove' 3546"];
3546 [label="return 'remove'; 3547"];
3547 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3548"];
3548 [label="'remove' 3549"];
3549 [label="return 'remove'; 3550"];
3550 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3551"];
3551 [label="'where' 3552"];
3552 [label="return 'where'; 3553"];
3553 [label="return SyntaxFacts.GetText(this.Kind); 3554"];
3554 [label="FullWidth 3555"];
3555 [label="'where' 3556"];
3556 [label="return 'where'; 3557"];
3557 [label="s_tokensWithElasticTrivia[(int)kind].Value 3558"];
3558 [label="'where' 3559"];
3559 [label="return 'where'; 3560"];
3560 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3561"];
3561 [label="'where' 3562"];
3562 [label="return 'where'; 3563"];
3563 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3564"];
3564 [label="'from' 3565"];
3565 [label="return 'from'; 3566"];
3566 [label="return SyntaxFacts.GetText(this.Kind); 3567"];
3567 [label="FullWidth 3568"];
3568 [label="'from' 3569"];
3569 [label="return 'from'; 3570"];
3570 [label="s_tokensWithElasticTrivia[(int)kind].Value 3571"];
3571 [label="'from' 3572"];
3572 [label="return 'from'; 3573"];
3573 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3574"];
3574 [label="'from' 3575"];
3575 [label="return 'from'; 3576"];
3576 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3577"];
3577 [label="'group' 3578"];
3578 [label="return 'group'; 3579"];
3579 [label="return SyntaxFacts.GetText(this.Kind); 3580"];
3580 [label="FullWidth 3581"];
3581 [label="'group' 3582"];
3582 [label="return 'group'; 3583"];
3583 [label="s_tokensWithElasticTrivia[(int)kind].Value 3584"];
3584 [label="'group' 3585"];
3585 [label="return 'group'; 3586"];
3586 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3587"];
3587 [label="'group' 3588"];
3588 [label="return 'group'; 3589"];
3589 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3590"];
3590 [label="'join' 3591"];
3591 [label="return 'join'; 3592"];
3592 [label="return SyntaxFacts.GetText(this.Kind); 3593"];
3593 [label="FullWidth 3594"];
3594 [label="'join' 3595"];
3595 [label="return 'join'; 3596"];
3596 [label="s_tokensWithElasticTrivia[(int)kind].Value 3597"];
3597 [label="'join' 3598"];
3598 [label="return 'join'; 3599"];
3599 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3600"];
3600 [label="'join' 3601"];
3601 [label="return 'join'; 3602"];
3602 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3603"];
3603 [label="'into' 3604"];
3604 [label="return 'into'; 3605"];
3605 [label="return SyntaxFacts.GetText(this.Kind); 3606"];
3606 [label="FullWidth 3607"];
3607 [label="'into' 3608"];
3608 [label="return 'into'; 3609"];
3609 [label="s_tokensWithElasticTrivia[(int)kind].Value 3610"];
3610 [label="'into' 3611"];
3611 [label="return 'into'; 3612"];
3612 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3613"];
3613 [label="'into' 3614"];
3614 [label="return 'into'; 3615"];
3615 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3616"];
3616 [label="'let' 3617"];
3617 [label="return 'let'; 3618"];
3618 [label="return SyntaxFacts.GetText(this.Kind); 3619"];
3619 [label="FullWidth 3620"];
3620 [label="'let' 3621"];
3621 [label="return 'let'; 3622"];
3622 [label="s_tokensWithElasticTrivia[(int)kind].Value 3623"];
3623 [label="'let' 3624"];
3624 [label="return 'let'; 3625"];
3625 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3626"];
3626 [label="'let' 3627"];
3627 [label="return 'let'; 3628"];
3628 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3629"];
3629 [label="'by' 3630"];
3630 [label="return 'by'; 3631"];
3631 [label="return SyntaxFacts.GetText(this.Kind); 3632"];
3632 [label="FullWidth 3633"];
3633 [label="'by' 3634"];
3634 [label="return 'by'; 3635"];
3635 [label="s_tokensWithElasticTrivia[(int)kind].Value 3636"];
3636 [label="'by' 3637"];
3637 [label="return 'by'; 3638"];
3638 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3639"];
3639 [label="'by' 3640"];
3640 [label="return 'by'; 3641"];
3641 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3642"];
3642 [label="'select' 3643"];
3643 [label="return 'select'; 3644"];
3644 [label="return SyntaxFacts.GetText(this.Kind); 3645"];
3645 [label="FullWidth 3646"];
3646 [label="'select' 3647"];
3647 [label="return 'select'; 3648"];
3648 [label="s_tokensWithElasticTrivia[(int)kind].Value 3649"];
3649 [label="'select' 3650"];
3650 [label="return 'select'; 3651"];
3651 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3652"];
3652 [label="'select' 3653"];
3653 [label="return 'select'; 3654"];
3654 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3655"];
3655 [label="'orderby' 3656"];
3656 [label="return 'orderby'; 3657"];
3657 [label="return SyntaxFacts.GetText(this.Kind); 3658"];
3658 [label="FullWidth 3659"];
3659 [label="'orderby' 3660"];
3660 [label="return 'orderby'; 3661"];
3661 [label="s_tokensWithElasticTrivia[(int)kind].Value 3662"];
3662 [label="'orderby' 3663"];
3663 [label="return 'orderby'; 3664"];
3664 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3665"];
3665 [label="'orderby' 3666"];
3666 [label="return 'orderby'; 3667"];
3667 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3668"];
3668 [label="'on' 3669"];
3669 [label="return 'on'; 3670"];
3670 [label="return SyntaxFacts.GetText(this.Kind); 3671"];
3671 [label="FullWidth 3672"];
3672 [label="'on' 3673"];
3673 [label="return 'on'; 3674"];
3674 [label="s_tokensWithElasticTrivia[(int)kind].Value 3675"];
3675 [label="'on' 3676"];
3676 [label="return 'on'; 3677"];
3677 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3678"];
3678 [label="'on' 3679"];
3679 [label="return 'on'; 3680"];
3680 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3681"];
3681 [label="'equals' 3682"];
3682 [label="return 'equals'; 3683"];
3683 [label="return SyntaxFacts.GetText(this.Kind); 3684"];
3684 [label="FullWidth 3685"];
3685 [label="'equals' 3686"];
3686 [label="return 'equals'; 3687"];
3687 [label="s_tokensWithElasticTrivia[(int)kind].Value 3688"];
3688 [label="'equals' 3689"];
3689 [label="return 'equals'; 3690"];
3690 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3691"];
3691 [label="'equals' 3692"];
3692 [label="return 'equals'; 3693"];
3693 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3694"];
3694 [label="'ascending' 3695"];
3695 [label="return 'ascending'; 3696"];
3696 [label="return SyntaxFacts.GetText(this.Kind); 3697"];
3697 [label="FullWidth 3698"];
3698 [label="'ascending' 3699"];
3699 [label="return 'ascending'; 3700"];
3700 [label="s_tokensWithElasticTrivia[(int)kind].Value 3701"];
3701 [label="'ascending' 3702"];
3702 [label="return 'ascending'; 3703"];
3703 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3704"];
3704 [label="'ascending' 3705"];
3705 [label="return 'ascending'; 3706"];
3706 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3707"];
3707 [label="'descending' 3708"];
3708 [label="return 'descending'; 3709"];
3709 [label="return SyntaxFacts.GetText(this.Kind); 3710"];
3710 [label="FullWidth 3711"];
3711 [label="'descending' 3712"];
3712 [label="return 'descending'; 3713"];
3713 [label="s_tokensWithElasticTrivia[(int)kind].Value 3714"];
3714 [label="'descending' 3715"];
3715 [label="return 'descending'; 3716"];
3716 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3717"];
3717 [label="'descending' 3718"];
3718 [label="return 'descending'; 3719"];
3719 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3720"];
3720 [label="'nameof' 3721"];
3721 [label="return 'nameof'; 3722"];
3722 [label="return SyntaxFacts.GetText(this.Kind); 3723"];
3723 [label="FullWidth 3724"];
3724 [label="'nameof' 3725"];
3725 [label="return 'nameof'; 3726"];
3726 [label="s_tokensWithElasticTrivia[(int)kind].Value 3727"];
3727 [label="'nameof' 3728"];
3728 [label="return 'nameof'; 3729"];
3729 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3730"];
3730 [label="'nameof' 3731"];
3731 [label="return 'nameof'; 3732"];
3732 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3733"];
3733 [label="'async' 3734"];
3734 [label="return 'async'; 3735"];
3735 [label="return SyntaxFacts.GetText(this.Kind); 3736"];
3736 [label="FullWidth 3737"];
3737 [label="'async' 3738"];
3738 [label="return 'async'; 3739"];
3739 [label="s_tokensWithElasticTrivia[(int)kind].Value 3740"];
3740 [label="'async' 3741"];
3741 [label="return 'async'; 3742"];
3742 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3743"];
3743 [label="'async' 3744"];
3744 [label="return 'async'; 3745"];
3745 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3746"];
3746 [label="'await' 3747"];
3747 [label="return 'await'; 3748"];
3748 [label="return SyntaxFacts.GetText(this.Kind); 3749"];
3749 [label="FullWidth 3750"];
3750 [label="'await' 3751"];
3751 [label="return 'await'; 3752"];
3752 [label="s_tokensWithElasticTrivia[(int)kind].Value 3753"];
3753 [label="'await' 3754"];
3754 [label="return 'await'; 3755"];
3755 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3756"];
3756 [label="'await' 3757"];
3757 [label="return 'await'; 3758"];
3758 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3759"];
3759 [label="'when' 3760"];
3760 [label="return 'when'; 3761"];
3761 [label="return SyntaxFacts.GetText(this.Kind); 3762"];
3762 [label="FullWidth 3763"];
3763 [label="'when' 3764"];
3764 [label="return 'when'; 3765"];
3765 [label="s_tokensWithElasticTrivia[(int)kind].Value 3766"];
3766 [label="'when' 3767"];
3767 [label="return 'when'; 3768"];
3768 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3769"];
3769 [label="'when' 3770"];
3770 [label="return 'when'; 3771"];
3771 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3772"];
3772 [label="'or' 3773"];
3773 [label="return 'or'; 3774"];
3774 [label="return SyntaxFacts.GetText(this.Kind); 3775"];
3775 [label="FullWidth 3776"];
3776 [label="'or' 3777"];
3777 [label="return 'or'; 3778"];
3778 [label="s_tokensWithElasticTrivia[(int)kind].Value 3779"];
3779 [label="'or' 3780"];
3780 [label="return 'or'; 3781"];
3781 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3782"];
3782 [label="'or' 3783"];
3783 [label="return 'or'; 3784"];
3784 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3785"];
3785 [label="'and' 3786"];
3786 [label="return 'and'; 3787"];
3787 [label="return SyntaxFacts.GetText(this.Kind); 3788"];
3788 [label="FullWidth 3789"];
3789 [label="'and' 3790"];
3790 [label="return 'and'; 3791"];
3791 [label="s_tokensWithElasticTrivia[(int)kind].Value 3792"];
3792 [label="'and' 3793"];
3793 [label="return 'and'; 3794"];
3794 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3795"];
3795 [label="'and' 3796"];
3796 [label="return 'and'; 3797"];
3797 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3798"];
3798 [label="'not' 3799"];
3799 [label="return 'not'; 3800"];
3800 [label="return SyntaxFacts.GetText(this.Kind); 3801"];
3801 [label="FullWidth 3802"];
3802 [label="'not' 3803"];
3803 [label="return 'not'; 3804"];
3804 [label="s_tokensWithElasticTrivia[(int)kind].Value 3805"];
3805 [label="'not' 3806"];
3806 [label="return 'not'; 3807"];
3807 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3808"];
3808 [label="'not' 3809"];
3809 [label="return 'not'; 3810"];
3810 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3811"];
3811 [label="'data' 3812"];
3812 [label="return 'data'; 3813"];
3813 [label="return SyntaxFacts.GetText(this.Kind); 3814"];
3814 [label="FullWidth 3815"];
3815 [label="'data' 3816"];
3816 [label="return 'data'; 3817"];
3817 [label="s_tokensWithElasticTrivia[(int)kind].Value 3818"];
3818 [label="'data' 3819"];
3819 [label="return 'data'; 3820"];
3820 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3821"];
3821 [label="'data' 3822"];
3822 [label="return 'data'; 3823"];
3823 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3824"];
3824 [label="'with' 3825"];
3825 [label="return 'with'; 3826"];
3826 [label="return SyntaxFacts.GetText(this.Kind); 3827"];
3827 [label="FullWidth 3828"];
3828 [label="'with' 3829"];
3829 [label="return 'with'; 3830"];
3830 [label="s_tokensWithElasticTrivia[(int)kind].Value 3831"];
3831 [label="'with' 3832"];
3832 [label="return 'with'; 3833"];
3833 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3834"];
3834 [label="'with' 3835"];
3835 [label="return 'with'; 3836"];
3836 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3837"];
3837 [label="'init' 3838"];
3838 [label="return 'init'; 3839"];
3839 [label="return SyntaxFacts.GetText(this.Kind); 3840"];
3840 [label="FullWidth 3841"];
3841 [label="'init' 3842"];
3842 [label="return 'init'; 3843"];
3843 [label="s_tokensWithElasticTrivia[(int)kind].Value 3844"];
3844 [label="'init' 3845"];
3845 [label="return 'init'; 3846"];
3846 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3847"];
3847 [label="'init' 3848"];
3848 [label="return 'init'; 3849"];
3849 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3850"];
3850 [label="'record' 3851"];
3851 [label="return 'record'; 3852"];
3852 [label="return SyntaxFacts.GetText(this.Kind); 3853"];
3853 [label="FullWidth 3854"];
3854 [label="'record' 3855"];
3855 [label="return 'record'; 3856"];
3856 [label="s_tokensWithElasticTrivia[(int)kind].Value 3857"];
3857 [label="'record' 3858"];
3858 [label="return 'record'; 3859"];
3859 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3860"];
3860 [label="'record' 3861"];
3861 [label="return 'record'; 3862"];
3862 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3863"];
3863 [label="'managed' 3864"];
3864 [label="return 'managed'; 3865"];
3865 [label="return SyntaxFacts.GetText(this.Kind); 3866"];
3866 [label="FullWidth 3867"];
3867 [label="'managed' 3868"];
3868 [label="return 'managed'; 3869"];
3869 [label="s_tokensWithElasticTrivia[(int)kind].Value 3870"];
3870 [label="'managed' 3871"];
3871 [label="return 'managed'; 3872"];
3872 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3873"];
3873 [label="'managed' 3874"];
3874 [label="return 'managed'; 3875"];
3875 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3876"];
3876 [label="'unmanaged' 3877"];
3877 [label="return 'unmanaged'; 3878"];
3878 [label="return SyntaxFacts.GetText(this.Kind); 3879"];
3879 [label="FullWidth 3880"];
3880 [label="'unmanaged' 3881"];
3881 [label="return 'unmanaged'; 3882"];
3882 [label="s_tokensWithElasticTrivia[(int)kind].Value 3883"];
3883 [label="'unmanaged' 3884"];
3884 [label="return 'unmanaged'; 3885"];
3885 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3886"];
3886 [label="'unmanaged' 3887"];
3887 [label="return 'unmanaged'; 3888"];
3888 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3889"];
3889 [label="'elif' 3890"];
3890 [label="return 'elif'; 3891"];
3891 [label="return SyntaxFacts.GetText(this.Kind); 3892"];
3892 [label="FullWidth 3893"];
3893 [label="'elif' 3894"];
3894 [label="return 'elif'; 3895"];
3895 [label="s_tokensWithElasticTrivia[(int)kind].Value 3896"];
3896 [label="'elif' 3897"];
3897 [label="return 'elif'; 3898"];
3898 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3899"];
3899 [label="'elif' 3900"];
3900 [label="return 'elif'; 3901"];
3901 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3902"];
3902 [label="'endif' 3903"];
3903 [label="return 'endif'; 3904"];
3904 [label="return SyntaxFacts.GetText(this.Kind); 3905"];
3905 [label="FullWidth 3906"];
3906 [label="'endif' 3907"];
3907 [label="return 'endif'; 3908"];
3908 [label="s_tokensWithElasticTrivia[(int)kind].Value 3909"];
3909 [label="'endif' 3910"];
3910 [label="return 'endif'; 3911"];
3911 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3912"];
3912 [label="'endif' 3913"];
3913 [label="return 'endif'; 3914"];
3914 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3915"];
3915 [label="'region' 3916"];
3916 [label="return 'region'; 3917"];
3917 [label="return SyntaxFacts.GetText(this.Kind); 3918"];
3918 [label="FullWidth 3919"];
3919 [label="'region' 3920"];
3920 [label="return 'region'; 3921"];
3921 [label="s_tokensWithElasticTrivia[(int)kind].Value 3922"];
3922 [label="'region' 3923"];
3923 [label="return 'region'; 3924"];
3924 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3925"];
3925 [label="'region' 3926"];
3926 [label="return 'region'; 3927"];
3927 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3928"];
3928 [label="'endregion' 3929"];
3929 [label="return 'endregion'; 3930"];
3930 [label="return SyntaxFacts.GetText(this.Kind); 3931"];
3931 [label="FullWidth 3932"];
3932 [label="'endregion' 3933"];
3933 [label="return 'endregion'; 3934"];
3934 [label="s_tokensWithElasticTrivia[(int)kind].Value 3935"];
3935 [label="'endregion' 3936"];
3936 [label="return 'endregion'; 3937"];
3937 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3938"];
3938 [label="'endregion' 3939"];
3939 [label="return 'endregion'; 3940"];
3940 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3941"];
3941 [label="'define' 3942"];
3942 [label="return 'define'; 3943"];
3943 [label="return SyntaxFacts.GetText(this.Kind); 3944"];
3944 [label="FullWidth 3945"];
3945 [label="'define' 3946"];
3946 [label="return 'define'; 3947"];
3947 [label="s_tokensWithElasticTrivia[(int)kind].Value 3948"];
3948 [label="'define' 3949"];
3949 [label="return 'define'; 3950"];
3950 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3951"];
3951 [label="'define' 3952"];
3952 [label="return 'define'; 3953"];
3953 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3954"];
3954 [label="'undef' 3955"];
3955 [label="return 'undef'; 3956"];
3956 [label="return SyntaxFacts.GetText(this.Kind); 3957"];
3957 [label="FullWidth 3958"];
3958 [label="'undef' 3959"];
3959 [label="return 'undef'; 3960"];
3960 [label="s_tokensWithElasticTrivia[(int)kind].Value 3961"];
3961 [label="'undef' 3962"];
3962 [label="return 'undef'; 3963"];
3963 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3964"];
3964 [label="'undef' 3965"];
3965 [label="return 'undef'; 3966"];
3966 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3967"];
3967 [label="'warning' 3968"];
3968 [label="return 'warning'; 3969"];
3969 [label="return SyntaxFacts.GetText(this.Kind); 3970"];
3970 [label="FullWidth 3971"];
3971 [label="'warning' 3972"];
3972 [label="return 'warning'; 3973"];
3973 [label="s_tokensWithElasticTrivia[(int)kind].Value 3974"];
3974 [label="'warning' 3975"];
3975 [label="return 'warning'; 3976"];
3976 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3977"];
3977 [label="'warning' 3978"];
3978 [label="return 'warning'; 3979"];
3979 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3980"];
3980 [label="'error' 3981"];
3981 [label="return 'error'; 3982"];
3982 [label="return SyntaxFacts.GetText(this.Kind); 3983"];
3983 [label="FullWidth 3984"];
3984 [label="'error' 3985"];
3985 [label="return 'error'; 3986"];
3986 [label="s_tokensWithElasticTrivia[(int)kind].Value 3987"];
3987 [label="'error' 3988"];
3988 [label="return 'error'; 3989"];
3989 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 3990"];
3990 [label="'error' 3991"];
3991 [label="return 'error'; 3992"];
3992 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 3993"];
3993 [label="'line' 3994"];
3994 [label="return 'line'; 3995"];
3995 [label="return SyntaxFacts.GetText(this.Kind); 3996"];
3996 [label="FullWidth 3997"];
3997 [label="'line' 3998"];
3998 [label="return 'line'; 3999"];
3999 [label="s_tokensWithElasticTrivia[(int)kind].Value 4000"];
4000 [label="'line' 4001"];
4001 [label="return 'line'; 4002"];
4002 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4003"];
4003 [label="'line' 4004"];
4004 [label="return 'line'; 4005"];
4005 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4006"];
4006 [label="'pragma' 4007"];
4007 [label="return 'pragma'; 4008"];
4008 [label="return SyntaxFacts.GetText(this.Kind); 4009"];
4009 [label="FullWidth 4010"];
4010 [label="'pragma' 4011"];
4011 [label="return 'pragma'; 4012"];
4012 [label="s_tokensWithElasticTrivia[(int)kind].Value 4013"];
4013 [label="'pragma' 4014"];
4014 [label="return 'pragma'; 4015"];
4015 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4016"];
4016 [label="'pragma' 4017"];
4017 [label="return 'pragma'; 4018"];
4018 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4019"];
4019 [label="'hidden' 4020"];
4020 [label="return 'hidden'; 4021"];
4021 [label="return SyntaxFacts.GetText(this.Kind); 4022"];
4022 [label="FullWidth 4023"];
4023 [label="'hidden' 4024"];
4024 [label="return 'hidden'; 4025"];
4025 [label="s_tokensWithElasticTrivia[(int)kind].Value 4026"];
4026 [label="'hidden' 4027"];
4027 [label="return 'hidden'; 4028"];
4028 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4029"];
4029 [label="'hidden' 4030"];
4030 [label="return 'hidden'; 4031"];
4031 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4032"];
4032 [label="'checksum' 4033"];
4033 [label="return 'checksum'; 4034"];
4034 [label="return SyntaxFacts.GetText(this.Kind); 4035"];
4035 [label="FullWidth 4036"];
4036 [label="'checksum' 4037"];
4037 [label="return 'checksum'; 4038"];
4038 [label="s_tokensWithElasticTrivia[(int)kind].Value 4039"];
4039 [label="'checksum' 4040"];
4040 [label="return 'checksum'; 4041"];
4041 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4042"];
4042 [label="'checksum' 4043"];
4043 [label="return 'checksum'; 4044"];
4044 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4045"];
4045 [label="'disable' 4046"];
4046 [label="return 'disable'; 4047"];
4047 [label="return SyntaxFacts.GetText(this.Kind); 4048"];
4048 [label="FullWidth 4049"];
4049 [label="'disable' 4050"];
4050 [label="return 'disable'; 4051"];
4051 [label="s_tokensWithElasticTrivia[(int)kind].Value 4052"];
4052 [label="'disable' 4053"];
4053 [label="return 'disable'; 4054"];
4054 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4055"];
4055 [label="'disable' 4056"];
4056 [label="return 'disable'; 4057"];
4057 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4058"];
4058 [label="'restore' 4059"];
4059 [label="return 'restore'; 4060"];
4060 [label="return SyntaxFacts.GetText(this.Kind); 4061"];
4061 [label="FullWidth 4062"];
4062 [label="'restore' 4063"];
4063 [label="return 'restore'; 4064"];
4064 [label="s_tokensWithElasticTrivia[(int)kind].Value 4065"];
4065 [label="'restore' 4066"];
4066 [label="return 'restore'; 4067"];
4067 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4068"];
4068 [label="'restore' 4069"];
4069 [label="return 'restore'; 4070"];
4070 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4071"];
4071 [label="'r' 4072"];
4072 [label="return 'r'; 4073"];
4073 [label="return SyntaxFacts.GetText(this.Kind); 4074"];
4074 [label="FullWidth 4075"];
4075 [label="'r' 4076"];
4076 [label="return 'r'; 4077"];
4077 [label="s_tokensWithElasticTrivia[(int)kind].Value 4078"];
4078 [label="'r' 4079"];
4079 [label="return 'r'; 4080"];
4080 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4081"];
4081 [label="'r' 4082"];
4082 [label="return 'r'; 4083"];
4083 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4084"];
4084 [label="'$\\'' 4085"];
4085 [label="return '$\\''; 4086"];
4086 [label="return SyntaxFacts.GetText(this.Kind); 4087"];
4087 [label="FullWidth 4088"];
4088 [label="'$\\'' 4089"];
4089 [label="return '$\\''; 4090"];
4090 [label="s_tokensWithElasticTrivia[(int)kind].Value 4091"];
4091 [label="'$\\'' 4092"];
4092 [label="return '$\\''; 4093"];
4093 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4094"];
4094 [label="'$\\'' 4095"];
4095 [label="return '$\\''; 4096"];
4096 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4097"];
4097 [label="'\\'' 4098"];
4098 [label="return '\\''; 4099"];
4099 [label="return SyntaxFacts.GetText(this.Kind); 4100"];
4100 [label="FullWidth 4101"];
4101 [label="'\\'' 4102"];
4102 [label="return '\\''; 4103"];
4103 [label="s_tokensWithElasticTrivia[(int)kind].Value 4104"];
4104 [label="'\\'' 4105"];
4105 [label="return '\\''; 4106"];
4106 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4107"];
4107 [label="'\\'' 4108"];
4108 [label="return '\\''; 4109"];
4109 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4110"];
4110 [label="'$@\\'' 4111"];
4111 [label="return '$@\\''; 4112"];
4112 [label="return SyntaxFacts.GetText(this.Kind); 4113"];
4113 [label="FullWidth 4114"];
4114 [label="'$@\\'' 4115"];
4115 [label="return '$@\\''; 4116"];
4116 [label="s_tokensWithElasticTrivia[(int)kind].Value 4117"];
4117 [label="'$@\\'' 4118"];
4118 [label="return '$@\\''; 4119"];
4119 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4120"];
4120 [label="'$@\\'' 4121"];
4121 [label="return '$@\\''; 4122"];
4122 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4123"];
4123 [label="'load' 4124"];
4124 [label="return 'load'; 4125"];
4125 [label="return SyntaxFacts.GetText(this.Kind); 4126"];
4126 [label="FullWidth 4127"];
4127 [label="'load' 4128"];
4128 [label="return 'load'; 4129"];
4129 [label="s_tokensWithElasticTrivia[(int)kind].Value 4130"];
4130 [label="'load' 4131"];
4131 [label="return 'load'; 4132"];
4132 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4133"];
4133 [label="'load' 4134"];
4134 [label="return 'load'; 4135"];
4135 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4136"];
4136 [label="'nullable' 4137"];
4137 [label="return 'nullable'; 4138"];
4138 [label="return SyntaxFacts.GetText(this.Kind); 4139"];
4139 [label="FullWidth 4140"];
4140 [label="'nullable' 4141"];
4141 [label="return 'nullable'; 4142"];
4142 [label="s_tokensWithElasticTrivia[(int)kind].Value 4143"];
4143 [label="'nullable' 4144"];
4144 [label="return 'nullable'; 4145"];
4145 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4146"];
4146 [label="'nullable' 4147"];
4147 [label="return 'nullable'; 4148"];
4148 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4149"];
4149 [label="'enable' 4150"];
4150 [label="return 'enable'; 4151"];
4151 [label="return SyntaxFacts.GetText(this.Kind); 4152"];
4152 [label="FullWidth 4153"];
4153 [label="'enable' 4154"];
4154 [label="return 'enable'; 4155"];
4155 [label="s_tokensWithElasticTrivia[(int)kind].Value 4156"];
4156 [label="'enable' 4157"];
4157 [label="return 'enable'; 4158"];
4158 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4159"];
4159 [label="'enable' 4160"];
4160 [label="return 'enable'; 4161"];
4161 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4162"];
4162 [label="'warnings' 4163"];
4163 [label="return 'warnings'; 4164"];
4164 [label="return SyntaxFacts.GetText(this.Kind); 4165"];
4165 [label="FullWidth 4166"];
4166 [label="'warnings' 4167"];
4167 [label="return 'warnings'; 4168"];
4168 [label="s_tokensWithElasticTrivia[(int)kind].Value 4169"];
4169 [label="'warnings' 4170"];
4170 [label="return 'warnings'; 4171"];
4171 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4172"];
4172 [label="'warnings' 4173"];
4173 [label="return 'warnings'; 4174"];
4174 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4175"];
4175 [label="'annotations' 4176"];
4176 [label="return 'annotations'; 4177"];
4177 [label="return SyntaxFacts.GetText(this.Kind); 4178"];
4178 [label="FullWidth 4179"];
4179 [label="'annotations' 4180"];
4180 [label="return 'annotations'; 4181"];
4181 [label="s_tokensWithElasticTrivia[(int)kind].Value 4182"];
4182 [label="'annotations' 4183"];
4183 [label="return 'annotations'; 4184"];
4184 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4185"];
4185 [label="'annotations' 4186"];
4186 [label="return 'annotations'; 4187"];
4187 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4188"];
4188 [label="'var' 4189"];
4189 [label="return 'var'; 4190"];
4190 [label="return SyntaxFacts.GetText(this.Kind); 4191"];
4191 [label="FullWidth 4192"];
4192 [label="'var' 4193"];
4193 [label="return 'var'; 4194"];
4194 [label="s_tokensWithElasticTrivia[(int)kind].Value 4195"];
4195 [label="'var' 4196"];
4196 [label="return 'var'; 4197"];
4197 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4198"];
4198 [label="'var' 4199"];
4199 [label="return 'var'; 4200"];
4200 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4201"];
4201 [label="'_' 4202"];
4202 [label="return '_'; 4203"];
4203 [label="return SyntaxFacts.GetText(this.Kind); 4204"];
4204 [label="FullWidth 4205"];
4205 [label="'_' 4206"];
4206 [label="return '_'; 4207"];
4207 [label="s_tokensWithElasticTrivia[(int)kind].Value 4208"];
4208 [label="'_' 4209"];
4209 [label="return '_'; 4210"];
4210 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 4211"];
4211 [label="'_' 4212"];
4212 [label="return '_'; 4213"];
4213 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 4214"];
4214 [label="contextualKind 4215"];
4215 [label="leading 4216"];
4216 [label="text 4217"];
4217 [label="valueText 4218"];
4218 [label="trailing 4219"];
4219 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 4220"];
4220 [label="param Identifier(SyntaxKind contextualKind) 4221"];
4221 [label="param Identifier(GreenNode leading) 4222"];
4222 [label="param Identifier(string text) 4223"];
4223 [label="param Identifier(string valueText) 4224"];
4224 [label="param Identifier(GreenNode trailing) 4225"];
4225 [label="contextualKind == SyntaxKind.IdentifierToken 4226"];
4226 [label="valueText == text 4227"];
4227 [label="contextualKind == SyntaxKind.IdentifierToken && valueText == text 4228"];
4228 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 4229"];
4229 [label="leading 4230"];
4230 [label="text 4231"];
4231 [label="trailing 4232"];
4232 [label="Identifier(leading, text, trailing) 4233"];
4233 [label="param Identifier(GreenNode leading) 4234"];
4234 [label="param Identifier(string text) 4235"];
4235 [label="param Identifier(GreenNode trailing) 4236"];
4236 [label="null 4237"];
4237 [label="leading == null 4238"];
4238 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 4239"];
4239 [label="null 4240"];
4240 [label="trailing == null 4241"];
4241 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 4242"];
4242 [label="text 4243"];
4243 [label="Identifier(text) 4244"];
4244 [label="param Identifier(string text) 4245"];
4245 [label="text 4246"];
4246 [label="new SyntaxIdentifier(text) 4247"];
4247 [label="new SyntaxIdentifier(text) 4248"];
4248 [label="param SyntaxToken(SyntaxKind kind) 4249"];
4249 [label="param SyntaxToken(int fullWidth) 4250"];
4250 [label="param SyntaxToken(this) 4251"];
4251 [label="kind 4252"];
4252 [label="fullWidth 4253"];
4253 [label="param SyntaxToken(this) 4254"];
4254 [label="param CSharpSyntaxNode(SyntaxKind kind) 4255"];
4255 [label="param CSharpSyntaxNode(int fullWidth) 4256"];
4256 [label="param CSharpSyntaxNode(this) 4257"];
4257 [label="kind 4258"];
4258 [label="fullWidth 4259"];
4259 [label="param CSharpSyntaxNode(this) 4260"];
4260 [label="param CSharpSyntaxNode(this) 4261"];
4261 [label="this 4262"];
4262 [label="GreenStats.NoteGreen(this) 4263"];
4263 [label="this.flags |= NodeFlags.IsNotMissing 4264"];
4264 [label="this.flags 4265"];
4265 [label="return new SyntaxIdentifier(text); 4266"];
4266 [label="return Identifier(text); 4267"];
4267 [label="return Identifier(leading, text, trailing); 4268"];
4268 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 4269"];
4269 [label="token 4270"];
4270 [label="null 4271"];
4271 [label="errors != null 4272"];
4272 [label="errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment) 4273"];
4273 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 4274"];
4274 [label="return token; 4275"];
4275 [label="return Create(ref tokenInfo, leading, trailing, errors); 4276"];
4276 [label="this.QuickScanSyntaxToken() ?? this.LexSyntaxToken() 4277"];
4277 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 4278"];
4278 [label="token = lexer.Lex(mode) 4279"];
4279 [label="token 4280"];
4280 [label="this.AddLexedToken(token) 4281"];
4281 [label="param AddLexedToken(SyntaxToken token) 4282"];
4282 [label="param AddLexedToken(this) 4283"];
4283 [label="null 4284"];
4284 [label="token != null 4285"];
4285 [label="Debug.Assert(token != null) 4286"];
4286 [label="_tokenCount >= _lexedTokens.Length 4287"];
4287 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 4288"];
4288 [label="_lexedTokens[_tokenCount] 4289"];
4289 [label="_lexedTokens[_tokenCount].Value 4290"];
4290 [label="_tokenCount 4291"];
4291 [label="token.Kind 4292"];
4292 [label="get { return (SyntaxKind)this.RawKind; } 4293"];
4293 [label="return (SyntaxKind)this.RawKind; 4294"];
4294 [label="token.Kind == SyntaxKind.EndOfFileToken 4295"];
4295 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 4296"];
4296 [label="i 4297"];
4297 [label="mode 4298"];
4298 [label="lexer.Lex(mode) 4299"];
4299 [label="param Lex(LexerMode mode) 4300"];
4300 [label="param Lex(this) 4301"];
4301 [label="TokensLexed 4302"];
4302 [label="_mode 4303"];
4303 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 4304"];
4304 [label="get\n            {\n                return _lexemeStart;\n            } 4305"];
4305 [label="return _lexemeStart; 4306"];
4306 [label="param LookupToken(char[] textBuffer) 4307"];
4307 [label="param LookupToken(int keyStart) 4308"];
4308 [label="param LookupToken(int keyLength) 4309"];
4309 [label="param LookupToken(int hashCode) 4310"];
4310 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 4311"];
4311 [label="param LookupToken(this) 4312"];
4312 [label="textBuffer 4313"];
4313 [label="keyStart 4314"];
4314 [label="keyLength 4315"];
4315 [label="hashCode 4316"];
4316 [label="_tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode) 4317"];
4317 [label="value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode) 4318"];
4318 [label="null 4319"];
4319 [label="value == null 4320"];
4320 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 4321"];
4321 [label="createTokenFunction() 4322"];
4322 [label="createTokenFunction() 4323"];
4323 [label="param CreateQuickToken(this) 4324"];
4324 [label="TextWindow.Width 4325"];
4325 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 4326"];
4326 [label="_offset - _lexemeStart 4327"];
4327 [label="return _offset - _lexemeStart; 4328"];
4328 [label="quickWidth = TextWindow.Width 4329"];
4329 [label="TextWindow.LexemeStartPosition 4330"];
4330 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 4331"];
4331 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 4332"];
4332 [label="param Reset(int position) 4333"];
4333 [label="param Reset(this) 4334"];
4334 [label="this.LexSyntaxToken() 4335"];
4335 [label="param LexSyntaxToken(this) 4336"];
4336 [label="_leadingTriviaCache.Clear() 4337"];
4337 [label="TextWindow.Position 4338"];
4338 [label="get\n            {\n                return _basis + _offset;\n            } 4339"];
4339 [label="0 4340"];
4340 [label="TextWindow.Position > 0 4341"];
4341 [label="afterFirstToken: TextWindow.Position > 0 4342"];
4342 [label="false 4343"];
4343 [label="isTrailing: false 4344"];
4344 [label="param LexSyntaxTrivia(bool afterFirstToken) 4345"];
4345 [label="param LexSyntaxTrivia(bool isTrailing) 4346"];
4346 [label="onlyWhitespaceOnLine = !isTrailing 4347"];
4347 [label="_offset >= _characterWindowCount 4348"];
4348 [label="_offset >= _characterWindowCount\n                && !MoreChars() 4349"];
4349 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 4350"];
4350 [label="ch = TextWindow.PeekChar() 4351"];
4351 [label="' ' 4352"];
4352 [label="ch == ' ' 4353"];
4353 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4354"];
4354 [label="127 4355"];
4355 [label="ch > 127 4356"];
4356 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4357"];
4357 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 4358"];
4358 [label="return; 4359"];
4359 [label="param AdvanceChar(this) 4360"];
4360 [label="_offset 4361"];
4361 [label="leading 4362"];
4362 [label="GetFullWidth(leading) 4363"];
4363 [label="param GetFullWidth(SyntaxListBuilder builder) 4364"];
4364 [label="0 4365"];
4365 [label="width = 0 4366"];
4366 [label="null 4367"];
4367 [label="builder != null 4368"];
4368 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 4369"];
4369 [label="0 4370"];
4370 [label="i = 0 4371"];
4371 [label="i < builder.Count 4372"];
4372 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 4373"];
4373 [label="return width; 4374"];
4374 [label="this.GetErrors(GetFullWidth(leading)) 4375"];
4375 [label="param GetErrors(int leadingTriviaWidth) 4376"];
4376 [label="param GetErrors(this) 4377"];
4377 [label="null 4378"];
4378 [label="_errors != null 4379"];
4379 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 4380"];
4380 [label="null 4381"];
4381 [label="return null; 4382"];
4382 [label="errors = this.GetErrors(GetFullWidth(leading)) 4383"];
4383 [label="ref tokenInfo 4384"];
4384 [label="errors 4385"];
4385 [label="param Create(ref TokenInfo info) 4386"];
4386 [label="param Create(SyntaxDiagnosticInfo[] errors) 4387"];
4387 [label="param Create(this) 4388"];
4388 [label="info.Kind != SyntaxKind.IdentifierToken 4389"];
4389 [label="info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null 4390"];
4390 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null) 4391"];
4391 [label="leadingNode = leading?.ToListNode() 4392"];
4392 [label="trailingNode = trailing?.ToListNode() 4393"];
4393 [label="token 4394"];
4394 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 4395"];
4395 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 4396"];
4396 [label="info.Kind 4397"];
4397 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 4398"];
4398 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 4399"];
4399 [label="kind >= SyntaxKind.TildeToken 4400"];
4400 [label="kind <= SyntaxKind.EndOfFileToken 4401"];
4401 [label="kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken 4402"];
4402 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 4403"];
4403 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)) 4404"];
4404 [label="leadingNode 4405"];
4405 [label="info.Kind 4406"];
4406 [label="trailingNode 4407"];
4407 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 4408"];
4408 [label="param Token(GreenNode leading) 4409"];
4409 [label="param Token(SyntaxKind kind) 4410"];
4410 [label="param Token(GreenNode trailing) 4411"];
4411 [label="kind 4412"];
4412 [label="leading 4413"];
4413 [label="trailing 4414"];
4414 [label="SyntaxToken.Create(kind, leading, trailing) 4415"];
4415 [label="param Create(SyntaxKind kind) 4416"];
4416 [label="param Create(GreenNode leading) 4417"];
4417 [label="param Create(GreenNode trailing) 4418"];
4418 [label="kind > LastTokenWithWellKnownText 4419"];
4419 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 4420"];
4420 [label="null 4421"];
4421 [label="leading == null 4422"];
4422 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 4423"];
4423 [label="null 4424"];
4424 [label="trailing == null 4425"];
4425 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 4426"];
4426 [label="s_tokensWithNoTrivia[(int)kind] 4427"];
4427 [label="return s_tokensWithNoTrivia[(int)kind].Value; 4428"];
4428 [label="return SyntaxToken.Create(kind, leading, trailing); 4429"];
4429 [label="token 4430"];
4430 [label="null 4431"];
4431 [label="errors != null 4432"];
4432 [label="errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment) 4433"];
4433 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 4434"];
4434 [label="return token; 4435"];
4435 [label="return Create(ref tokenInfo, leading, trailing, errors); 4436"];
4436 [label="token = this.LexSyntaxToken() 4437"];
4437 [label="quickWidth == token.FullWidth 4438"];
4438 [label="Debug.Assert(quickWidth == token.FullWidth) 4439"];
4439 [label="return token; 4440"];
4440 [label="value 4441"];
4441 [label="textBuffer 4442"];
4442 [label="keyStart 4443"];
4443 [label="keyLength 4444"];
4444 [label="hashCode 4445"];
4445 [label="value 4446"];
4446 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value) 4447"];
4447 [label="return value; 4448"];
4448 [label="this.QuickScanSyntaxToken() 4449"];
4449 [label="this.QuickScanSyntaxToken() ?? this.LexSyntaxToken() 4450"];
4450 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 4451"];
4451 [label="token = lexer.Lex(mode) 4452"];
4452 [label="token 4453"];
4453 [label="this.AddLexedToken(token) 4454"];
4454 [label="param AddLexedToken(SyntaxToken token) 4455"];
4455 [label="param AddLexedToken(this) 4456"];
4456 [label="null 4457"];
4457 [label="token != null 4458"];
4458 [label="Debug.Assert(token != null) 4459"];
4459 [label="_tokenCount >= _lexedTokens.Length 4460"];
4460 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 4461"];
4461 [label="_lexedTokens[_tokenCount] 4462"];
4462 [label="_lexedTokens[_tokenCount].Value 4463"];
4463 [label="_tokenCount 4464"];
4464 [label="token.Kind 4465"];
4465 [label="get { return (SyntaxKind)this.RawKind; } 4466"];
4466 [label="return (SyntaxKind)this.RawKind; 4467"];
4467 [label="token.Kind == SyntaxKind.EndOfFileToken 4468"];
4468 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 4469"];
4469 [label="TextWindow.Width 4470"];
4470 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 4471"];
4471 [label="_offset - _lexemeStart 4472"];
4472 [label="return _offset - _lexemeStart; 4473"];
4473 [label="quickWidth = TextWindow.Width 4474"];
4474 [label="TextWindow.Position 4475"];
4475 [label="0 4476"];
4476 [label="TextWindow.Position > 0 4477"];
4477 [label="afterFirstToken: TextWindow.Position > 0 4478"];
4478 [label="false 4479"];
4479 [label="isTrailing: false 4480"];
4480 [label="param LexSyntaxTrivia(bool afterFirstToken) 4481"];
4481 [label="param LexSyntaxTrivia(bool isTrailing) 4482"];
4482 [label="onlyWhitespaceOnLine = !isTrailing 4483"];
4483 [label="_offset >= _characterWindowCount 4484"];
4484 [label="_offset >= _characterWindowCount\n                && !MoreChars() 4485"];
4485 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 4486"];
4486 [label="ch = TextWindow.PeekChar() 4487"];
4487 [label="' ' 4488"];
4488 [label="ch == ' ' 4489"];
4489 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4490"];
4490 [label="127 4491"];
4491 [label="ch > 127 4492"];
4492 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4493"];
4493 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 4494"];
4494 [label="return; 4495"];
4495 [label="_offset >= _characterWindowCount 4496"];
4496 [label="_offset >= _characterWindowCount\n                && !MoreChars() 4497"];
4497 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 4498"];
4498 [label="leading 4499"];
4499 [label="GetFullWidth(leading) 4500"];
4500 [label="param GetFullWidth(SyntaxListBuilder builder) 4501"];
4501 [label="0 4502"];
4502 [label="width = 0 4503"];
4503 [label="null 4504"];
4504 [label="builder != null 4505"];
4505 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 4506"];
4506 [label="0 4507"];
4507 [label="i = 0 4508"];
4508 [label="i < builder.Count 4509"];
4509 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 4510"];
4510 [label="return width; 4511"];
4511 [label="this.GetErrors(GetFullWidth(leading)) 4512"];
4512 [label="param GetErrors(int leadingTriviaWidth) 4513"];
4513 [label="param GetErrors(this) 4514"];
4514 [label="null 4515"];
4515 [label="_errors != null 4516"];
4516 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 4517"];
4517 [label="null 4518"];
4518 [label="return null; 4519"];
4519 [label="errors = this.GetErrors(GetFullWidth(leading)) 4520"];
4520 [label="errors 4521"];
4521 [label="param Create(SyntaxDiagnosticInfo[] errors) 4522"];
4522 [label="param Create(this) 4523"];
4523 [label="info.Kind != SyntaxKind.IdentifierToken 4524"];
4524 [label="info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null 4525"];
4525 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null) 4526"];
4526 [label="token 4527"];
4527 [label="info.Kind 4528"];
4528 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 4529"];
4529 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 4530"];
4530 [label="kind >= SyntaxKind.TildeToken 4531"];
4531 [label="kind <= SyntaxKind.EndOfFileToken 4532"];
4532 [label="kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken 4533"];
4533 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 4534"];
4534 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)) 4535"];
4535 [label="kind > LastTokenWithWellKnownText 4536"];
4536 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 4537"];
4537 [label="null 4538"];
4538 [label="errors != null 4539"];
4539 [label="errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment) 4540"];
4540 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 4541"];
4541 [label="quickWidth == token.FullWidth 4542"];
4542 [label="Debug.Assert(quickWidth == token.FullWidth) 4543"];
4543 [label="this.QuickScanSyntaxToken() ?? this.LexSyntaxToken() 4544"];
4544 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 4545"];
4545 [label="token = lexer.Lex(mode) 4546"];
4546 [label="token 4547"];
4547 [label="param AddLexedToken(SyntaxToken token) 4548"];
4548 [label="token != null 4549"];
4549 [label="Debug.Assert(token != null) 4550"];
4550 [label="_tokenCount >= _lexedTokens.Length 4551"];
4551 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 4552"];
4552 [label="_lexedTokens[_tokenCount] 4553"];
4553 [label="_lexedTokens[_tokenCount].Value 4554"];
4554 [label="get { return (SyntaxKind)this.RawKind; } 4555"];
4555 [label="return (SyntaxKind)this.RawKind; 4556"];
4556 [label="token.Kind == SyntaxKind.EndOfFileToken 4557"];
4557 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 4558"];
4558 [label="0 4559"];
4559 [label="TextWindow.Position > 0 4560"];
4560 [label="afterFirstToken: TextWindow.Position > 0 4561"];
4561 [label="false 4562"];
4562 [label="isTrailing: false 4563"];
4563 [label="param LexSyntaxTrivia(bool afterFirstToken) 4564"];
4564 [label="param LexSyntaxTrivia(bool isTrailing) 4565"];
4565 [label="onlyWhitespaceOnLine = !isTrailing 4566"];
4566 [label="ch = TextWindow.PeekChar() 4567"];
4567 [label="' ' 4568"];
4568 [label="ch == ' ' 4569"];
4569 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4570"];
4570 [label="127 4571"];
4571 [label="ch > 127 4572"];
4572 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4573"];
4573 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 4574"];
4574 [label="return; 4575"];
4575 [label="leading 4576"];
4576 [label="GetFullWidth(leading) 4577"];
4577 [label="param GetFullWidth(SyntaxListBuilder builder) 4578"];
4578 [label="0 4579"];
4579 [label="width = 0 4580"];
4580 [label="null 4581"];
4581 [label="builder != null 4582"];
4582 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 4583"];
4583 [label="0 4584"];
4584 [label="i = 0 4585"];
4585 [label="i < builder.Count 4586"];
4586 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 4587"];
4587 [label="return width; 4588"];
4588 [label="this.GetErrors(GetFullWidth(leading)) 4589"];
4589 [label="param GetErrors(int leadingTriviaWidth) 4590"];
4590 [label="param GetErrors(this) 4591"];
4591 [label="null 4592"];
4592 [label="_errors != null 4593"];
4593 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 4594"];
4594 [label="null 4595"];
4595 [label="return null; 4596"];
4596 [label="errors = this.GetErrors(GetFullWidth(leading)) 4597"];
4597 [label="errors 4598"];
4598 [label="param Create(SyntaxDiagnosticInfo[] errors) 4599"];
4599 [label="param Create(this) 4600"];
4600 [label="info.Kind != SyntaxKind.IdentifierToken 4601"];
4601 [label="info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null 4602"];
4602 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null) 4603"];
4603 [label="token 4604"];
4604 [label="null 4605"];
4605 [label="errors != null 4606"];
4606 [label="errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment) 4607"];
4607 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 4608"];
4608 [label="this.QuickScanSyntaxToken() ?? this.LexSyntaxToken() 4609"];
4609 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 4610"];
4610 [label="token = lexer.Lex(mode) 4611"];
4611 [label="token 4612"];
4612 [label="param AddLexedToken(SyntaxToken token) 4613"];
4613 [label="token != null 4614"];
4614 [label="Debug.Assert(token != null) 4615"];
4615 [label="_lexedTokens[_tokenCount].Value 4616"];
4616 [label="get { return (SyntaxKind)this.RawKind; } 4617"];
4617 [label="return (SyntaxKind)this.RawKind; 4618"];
4618 [label="token.Kind == SyntaxKind.EndOfFileToken 4619"];
4619 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 4620"];
4620 [label="this.Position 4621"];
4621 [label="this.Position >= _textEnd 4622"];
4622 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 4623"];
4623 [label="false 4624"];
4624 [label="return false; 4625"];
4625 [label="_offset >= _characterWindowCount\n                && !MoreChars() 4626"];
4626 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 4627"];
4627 [label="return InvalidCharacter; 4628"];
4628 [label="ch = TextWindow.PeekChar() 4629"];
4629 [label="ch == ' ' 4630"];
4630 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4631"];
4631 [label="127 4632"];
4632 [label="ch > 127 4633"];
4633 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 4634"];
4634 [label="ch 4635"];
4635 [label="SyntaxFacts.IsWhitespace(ch) 4636"];
4636 [label="param IsWhitespace(char ch) 4637"];
4637 [label="' ' 4638"];
4638 [label="ch == ' ' 4639"];
4639 [label="'\\t' 4640"];
4640 [label="ch == '\\t' 4641"];
4641 [label="ch == ' '\n                || ch == '\\t' 4642"];
4642 [label="'\\v' 4643"];
4643 [label="ch == '\\v' 4644"];
4644 [label="ch == ' '\n                || ch == '\\t'\n                || ch == '\\v' 4645"];
4645 [label="'\\f' 4646"];
4646 [label="ch == '\\f' 4647"];
4647 [label="ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f' 4648"];
4648 [label="'\\u00A0' 4649"];
4649 [label="ch == '\\u00A0' 4650"];
4650 [label="ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' 4651"];
4651 [label="'\\uFEFF' 4652"];
4652 [label="ch == '\\uFEFF' 4653"];
4653 [label="ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF' 4654"];
4654 [label="'\\u001A' 4655"];
4655 [label="ch == '\\u001A' 4656"];
4656 [label="ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A' 4657"];
4657 [label="255 4658"];
4658 [label="ch > 255 4659"];
4659 [label="ch 4660"];
4660 [label="CharUnicodeInfo.GetUnicodeCategory(ch) 4661"];
4661 [label="CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator 4662"];
4662 [label="ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator 4663"];
4663 [label="ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator) 4664"];
4664 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 4665"];
4665 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 4666"];
4666 [label="ch 4667"];
4667 [label="SyntaxFacts.IsNewLine(ch) 4668"];
4668 [label="param IsNewLine(char ch) 4669"];
4669 [label="'\\r' 4670"];
4670 [label="ch == '\\r' 4671"];
4671 [label="'\\n' 4672"];
4672 [label="ch == '\\n' 4673"];
4673 [label="ch == '\\r'\n                || ch == '\\n' 4674"];
4674 [label="'\\u0085' 4675"];
4675 [label="ch == '\\u0085' 4676"];
4676 [label="ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085' 4677"];
4677 [label="'\\u2028' 4678"];
4678 [label="ch == '\\u2028' 4679"];
4679 [label="ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028' 4680"];
4680 [label="'\\u2029' 4681"];
4681 [label="ch == '\\u2029' 4682"];
4682 [label="ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029' 4683"];
4683 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 4684"];
4684 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 4685"];
4685 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 4686"];
4686 [label="return; 4687"];
4687 [label="_offset >= _characterWindowCount 4688"];
4688 [label="this.Position >= _textEnd 4689"];
4689 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 4690"];
4690 [label="false 4691"];
4691 [label="return false; 4692"];
4692 [label="_offset >= _characterWindowCount\n                && !MoreChars() 4693"];
4693 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 4694"];
4694 [label="return InvalidCharacter; 4695"];
4695 [label="param IsReallyAtEnd(this) 4696"];
4696 [label="_offset >= _characterWindowCount 4697"];
4697 [label="Position 4698"];
4698 [label="get\n            {\n                return _basis + _offset;\n            } 4699"];
4699 [label="_basis + _offset 4700"];
4700 [label="Position >= _textEnd 4701"];
4701 [label="_offset >= _characterWindowCount && Position >= _textEnd 4702"];
4702 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 4703"];
4703 [label="ConsList<Directive>.Empty 4704"];
4704 [label="new DirectiveStack(ConsList<Directive>.Empty) 4705"];
4705 [label="param DirectiveStack(ConsList<Directive> directives) 4706"];
4706 [label="param DirectiveStack(this) 4707"];
4707 [label="_directives 4708"];
4708 [label="null 4709"];
4709 [label="new DirectiveStack(null) 4710"];
4710 [label="param DirectiveStack(ConsList<Directive> directives) 4711"];
4711 [label="param DirectiveStack(this) 4712"];
4712 [label="_directives 4713"];
4713 [label="Null = new DirectiveStack(null) 4714"];
4714 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 4715"];
4715 [label="param HasUnfinishedIf(this) 4716"];
4716 [label="_directives 4717"];
4717 [label="GetPreviousIfElifElseOrRegion(_directives) 4718"];
4718 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 4719"];
4719 [label="current = directives 4720"];
4720 [label="null 4721"];
4721 [label="current != null 4722"];
4722 [label="current != null && current.Any() 4723"];
4723 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 4724"];
4724 [label="return current; 4725"];
4725 [label="prev = GetPreviousIfElifElseOrRegion(_directives) 4726"];
4726 [label="null 4727"];
4727 [label="prev != null 4728"];
4728 [label="prev != null && prev.Any() 4729"];
4729 [label="prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia 4730"];
4730 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 4731"];
4731 [label="param HasUnfinishedRegion(this) 4732"];
4732 [label="_directives 4733"];
4733 [label="GetPreviousIfElifElseOrRegion(_directives) 4734"];
4734 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 4735"];
4735 [label="null 4736"];
4736 [label="current != null 4737"];
4737 [label="current != null && current.Any() 4738"];
4738 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 4739"];
4739 [label="prev = GetPreviousIfElifElseOrRegion(_directives) 4740"];
4740 [label="null 4741"];
4741 [label="prev != null 4742"];
4742 [label="prev != null && prev.Any() 4743"];
4743 [label="prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia 4744"];
4744 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 4745"];
4745 [label="i < builder.Count 4746"];
4746 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 4747"];
4747 [label="_errors != null 4748"];
4748 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 4749"];
4749 [label="null 4750"];
4750 [label="return null; 4751"];
4751 [label="errors = this.GetErrors(GetFullWidth(leading)) 4752"];
4752 [label="errors 4753"];
4753 [label="param Create(SyntaxDiagnosticInfo[] errors) 4754"];
4754 [label="info.Kind != SyntaxKind.IdentifierToken 4755"];
4755 [label="info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null 4756"];
4756 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null) 4757"];
4757 [label="leadingNode 4758"];
4758 [label="info.Kind 4759"];
4759 [label="trailingNode 4760"];
4760 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 4761"];
4761 [label="param Token(GreenNode leading) 4762"];
4762 [label="param Token(SyntaxKind kind) 4763"];
4763 [label="param Token(GreenNode trailing) 4764"];
4764 [label="kind > LastTokenWithWellKnownText 4765"];
4765 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 4766"];
4766 [label="trailing == null 4767"];
4767 [label="s_tokensWithNoTrivia[(int)kind] 4768"];
4768 [label="token 4769"];
4769 [label="errors != null 4770"];
4770 [label="errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment) 4771"];
4771 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 4772"];
4772 [label="this.QuickScanSyntaxToken() ?? this.LexSyntaxToken() 4773"];
4773 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 4774"];
4774 [label="token = lexer.Lex(mode) 4775"];
4775 [label="token 4776"];
4776 [label="param AddLexedToken(SyntaxToken token) 4777"];
4777 [label="token != null 4778"];
4778 [label="Debug.Assert(token != null) 4779"];
4779 [label="_lexedTokens[_tokenCount].Value 4780"];
4780 [label="get { return (SyntaxKind)this.RawKind; } 4781"];
4781 [label="return (SyntaxKind)this.RawKind; 4782"];
4782 [label="token.Kind == SyntaxKind.EndOfFileToken 4783"];
4783 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 4784"];
4784 [label="new SyntaxListPool() 4785"];
4785 [label="_pool = new SyntaxListPool() 4786"];
4786 [label="_syntaxFactoryContext 4787"];
4787 [label="_syntaxFactory 4788"];
4788 [label="_recursionDepth 4789"];
4789 [label="_termState 4790"];
4790 [label="_isInTry 4791"];
4791 [label="_checkedTopLevelStatementsFeatureAvailability 4792"];
4792 [label="new SyntaxFactoryContext() 4793"];
4793 [label="_syntaxFactoryContext 4794"];
4794 [label="_syntaxFactoryContext 4795"];
4795 [label="new ContextAwareSyntax(_syntaxFactoryContext) 4796"];
4796 [label="_syntaxFactory 4797"];
4797 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 4798"];
4798 [label="parser = MakeParser(lexer) 4799"];
4799 [label="parser.ParseStatement() 4800"];
4800 [label="param ParseStatement(this) 4801"];
4801 [label="() => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default) 4802"];
4802 [label="() => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken)) 4803"];
4803 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 4804"];
4804 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 4805"];
4805 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 4806"];
4806 [label="param ParseWithStackGuard(this) 4807"];
4807 [label="0 4808"];
4808 [label="_recursionDepth == 0 4809"];
4809 [label="Debug.Assert(_recursionDepth == 0) 4810"];
4810 [label="parseFunc() 4811"];
4811 [label="parseFunc() 4812"];
4812 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 4813"];
4813 [label="ParseAttributeDeclarations() 4814"];
4814 [label="param ParseAttributeDeclarations(this) 4815"];
4815 [label="_pool.Allocate<AttributeListSyntax>() 4816"];
4816 [label="attributes = _pool.Allocate<AttributeListSyntax>() 4817"];
4817 [label="saveTerm = _termState 4818"];
4818 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator 4819"];
4819 [label="_termState 4820"];
4820 [label="this.IsPossibleAttributeDeclaration() 4821"];
4821 [label="param IsPossibleAttributeDeclaration(this) 4822"];
4822 [label="this.CurrentToken 4823"];
4823 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 4824"];
4824 [label="this.FetchCurrentToken() 4825"];
4825 [label="param FetchCurrentToken(this) 4826"];
4826 [label="_tokenOffset >= _tokenCount 4827"];
4827 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 4828"];
4828 [label="null 4829"];
4829 [label="_blendedTokens != null 4830"];
4830 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 4831"];
4831 [label="_lexedTokens[_tokenOffset] 4832"];
4832 [label="return _lexedTokens[_tokenOffset]; 4833"];
4833 [label="_currentToken 4834"];
4834 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 4835"];
4835 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 4836"];
4836 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 4837"];
4837 [label="this.CurrentToken.Kind 4838"];
4838 [label="get { return (SyntaxKind)this.RawKind; } 4839"];
4839 [label="return (SyntaxKind)this.RawKind; 4840"];
4840 [label="this.CurrentToken.Kind == SyntaxKind.OpenBracketToken 4841"];
4841 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 4842"];
4842 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 4843"];
4843 [label="_termState 4844"];
4844 [label="attributes.ToList() 4845"];
4845 [label="return attributes.ToList(); 4846"];
4846 [label="attributes 4847"];
4847 [label="_pool.Free(attributes) 4848"];
4848 [label="false 4849"];
4849 [label="isGlobal: false 4850"];
4850 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 4851"];
4851 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 4852"];
4852 [label="param ParseStatementCore(bool isGlobal) 4853"];
4853 [label="param ParseStatementCore(this) 4854"];
4854 [label="attributes 4855"];
4855 [label="isGlobal 4856"];
4856 [label="canReuseStatement(attributes, isGlobal) 4857"];
4857 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 4858"];
4858 [label="param ParseStatementCore(bool isGlobal) 4859"];
4859 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 4860"];
4860 [label="this.IsIncrementalAndFactoryContextMatches 4861"];
4861 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 4862"];
4862 [label="base.IsIncremental 4863"];
4863 [label="get\n            {\n                return _isIncremental;\n            } 4864"];
4864 [label="return _isIncremental; 4865"];
4865 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 4866"];
4866 [label="false 4867"];
4867 [label="return false; 4868"];
4868 [label="this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax 4869"];
4869 [label="this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal 4870"];
4870 [label="this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0 4871"];
4871 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 4872"];
4872 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 4873"];
4873 [label="this.GetResetPoint() 4874"];
4874 [label="param GetResetPoint(this) 4875"];
4875 [label="base.GetResetPoint() 4876"];
4876 [label="param GetResetPoint(this) 4877"];
4877 [label="CurrentTokenPosition 4878"];
4878 [label="=> _firstToken + _tokenOffset 4879"];
4879 [label="_firstToken + _tokenOffset 4880"];
4880 [label="pos = CurrentTokenPosition 4881"];
4881 [label="0 4882"];
4882 [label="_resetCount == 0 4883"];
4883 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 4884"];
4884 [label="_resetStart 4885"];
4885 [label="_resetCount 4886"];
4886 [label="_resetCount 4887"];
4887 [label="_mode 4888"];
4888 [label="pos 4889"];
4889 [label="_prevTokenTrailingTrivia 4890"];
4890 [label="new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia) 4891"];
4891 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 4892"];
4892 [label="_termState 4893"];
4893 [label="_isInTry 4894"];
4894 [label="_syntaxFactoryContext.IsInAsync 4895"];
4895 [label="_syntaxFactoryContext.QueryDepth 4896"];
4896 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 4897"];
4897 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 4898"];
4898 [label="param ResetPoint(TerminatorState terminatorState) 4899"];
4899 [label="param ResetPoint(bool isInTry) 4900"];
4900 [label="param ResetPoint(bool isInAsync) 4901"];
4901 [label="param ResetPoint(int queryDepth) 4902"];
4902 [label="param ResetPoint(this) 4903"];
4903 [label="this.BaseResetPoint 4904"];
4904 [label="this.TerminatorState 4905"];
4905 [label="this.IsInTry 4906"];
4906 [label="this.IsInAsync 4907"];
4907 [label="this.QueryDepth 4908"];
4908 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 4909"];
4909 [label="resetPointBeforeStatement = this.GetResetPoint() 4910"];
4910 [label="_recursionDepth 4911"];
4911 [label="_recursionDepth 4912"];
4912 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth) 4913"];
4913 [label="result 4914"];
4914 [label="this.CurrentToken 4915"];
4915 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 4916"];
4916 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 4917"];
4917 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 4918"];
4918 [label="this.CurrentToken.Kind 4919"];
4919 [label="get { return (SyntaxKind)this.RawKind; } 4920"];
4920 [label="return (SyntaxKind)this.RawKind; 4921"];
4921 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 4922"];
4922 [label="attributes 4923"];
4923 [label="isGlobal 4924"];
4924 [label="TryParseStatementStartingWithIdentifier(attributes, isGlobal) 4925"];
4925 [label="param TryParseStatementStartingWithIdentifier(SyntaxList<AttributeListSyntax> attributes) 4926"];
4926 [label="param TryParseStatementStartingWithIdentifier(bool isGlobal) 4927"];
4927 [label="param TryParseStatementStartingWithIdentifier(this) 4928"];
4928 [label="this.CurrentToken 4929"];
4929 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 4930"];
4930 [label="this.CurrentToken.ContextualKind 4931"];
4931 [label="get\n            {\n                return this.Kind;\n            } 4932"];
4932 [label="this.Kind 4933"];
4933 [label="get { return (SyntaxKind)this.RawKind; } 4934"];
4934 [label="return this.Kind; 4935"];
4935 [label="this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 4936"];
4936 [label="this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.ForEachKeyword 4937"];
4937 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.ForEachKeyword)\n            {\n                return this.ParseForEachStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncStreams));\n            }\n            else if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 4938"];
4938 [label="IsPossibleAwaitUsing() 4939"];
4939 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 4940"];
4940 [label="CurrentToken 4941"];
4941 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 4942"];
4942 [label="CurrentToken.ContextualKind 4943"];
4943 [label="get\n            {\n                return this.Kind;\n            } 4944"];
4944 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 4945"];
4945 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 4946"];
4946 [label="if (IsPossibleAwaitUsing())\n            {\n                if (PeekToken(2).Kind == SyntaxKind.OpenParenToken)\n                {\n                    // `await using Type ...` is handled below in ParseLocalDeclarationStatement\n                    return this.ParseUsingStatement(attributes, ParseAwaitKeyword(MessageID.IDS_FeatureAsyncUsing));\n                }\n            }\n            else if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 4947"];
4947 [label="this.IsPossibleLabeledStatement() 4948"];
4948 [label="param IsPossibleLabeledStatement(this) 4949"];
4949 [label="1 4950"];
4950 [label="this.PeekToken(1) 4951"];
4951 [label="param PeekToken(int n) 4952"];
4952 [label="param PeekToken(this) 4953"];
4953 [label="0 4954"];
4954 [label="n >= 0 4955"];
4955 [label="Debug.Assert(n >= 0) 4956"];
4956 [label="_tokenOffset + n 4957"];
4957 [label="_tokenOffset + n >= _tokenCount 4958"];
4958 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 4959"];
4959 [label="null 4960"];
4960 [label="_blendedTokens != null 4961"];
4961 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 4962"];
4962 [label="_tokenOffset + n 4963"];
4963 [label="_lexedTokens[_tokenOffset + n] 4964"];
4964 [label="return _lexedTokens[_tokenOffset + n]; 4965"];
4965 [label="this.PeekToken(1).Kind 4966"];
4966 [label="get { return (SyntaxKind)this.RawKind; } 4967"];
4967 [label="this.PeekToken(1).Kind == SyntaxKind.ColonToken 4968"];
4968 [label="this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier() 4969"];
4969 [label="return this.PeekToken(1).Kind == SyntaxKind.ColonToken && this.IsTrueIdentifier(); 4970"];
4970 [label="if (this.IsPossibleLabeledStatement())\n            {\n                return this.ParseLabeledStatement(attributes);\n            }\n            else if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 4971"];
4971 [label="this.IsPossibleYieldStatement() 4972"];
4972 [label="param IsPossibleYieldStatement(this) 4973"];
4973 [label="this.CurrentToken 4974"];
4974 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 4975"];
4975 [label="this.CurrentToken.ContextualKind 4976"];
4976 [label="get\n            {\n                return this.Kind;\n            } 4977"];
4977 [label="this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword 4978"];
4978 [label="this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword) 4979"];
4979 [label="return this.CurrentToken.ContextualKind == SyntaxKind.YieldKeyword && (this.PeekToken(1).Kind == SyntaxKind.ReturnKeyword || this.PeekToken(1).Kind == SyntaxKind.BreakKeyword); 4980"];
4980 [label="if (this.IsPossibleYieldStatement())\n            {\n                return this.ParseYieldStatement(attributes);\n            }\n            else if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 4981"];
4981 [label="this.IsPossibleAwaitExpressionStatement() 4982"];
4982 [label="param IsPossibleAwaitExpressionStatement(this) 4983"];
4983 [label="this.IsScript 4984"];
4984 [label="get { return Options.Kind == SourceCodeKind.Script; } 4985"];
4985 [label="Options 4986"];
4986 [label="get { return this.lexer.Options; } 4987"];
4987 [label="this.lexer.Options 4988"];
4988 [label="get { return _options; } 4989"];
4989 [label="return _options; 4990"];
4990 [label="return this.lexer.Options; 4991"];
4991 [label="Options.Kind == SourceCodeKind.Script 4992"];
4992 [label="return Options.Kind == SourceCodeKind.Script; 4993"];
4993 [label="this.IsInAsync 4994"];
4994 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 4995"];
4995 [label="return _syntaxFactoryContext.IsInAsync; 4996"];
4996 [label="this.IsScript || this.IsInAsync 4997"];
4997 [label="(this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 4998"];
4998 [label="return (this.IsScript || this.IsInAsync) && this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword; 4999"];
4999 [label="if (this.IsPossibleAwaitExpressionStatement())\n            {\n                return this.ParseExpressionStatement(attributes);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5000"];
5000 [label="true 5001"];
5001 [label="mayBeVariableDeclaration: true 5002"];
5002 [label="isGlobal && IsScript 5003"];
5003 [label="mayBeMemberDeclaration: isGlobal && IsScript 5004"];
5004 [label="this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript) 5005"];
5005 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 5006"];
5006 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 5007"];
5007 [label="param IsQueryExpression(this) 5008"];
5008 [label="this.CurrentToken 5009"];
5009 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5010"];
5010 [label="this.CurrentToken.ContextualKind 5011"];
5011 [label="get\n            {\n                return this.Kind;\n            } 5012"];
5012 [label="this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword 5013"];
5013 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 5014"];
5014 [label="false 5015"];
5015 [label="return false; 5016"];
5016 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: isGlobal && IsScript))\n            {\n                return this.ParseExpressionStatement(attributes, this.ParseQueryExpression(0));\n            } 5017"];
5017 [label="null 5018"];
5018 [label="return null; 5019"];
5019 [label="result 5020"];
5020 [label="null 5021"];
5021 [label="result != null 5022"];
5022 [label="if (result != null)\n                            return result; 5023"];
5023 [label="attributes 5024"];
5024 [label="isGlobal 5025"];
5025 [label="ref resetPointBeforeStatement 5026"];
5026 [label="ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement) 5027"];
5027 [label="param ParseStatementCoreRest(SyntaxList<AttributeListSyntax> attributes) 5028"];
5028 [label="param ParseStatementCoreRest(bool isGlobal) 5029"];
5029 [label="param ParseStatementCoreRest(ref ResetPoint resetPointBeforeStatement) 5030"];
5030 [label="param ParseStatementCoreRest(this) 5031"];
5031 [label="isGlobal && IsScript 5032"];
5032 [label="isGlobal 5033"];
5033 [label="isGlobal 5034"];
5034 [label="this.IsPossibleLocalDeclarationStatement(isGlobal) 5035"];
5035 [label="param IsPossibleLocalDeclarationStatement(bool isGlobalScriptLevel) 5036"];
5036 [label="param IsPossibleLocalDeclarationStatement(this) 5037"];
5037 [label="this.CurrentToken 5038"];
5038 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5039"];
5039 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 5040"];
5040 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5041"];
5041 [label="this.CurrentToken.Kind 5042"];
5042 [label="get { return (SyntaxKind)this.RawKind; } 5043"];
5043 [label="return (SyntaxKind)this.RawKind; 5044"];
5044 [label="tk = this.CurrentToken.Kind 5045"];
5045 [label="tk == SyntaxKind.RefKeyword 5046"];
5046 [label="tk 5047"];
5047 [label="IsDeclarationModifier(tk) 5048"];
5048 [label="param IsDeclarationModifier(SyntaxKind kind) 5049"];
5049 [label="switch (kind)\n            {\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.ReadOnlyKeyword:\n                case SyntaxKind.VolatileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5050"];
5050 [label="false 5051"];
5051 [label="return false; 5052"];
5052 [label="tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) 5053"];
5053 [label="tk 5054"];
5054 [label="SyntaxFacts.IsPredefinedType(tk) 5055"];
5055 [label="param IsPredefinedType(SyntaxKind kind) 5056"];
5056 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5057"];
5057 [label="false 5058"];
5058 [label="return false; 5059"];
5059 [label="SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken 5060"];
5060 [label="SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken 5061"];
5061 [label="tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken) 5062"];
5062 [label="if (tk == SyntaxKind.RefKeyword ||\n                IsDeclarationModifier(tk) || // treat `static int x = 2;` as a local variable declaration\n                (SyntaxFacts.IsPredefinedType(tk) &&\n                        this.PeekToken(1).Kind != SyntaxKind.DotToken && // e.g. `int.Parse()` is an expression\n                        this.PeekToken(1).Kind != SyntaxKind.OpenParenToken)) // e.g. `int (x, y)` is an error decl expression\n            {\n                return true;\n            } 5063"];
5063 [label="tk == SyntaxKind.UsingKeyword 5064"];
5064 [label="if (tk == SyntaxKind.UsingKeyword)\n            {\n                Debug.Assert(PeekToken(1).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 5065"];
5065 [label="IsPossibleAwaitUsing() 5066"];
5066 [label="=> CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 5067"];
5067 [label="CurrentToken 5068"];
5068 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5069"];
5069 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 5070"];
5070 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5071"];
5071 [label="CurrentToken.ContextualKind 5072"];
5072 [label="get\n            {\n                return this.Kind;\n            } 5073"];
5073 [label="this.Kind 5074"];
5074 [label="get { return (SyntaxKind)this.RawKind; } 5075"];
5075 [label="return (SyntaxKind)this.RawKind; 5076"];
5076 [label="return this.Kind; 5077"];
5077 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 5078"];
5078 [label="CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword && PeekToken(1).Kind == SyntaxKind.UsingKeyword 5079"];
5079 [label="if (IsPossibleAwaitUsing())\n            {\n                Debug.Assert(PeekToken(2).Kind != SyntaxKind.OpenParenToken);\n                return true;\n            } 5080"];
5080 [label="this.CurrentToken 5081"];
5081 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5082"];
5082 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 5083"];
5083 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5084"];
5084 [label="this.CurrentToken.ContextualKind 5085"];
5085 [label="get\n            {\n                return this.Kind;\n            } 5086"];
5086 [label="this.Kind 5087"];
5087 [label="get { return (SyntaxKind)this.RawKind; } 5088"];
5088 [label="return (SyntaxKind)this.RawKind; 5089"];
5089 [label="return this.Kind; 5090"];
5090 [label="tk 5091"];
5091 [label="tk 5092"];
5092 [label="IsAdditionalLocalFunctionModifier(tk) 5093"];
5093 [label="param IsAdditionalLocalFunctionModifier(SyntaxKind kind) 5094"];
5094 [label="switch (kind)\n            {\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.UnsafeKeyword:\n                case SyntaxKind.ExternKeyword:\n                // Not a valid modifier, but we should parse to give a good\n                // error message\n                case SyntaxKind.PublicKeyword:\n                case SyntaxKind.InternalKeyword:\n                case SyntaxKind.ProtectedKeyword:\n                case SyntaxKind.PrivateKeyword:\n                    return true;\n\n                default:\n                    return false;\n            } 5095"];
5095 [label="false 5096"];
5096 [label="return false; 5097"];
5097 [label="tk == SyntaxKind.OpenBracketToken 5098"];
5098 [label="IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken 5099"];
5099 [label="(IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)) 5100"];
5100 [label="isPossibleAttributeOrModifier = (IsAdditionalLocalFunctionModifier(tk) || tk == SyntaxKind.OpenBracketToken)\n                && (tk != SyntaxKind.AsyncKeyword || ShouldAsyncBeTreatedAsModifier(parsingStatementNotDeclaration: true)) 5101"];
5101 [label="if (isPossibleAttributeOrModifier)\n            {\n                return true;\n            } 5102"];
5102 [label="isGlobalScriptLevel 5103"];
5103 [label="IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel) 5104"];
5104 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(bool isGlobalScriptLevel) 5105"];
5105 [label="param IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(this) 5106"];
5106 [label="this.CurrentToken 5107"];
5107 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5108"];
5108 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 5109"];
5109 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 5110"];
5110 [label="1 5111"];
5111 [label="this.PeekToken(1) 5112"];
5112 [label="param PeekToken(int n) 5113"];
5113 [label="param PeekToken(this) 5114"];
5114 [label="0 5115"];
5115 [label="n >= 0 5116"];
5116 [label="Debug.Assert(n >= 0) 5117"];
5117 [label="_tokenOffset + n 5118"];
5118 [label="_tokenOffset + n >= _tokenCount 5119"];
5119 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5120"];
5120 [label="null 5121"];
5121 [label="_blendedTokens != null 5122"];
5122 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 5123"];
5123 [label="_tokenOffset + n 5124"];
5124 [label="_lexedTokens[_tokenOffset + n] 5125"];
5125 [label="return _lexedTokens[_tokenOffset + n]; 5126"];
5126 [label="false 5127"];
5127 [label="allowThisKeyword: false 5128"];
5128 [label="IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false) 5129"];
5129 [label="param IsPossibleTypedIdentifierStart(SyntaxToken current) 5130"];
5130 [label="param IsPossibleTypedIdentifierStart(SyntaxToken next) 5131"];
5131 [label="param IsPossibleTypedIdentifierStart(bool allowThisKeyword) 5132"];
5132 [label="param IsPossibleTypedIdentifierStart(this) 5133"];
5133 [label="current 5134"];
5134 [label="IsTrueIdentifier(current) 5135"];
5135 [label="param IsTrueIdentifier(SyntaxToken token) 5136"];
5136 [label="param IsTrueIdentifier(this) 5137"];
5137 [label="token.Kind 5138"];
5138 [label="get { return (SyntaxKind)this.RawKind; } 5139"];
5139 [label="return (SyntaxKind)this.RawKind; 5140"];
5140 [label="token.Kind == SyntaxKind.IdentifierToken 5141"];
5141 [label="this.IsInQuery 5142"];
5142 [label="get { return _syntaxFactoryContext.IsInQuery; } 5143"];
5143 [label="return _syntaxFactoryContext.IsInQuery; 5144"];
5144 [label="this.IsInQuery && IsTokenQueryContextualKeyword(token) 5145"];
5145 [label="token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)) 5146"];
5146 [label="return\n                token.Kind == SyntaxKind.IdentifierToken &&\n                !(this.IsInQuery && IsTokenQueryContextualKeyword(token)); 5147"];
5147 [label="if (IsTrueIdentifier(current))\n            {\n                switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                }\n            } 5148"];
5148 [label="next.Kind 5149"];
5149 [label="get { return (SyntaxKind)this.RawKind; } 5150"];
5150 [label="switch (next.Kind)\n                {\n                    // tokens that can be in type names...\n                    case SyntaxKind.DotToken:\n                    case SyntaxKind.AsteriskToken:\n                    case SyntaxKind.QuestionToken:\n                    case SyntaxKind.OpenBracketToken:\n                    case SyntaxKind.LessThanToken:\n                    case SyntaxKind.ColonColonToken:\n                        return null;\n\n                    case SyntaxKind.OpenParenToken:\n                        if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                    case SyntaxKind.IdentifierToken:\n                        return IsTrueIdentifier(next);\n\n                    case SyntaxKind.ThisKeyword:\n                        return allowThisKeyword;\n\n                    default:\n                        return false;\n                } 5151"];
5151 [label="current 5152"];
5152 [label="current.IsIdentifierVar() 5153"];
5153 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 5154"];
5154 [label="node.ContextualKind 5155"];
5155 [label="get\n            {\n                return this.Kind;\n            } 5156"];
5156 [label="this.Kind 5157"];
5157 [label="get { return (SyntaxKind)this.RawKind; } 5158"];
5158 [label="return this.Kind; 5159"];
5159 [label="node.ContextualKind == SyntaxKind.VarKeyword 5160"];
5160 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 5161"];
5161 [label="if (current.IsIdentifierVar())\n                        {\n                            // potentially either a tuple type in a local declaration (true), or\n                            // a tuple lvalue in a deconstruction assignment (false).\n                            return null;\n                        }\n                        else\n                        {\n                            return false;\n                        } 5162"];
5162 [label="false 5163"];
5163 [label="return false; 5164"];
5164 [label="typedIdentifier = IsPossibleTypedIdentifierStart(this.CurrentToken, this.PeekToken(1), allowThisKeyword: false) 5165"];
5165 [label="null 5166"];
5166 [label="typedIdentifier != null 5167"];
5167 [label="if (typedIdentifier != null)\n            {\n                return typedIdentifier.Value;\n            } 5168"];
5168 [label="return typedIdentifier.Value; 5169"];
5169 [label="return IsPossibleFirstTypedIdentifierInLocaDeclarationStatement(isGlobalScriptLevel); 5170"];
5170 [label="if (!this.IsPossibleLocalDeclarationStatement(isGlobal))\n            {\n                return this.ParseExpressionStatement(attributes);\n            } 5171"];
5171 [label="attributes 5172"];
5172 [label="this.ParseExpressionStatement(attributes) 5173"];
5173 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 5174"];
5174 [label="param ParseExpressionStatement(this) 5175"];
5175 [label="attributes 5176"];
5176 [label="this.ParseExpressionCore() 5177"];
5177 [label="param ParseExpressionCore(this) 5178"];
5178 [label="Precedence.Expression 5179"];
5179 [label="this.ParseSubExpression(Precedence.Expression) 5180"];
5180 [label="param ParseSubExpression(Precedence precedence) 5181"];
5181 [label="param ParseSubExpression(this) 5182"];
5182 [label="_recursionDepth 5183"];
5183 [label="_recursionDepth 5184"];
5184 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth) 5185"];
5185 [label="precedence 5186"];
5186 [label="ParseSubExpressionCore(precedence) 5187"];
5187 [label="param ParseSubExpressionCore(Precedence precedence) 5188"];
5188 [label="param ParseSubExpressionCore(this) 5189"];
5189 [label="leftOperand 5190"];
5190 [label="0 5191"];
5191 [label="newPrecedence = 0 5192"];
5192 [label="this.CurrentToken 5193"];
5193 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5194"];
5194 [label="this.CurrentToken.Kind 5195"];
5195 [label="get { return (SyntaxKind)this.RawKind; } 5196"];
5196 [label="tk = this.CurrentToken.Kind 5197"];
5197 [label="tk 5198"];
5198 [label="IsInvalidSubExpression(tk) 5199"];
5199 [label="param IsInvalidSubExpression(SyntaxKind kind) 5200"];
5200 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5201"];
5201 [label="false 5202"];
5202 [label="return false; 5203"];
5203 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 5204"];
5204 [label="tk 5205"];
5205 [label="IsExpectedPrefixUnaryOperator(tk) 5206"];
5206 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 5207"];
5207 [label="kind 5208"];
5208 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 5209"];
5209 [label="param IsPrefixUnaryExpression(SyntaxKind token) 5210"];
5210 [label="token 5211"];
5211 [label="GetPrefixUnaryExpression(token) 5212"];
5212 [label="param GetPrefixUnaryExpression(SyntaxKind token) 5213"];
5213 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 5214"];
5214 [label="return SyntaxKind.None; 5215"];
5215 [label="GetPrefixUnaryExpression(token) != SyntaxKind.None 5216"];
5216 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 5217"];
5217 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword 5218"];
5218 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword 5219"];
5219 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 5220"];
5220 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5221"];
5221 [label="tk == SyntaxKind.DotDotToken 5222"];
5222 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5223"];
5223 [label="IsAwaitExpression() 5224"];
5224 [label="param IsAwaitExpression(this) 5225"];
5225 [label="this.CurrentToken 5226"];
5226 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5227"];
5227 [label="this.CurrentToken.ContextualKind 5228"];
5228 [label="get\n            {\n                return this.Kind;\n            } 5229"];
5229 [label="this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword 5230"];
5230 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 5231"];
5231 [label="false 5232"];
5232 [label="return false; 5233"];
5233 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5234"];
5234 [label="false 5235"];
5235 [label="mayBeVariableDeclaration: false 5236"];
5236 [label="false 5237"];
5237 [label="mayBeMemberDeclaration: false 5238"];
5238 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 5239"];
5239 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 5240"];
5240 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 5241"];
5241 [label="param IsQueryExpression(this) 5242"];
5242 [label="this.CurrentToken 5243"];
5243 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5244"];
5244 [label="this.CurrentToken.ContextualKind 5245"];
5245 [label="get\n            {\n                return this.Kind;\n            } 5246"];
5246 [label="this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword 5247"];
5247 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 5248"];
5248 [label="false 5249"];
5249 [label="return false; 5250"];
5250 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5251"];
5251 [label="this.CurrentToken 5252"];
5252 [label="this.CurrentToken.ContextualKind 5253"];
5253 [label="get\n            {\n                return this.Kind;\n            } 5254"];
5254 [label="this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword 5255"];
5255 [label="this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery 5256"];
5256 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5257"];
5257 [label="tk == SyntaxKind.ThrowKeyword 5258"];
5258 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5259"];
5259 [label="precedence 5260"];
5260 [label="this.IsPossibleDeconstructionLeft(precedence) 5261"];
5261 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 5262"];
5262 [label="param IsPossibleDeconstructionLeft(this) 5263"];
5263 [label="precedence > Precedence.Assignment 5264"];
5264 [label="this.CurrentToken 5265"];
5265 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5266"];
5266 [label="this.CurrentToken.IsIdentifierVar() 5267"];
5267 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 5268"];
5268 [label="this.CurrentToken 5269"];
5269 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5270"];
5270 [label="this.CurrentToken.Kind 5271"];
5271 [label="get { return (SyntaxKind)this.RawKind; } 5272"];
5272 [label="IsPredefinedType(this.CurrentToken.Kind) 5273"];
5273 [label="param IsPredefinedType(SyntaxKind keyword) 5274"];
5274 [label="keyword 5275"];
5275 [label="SyntaxFacts.IsPredefinedType(keyword) 5276"];
5276 [label="param IsPredefinedType(SyntaxKind kind) 5277"];
5277 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 5278"];
5278 [label="false 5279"];
5279 [label="return false; 5280"];
5280 [label="return SyntaxFacts.IsPredefinedType(keyword); 5281"];
5281 [label="this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind) 5282"];
5282 [label="precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)) 5283"];
5283 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 5284"];
5284 [label="false 5285"];
5285 [label="return false; 5286"];
5286 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 5287"];
5287 [label="precedence 5288"];
5288 [label="this.ParseTerm(precedence) 5289"];
5289 [label="param ParseTerm(Precedence precedence) 5290"];
5290 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 5291"];
5291 [label="precedence 5292"];
5292 [label="ParseTermWithoutPostfix(precedence) 5293"];
5293 [label="param ParseTermWithoutPostfix(Precedence precedence) 5294"];
5294 [label="param ParseTermWithoutPostfix(this) 5295"];
5295 [label="this.CurrentToken 5296"];
5296 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5297"];
5297 [label="this.CurrentToken.Kind 5298"];
5298 [label="get { return (SyntaxKind)this.RawKind; } 5299"];
5299 [label="tk = this.CurrentToken.Kind 5300"];
5300 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 5301"];
5301 [label="this.IsTrueIdentifier() 5302"];
5302 [label="param IsTrueIdentifier(this) 5303"];
5303 [label="this.CurrentToken 5304"];
5304 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5305"];
5305 [label="this.CurrentToken.Kind 5306"];
5306 [label="get { return (SyntaxKind)this.RawKind; } 5307"];
5307 [label="this.CurrentToken.Kind == SyntaxKind.IdentifierToken 5308"];
5308 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 5309"];
5309 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 5310"];
5310 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 5311"];
5311 [label="this.CurrentToken 5312"];
5312 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5313"];
5313 [label="this.CurrentToken.ContextualKind 5314"];
5314 [label="get\n            {\n                return this.Kind;\n            } 5315"];
5315 [label="this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword 5316"];
5316 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 5317"];
5317 [label="false 5318"];
5318 [label="return false; 5319"];
5319 [label="IsCurrentTokenQueryKeywordInQuery() 5320"];
5320 [label="param IsCurrentTokenQueryKeywordInQuery(this) 5321"];
5321 [label="this.IsInQuery 5322"];
5322 [label="get { return _syntaxFactoryContext.IsInQuery; } 5323"];
5323 [label="return _syntaxFactoryContext.IsInQuery; 5324"];
5324 [label="this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword 5325"];
5325 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 5326"];
5326 [label="!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() 5327"];
5327 [label="IsCurrentTokenWhereOfConstraintClause() 5328"];
5328 [label="param IsCurrentTokenWhereOfConstraintClause(this) 5329"];
5329 [label="this.CurrentToken 5330"];
5330 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5331"];
5331 [label="this.CurrentToken.ContextualKind 5332"];
5332 [label="get\n            {\n                return this.Kind;\n            } 5333"];
5333 [label="this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword 5334"];
5334 [label="this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken 5335"];
5335 [label="this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken 5336"];
5336 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 5337"];
5337 [label="!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause() 5338"];
5338 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 5339"];
5339 [label="true 5340"];
5340 [label="return true; 5341"];
5341 [label="if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    } 5342"];
5342 [label="this.IsPossibleAnonymousMethodExpression() 5343"];
5343 [label="param IsPossibleAnonymousMethodExpression(this) 5344"];
5344 [label="0 5345"];
5345 [label="tokenIndex = 0 5346"];
5346 [label="tokenIndex 5347"];
5347 [label="this.PeekToken(tokenIndex) 5348"];
5348 [label="param PeekToken(int n) 5349"];
5349 [label="param PeekToken(this) 5350"];
5350 [label="0 5351"];
5351 [label="n >= 0 5352"];
5352 [label="Debug.Assert(n >= 0) 5353"];
5353 [label="_tokenOffset + n 5354"];
5354 [label="_tokenOffset + n >= _tokenCount 5355"];
5355 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5356"];
5356 [label="_tokenOffset + n 5357"];
5357 [label="this.PeekToken(tokenIndex).Kind 5358"];
5358 [label="get { return (SyntaxKind)this.RawKind; } 5359"];
5359 [label="this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword 5360"];
5360 [label="tokenIndex 5361"];
5361 [label="this.PeekToken(tokenIndex) 5362"];
5362 [label="param PeekToken(int n) 5363"];
5363 [label="param PeekToken(this) 5364"];
5364 [label="0 5365"];
5365 [label="n >= 0 5366"];
5366 [label="Debug.Assert(n >= 0) 5367"];
5367 [label="_tokenOffset + n 5368"];
5368 [label="_tokenOffset + n >= _tokenCount 5369"];
5369 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5370"];
5370 [label="_tokenOffset + n 5371"];
5371 [label="this.PeekToken(tokenIndex).ContextualKind 5372"];
5372 [label="get\n            {\n                return this.Kind;\n            } 5373"];
5373 [label="this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword 5374"];
5374 [label="this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword 5375"];
5375 [label="while (this.PeekToken(tokenIndex).Kind == SyntaxKind.StaticKeyword ||\n                   this.PeekToken(tokenIndex).ContextualKind == SyntaxKind.AsyncKeyword)\n            {\n                tokenIndex++;\n            } 5376"];
5376 [label="tokenIndex 5377"];
5377 [label="this.PeekToken(tokenIndex) 5378"];
5378 [label="param PeekToken(int n) 5379"];
5379 [label="param PeekToken(this) 5380"];
5380 [label="0 5381"];
5381 [label="n >= 0 5382"];
5382 [label="Debug.Assert(n >= 0) 5383"];
5383 [label="_tokenOffset + n 5384"];
5384 [label="_tokenOffset + n >= _tokenCount 5385"];
5385 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5386"];
5386 [label="_tokenOffset + n 5387"];
5387 [label="this.PeekToken(tokenIndex).Kind 5388"];
5388 [label="get { return (SyntaxKind)this.RawKind; } 5389"];
5389 [label="this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword 5390"];
5390 [label="return this.PeekToken(tokenIndex).Kind == SyntaxKind.DelegateKeyword; 5391"];
5391 [label="if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 5392"];
5392 [label="precedence 5393"];
5393 [label="this.IsPossibleLambdaExpression(precedence) 5394"];
5394 [label="param IsPossibleLambdaExpression(Precedence precedence) 5395"];
5395 [label="param IsPossibleLambdaExpression(this) 5396"];
5396 [label="this.CurrentToken 5397"];
5397 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5398"];
5398 [label="this.CurrentToken.Kind 5399"];
5399 [label="get { return (SyntaxKind)this.RawKind; } 5400"];
5400 [label="this.CurrentToken.Kind == SyntaxKind.StaticKeyword 5401"];
5401 [label="this.CurrentToken 5402"];
5402 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5403"];
5403 [label="this.IsTrueIdentifier(this.CurrentToken) 5404"];
5404 [label="param IsTrueIdentifier(SyntaxToken token) 5405"];
5405 [label="param IsTrueIdentifier(this) 5406"];
5406 [label="this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken) 5407"];
5407 [label="Debug.Assert(\n                this.CurrentToken.Kind == SyntaxKind.StaticKeyword ||\n                this.IsTrueIdentifier(this.CurrentToken)) 5408"];
5408 [label="precedence > Precedence.Lambda 5409"];
5409 [label="if (precedence > Precedence.Lambda)\n            {\n                return false;\n            } 5410"];
5410 [label="peekIndex 5411"];
5411 [label="seenStatic 5412"];
5412 [label="this.CurrentToken 5413"];
5413 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5414"];
5414 [label="this.CurrentToken.Kind 5415"];
5415 [label="get { return (SyntaxKind)this.RawKind; } 5416"];
5416 [label="this.CurrentToken.Kind == SyntaxKind.StaticKeyword 5417"];
5417 [label="if (this.CurrentToken.Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 1;\n                seenStatic = true;\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 5418"];
5418 [label="this.CurrentToken 5419"];
5419 [label="this.CurrentToken.ContextualKind 5420"];
5420 [label="get\n            {\n                return this.Kind;\n            } 5421"];
5421 [label="this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword 5422"];
5422 [label="this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword 5423"];
5423 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AsyncKeyword &&\n                     this.PeekToken(1).Kind == SyntaxKind.StaticKeyword)\n            {\n                peekIndex = 2;\n                seenStatic = true;\n            }\n            else\n            {\n                peekIndex = 0;\n                seenStatic = false;\n            } 5424"];
5424 [label="0 5425"];
5425 [label="peekIndex 5426"];
5426 [label="false 5427"];
5427 [label="seenStatic 5428"];
5428 [label="peekIndex 5429"];
5429 [label="this.PeekToken(peekIndex) 5430"];
5430 [label="param PeekToken(int n) 5431"];
5431 [label="param PeekToken(this) 5432"];
5432 [label="0 5433"];
5433 [label="n >= 0 5434"];
5434 [label="Debug.Assert(n >= 0) 5435"];
5435 [label="_tokenOffset + n 5436"];
5436 [label="_tokenOffset + n >= _tokenCount 5437"];
5437 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5438"];
5438 [label="this.PeekToken(peekIndex).Kind 5439"];
5439 [label="get { return (SyntaxKind)this.RawKind; } 5440"];
5440 [label="this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken 5441"];
5441 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on => then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static =>`\n                // 2. `async static =>`\n\n                // This is an error case, but we have enough code in front of us to be certain\n                // the user was trying to write a static lambda.\n                return true;\n            } 5442"];
5442 [label="peekIndex 5443"];
5443 [label="this.PeekToken(peekIndex) 5444"];
5444 [label="param PeekToken(int n) 5445"];
5445 [label="param PeekToken(this) 5446"];
5446 [label="0 5447"];
5447 [label="n >= 0 5448"];
5448 [label="Debug.Assert(n >= 0) 5449"];
5449 [label="_tokenOffset + n 5450"];
5450 [label="_tokenOffset + n >= _tokenCount 5451"];
5451 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5452"];
5452 [label="this.PeekToken(peekIndex).Kind 5453"];
5453 [label="get { return (SyntaxKind)this.RawKind; } 5454"];
5454 [label="this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken 5455"];
5455 [label="1 5456"];
5456 [label="peekIndex + 1 5457"];
5457 [label="this.PeekToken(peekIndex + 1) 5458"];
5458 [label="param PeekToken(int n) 5459"];
5459 [label="param PeekToken(this) 5460"];
5460 [label="0 5461"];
5461 [label="n >= 0 5462"];
5462 [label="Debug.Assert(n >= 0) 5463"];
5463 [label="_tokenOffset + n 5464"];
5464 [label="_tokenOffset + n >= _tokenCount 5465"];
5465 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5466"];
5466 [label="this.PeekToken(peekIndex + 1).Kind 5467"];
5467 [label="get { return (SyntaxKind)this.RawKind; } 5468"];
5468 [label="this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken 5469"];
5469 [label="this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken 5470"];
5470 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(peekIndex + 1).Kind == SyntaxKind.EqualsGreaterThanToken)\n            {\n                // 1. `a => ...`\n                // 1. `static a => ...`\n                // 2. `async static a => ...`\n                return true;\n            } 5471"];
5471 [label="peekIndex 5472"];
5472 [label="this.PeekToken(peekIndex) 5473"];
5473 [label="param PeekToken(int n) 5474"];
5474 [label="param PeekToken(this) 5475"];
5475 [label="0 5476"];
5476 [label="n >= 0 5477"];
5477 [label="Debug.Assert(n >= 0) 5478"];
5478 [label="_tokenOffset + n 5479"];
5479 [label="_tokenOffset + n >= _tokenCount 5480"];
5480 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5481"];
5481 [label="this.PeekToken(peekIndex).Kind 5482"];
5482 [label="get { return (SyntaxKind)this.RawKind; } 5483"];
5483 [label="this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken 5484"];
5484 [label="if (this.PeekToken(peekIndex).Kind == SyntaxKind.OpenParenToken)\n            {\n                // We only got into IsPossibleLambdaExpression if we saw 'static' or an identifier.\n                // So if we're now on ( then we must have been on 'static' in order to have moved\n                // past those.\n                Contract.Requires(seenStatic);\n\n                // 1. `static (...\n                // 2. `async static (...\n                return true;\n            } 5485"];
5485 [label="peekIndex 5486"];
5486 [label="this.PeekToken(peekIndex) 5487"];
5487 [label="param PeekToken(int n) 5488"];
5488 [label="param PeekToken(this) 5489"];
5489 [label="0 5490"];
5490 [label="n >= 0 5491"];
5491 [label="Debug.Assert(n >= 0) 5492"];
5492 [label="_tokenOffset + n 5493"];
5493 [label="_tokenOffset + n >= _tokenCount 5494"];
5494 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5495"];
5495 [label="this.PeekToken(peekIndex).ContextualKind 5496"];
5496 [label="get\n            {\n                return this.Kind;\n            } 5497"];
5497 [label="this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword 5498"];
5498 [label="if (this.PeekToken(peekIndex).ContextualKind != SyntaxKind.AsyncKeyword)\n            {\n                return false;\n            } 5499"];
5499 [label="false 5500"];
5500 [label="return false; 5501"];
5501 [label="if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 5502"];
5502 [label="precedence 5503"];
5503 [label="this.IsPossibleDeconstructionLeft(precedence) 5504"];
5504 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 5505"];
5505 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        } 5506"];
5506 [label="NameOptions.InExpression 5507"];
5507 [label="this.ParseAliasQualifiedName(NameOptions.InExpression) 5508"];
5508 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 5509"];
5509 [label="param ParseAliasQualifiedName(this) 5510"];
5510 [label="allowedParts 5511"];
5511 [label="this.ParseSimpleName(allowedParts) 5512"];
5512 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 5513"];
5513 [label="param ParseSimpleName(this) 5514"];
5514 [label="this.ParseIdentifierName() 5515"];
5515 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 5516"];
5516 [label="param ParseIdentifierName(this) 5517"];
5517 [label="this.IsIncrementalAndFactoryContextMatches 5518"];
5518 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 5519"];
5519 [label="base.IsIncremental 5520"];
5520 [label="get\n            {\n                return _isIncremental;\n            } 5521"];
5521 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 5522"];
5522 [label="false 5523"];
5523 [label="return false; 5524"];
5524 [label="this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName 5525"];
5525 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 5526"];
5526 [label="code 5527"];
5527 [label="ParseIdentifierToken(code) 5528"];
5528 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 5529"];
5529 [label="param ParseIdentifierToken(this) 5530"];
5530 [label="this.CurrentToken 5531"];
5531 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5532"];
5532 [label="this.CurrentToken.Kind 5533"];
5533 [label="get { return (SyntaxKind)this.RawKind; } 5534"];
5534 [label="ctk = this.CurrentToken.Kind 5535"];
5535 [label="ctk == SyntaxKind.IdentifierToken 5536"];
5536 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 5537"];
5537 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 5538"];
5538 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 5539"];
5539 [label="this.CurrentToken 5540"];
5540 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5541"];
5541 [label="this.CurrentToken.ContextualKind 5542"];
5542 [label="get\n            {\n                return this.Kind;\n            } 5543"];
5543 [label="this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword 5544"];
5544 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 5545"];
5545 [label="IsCurrentTokenQueryKeywordInQuery() 5546"];
5546 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery() 5547"];
5547 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 5548"];
5548 [label="this.EatToken() 5549"];
5549 [label="param EatToken(this) 5550"];
5550 [label="this.CurrentToken 5551"];
5551 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5552"];
5552 [label="ct = this.CurrentToken 5553"];
5553 [label="MoveToNextToken() 5554"];
5554 [label="param MoveToNextToken(this) 5555"];
5555 [label="_currentToken.GetTrailingTrivia() 5556"];
5556 [label="param GetTrailingTrivia(this) 5557"];
5557 [label="null 5558"];
5558 [label="return null; 5559"];
5559 [label="_prevTokenTrailingTrivia 5560"];
5560 [label="null 5561"];
5561 [label="_currentToken 5562"];
5562 [label="null 5563"];
5563 [label="_blendedTokens != null 5564"];
5564 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 5565"];
5565 [label="_tokenOffset 5566"];
5566 [label="return ct; 5567"];
5567 [label="identifierToken = this.EatToken() 5568"];
5568 [label="this.IsInAsync 5569"];
5569 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 5570"];
5570 [label="return _syntaxFactoryContext.IsInAsync; 5571"];
5571 [label="this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword 5572"];
5572 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 5573"];
5573 [label="return identifierToken; 5574"];
5574 [label="tk = ParseIdentifierToken(code) 5575"];
5575 [label="tk 5576"];
5576 [label="SyntaxFactory.IdentifierName(tk) 5577"];
5577 [label="SyntaxFactory.IdentifierName(tk) 5578"];
5578 [label="param CSharpSyntaxNode(SyntaxKind kind) 5579"];
5579 [label="param CSharpSyntaxNode(this) 5580"];
5580 [label="kind 5581"];
5581 [label="param CSharpSyntaxNode(this) 5582"];
5582 [label="param CSharpSyntaxNode(this) 5583"];
5583 [label="this 5584"];
5584 [label="GreenStats.NoteGreen(this) 5585"];
5585 [label="return SyntaxFactory.IdentifierName(tk); 5586"];
5586 [label="id = this.ParseIdentifierName() 5587"];
5587 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 5588"];
5588 [label="name = id 5589"];
5589 [label="this.CurrentToken 5590"];
5590 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5591"];
5591 [label="_tokenOffset >= _tokenCount 5592"];
5592 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5593"];
5593 [label="_blendedTokens != null 5594"];
5594 [label="this.CurrentToken.Kind 5595"];
5595 [label="get { return (SyntaxKind)this.RawKind; } 5596"];
5596 [label="this.CurrentToken.Kind == SyntaxKind.LessThanToken 5597"];
5597 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 5598"];
5598 [label="return name; 5599"];
5599 [label="name = this.ParseSimpleName(allowedParts) 5600"];
5600 [label="this.CurrentToken 5601"];
5601 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5602"];
5602 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 5603"];
5603 [label="this.CurrentToken.Kind 5604"];
5604 [label="get { return (SyntaxKind)this.RawKind; } 5605"];
5605 [label="this.CurrentToken.Kind == SyntaxKind.ColonColonToken 5606"];
5606 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 5607"];
5607 [label="return name; 5608"];
5608 [label="return this.ParseAliasQualifiedName(NameOptions.InExpression); 5609"];
5609 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 5610"];
5610 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 5611"];
5611 [label="param ParseParenthesizedArgumentList(this) 5612"];
5612 [label="this.IsIncrementalAndFactoryContextMatches 5613"];
5613 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 5614"];
5614 [label="base.IsIncremental 5615"];
5615 [label="get\n            {\n                return _isIncremental;\n            } 5616"];
5616 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 5617"];
5617 [label="false 5618"];
5618 [label="return false; 5619"];
5619 [label="this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList 5620"];
5620 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.ArgumentList)\n            {\n                return (ArgumentListSyntax)this.EatNode();\n            } 5621"];
5621 [label="openToken 5622"];
5622 [label="openToken: out SyntaxToken openToken 5623"];
5623 [label="arguments 5624"];
5624 [label="arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments 5625"];
5625 [label="closeToken 5626"];
5626 [label="closeToken: out SyntaxToken closeToken 5627"];
5627 [label="openKind: SyntaxKind.OpenParenToken 5628"];
5628 [label="closeKind: SyntaxKind.CloseParenToken 5629"];
5629 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken) 5630"];
5630 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken) 5631"];
5631 [label="param EatTokenAsKind(SyntaxKind expected) 5632"];
5632 [label="param EatTokenAsKind(this) 5633"];
5633 [label="expected 5634"];
5634 [label="SyntaxFacts.IsAnyToken(expected) 5635"];
5635 [label="param IsAnyToken(SyntaxKind kind) 5636"];
5636 [label="kind >= SyntaxKind.TildeToken 5637"];
5637 [label="kind < SyntaxKind.EndOfLineTrivia 5638"];
5638 [label="kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia 5639"];
5639 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 5640"];
5640 [label="true 5641"];
5641 [label="return true; 5642"];
5642 [label="Debug.Assert(SyntaxFacts.IsAnyToken(expected)) 5643"];
5643 [label="this.CurrentToken 5644"];
5644 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5645"];
5645 [label="ct = this.CurrentToken 5646"];
5646 [label="ct.Kind 5647"];
5647 [label="get { return (SyntaxKind)this.RawKind; } 5648"];
5648 [label="ct.Kind == expected 5649"];
5649 [label="if (ct.Kind == expected)\n            {\n                MoveToNextToken();\n                return ct;\n            } 5650"];
5650 [label="MoveToNextToken() 5651"];
5651 [label="param GetTrailingTrivia(this) 5652"];
5652 [label="null 5653"];
5653 [label="_blendedTokens != null 5654"];
5654 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 5655"];
5655 [label="return ct; 5656"];
5656 [label="ParseArgumentList(\n                openToken: out SyntaxToken openToken,\n                arguments: out SeparatedSyntaxList<ArgumentSyntax> arguments,\n                closeToken: out SyntaxToken closeToken,\n                openKind: SyntaxKind.OpenParenToken,\n                closeKind: SyntaxKind.CloseParenToken) 5657"];
5657 [label="_tokenOffset >= _tokenCount 5658"];
5658 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5659"];
5659 [label="param GetTrailingTrivia(this) 5660"];
5660 [label="null 5661"];
5661 [label="_blendedTokens != null 5662"];
5662 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 5663"];
5663 [label="openToken 5664"];
5664 [label="arguments 5665"];
5665 [label="closeToken 5666"];
5666 [label="_syntaxFactory.ArgumentList(openToken, arguments, closeToken) 5667"];
5667 [label="_syntaxFactory.ArgumentList(openToken, arguments, closeToken) 5668"];
5668 [label="param TryGetNode(int kind) 5669"];
5669 [label="param TryGetNode(GreenNode child1) 5670"];
5670 [label="param TryGetNode(GreenNode child2) 5671"];
5671 [label="param TryGetNode(GreenNode child3) 5672"];
5672 [label="param TryGetNode(SyntaxFactoryContext context) 5673"];
5673 [label="param TryGetNode(out int hash) 5674"];
5674 [label="kind 5675"];
5675 [label="child1 5676"];
5676 [label="child2 5677"];
5677 [label="child3 5678"];
5678 [label="context 5679"];
5679 [label="GetNodeFlags(context) 5680"];
5680 [label="param GetNodeFlags(SyntaxFactoryContext context) 5681"];
5681 [label="SyntaxNodeCache.GetDefaultNodeFlags() 5682"];
5682 [label="flags = SyntaxNodeCache.GetDefaultNodeFlags() 5683"];
5683 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 5684"];
5684 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 5685"];
5685 [label="return flags; 5686"];
5686 [label="out hash 5687"];
5687 [label="SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash) 5688"];
5688 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 5689"];
5689 [label="param CSharpSyntaxNode(this) 5690"];
5690 [label="this 5691"];
5691 [label="param SetFactoryContext(SyntaxFactoryContext context) 5692"];
5692 [label="param SetFactoryContext(this) 5693"];
5693 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 5694"];
5694 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 5695"];
5695 [label="return _syntaxFactory.ArgumentList(openToken, arguments, closeToken); 5696"];
5696 [label="param TryGetNode(int kind) 5697"];
5697 [label="param TryGetNode(GreenNode child1) 5698"];
5698 [label="param TryGetNode(GreenNode child2) 5699"];
5699 [label="param TryGetNode(SyntaxFactoryContext context) 5700"];
5700 [label="param TryGetNode(out int hash) 5701"];
5701 [label="kind 5702"];
5702 [label="child1 5703"];
5703 [label="child2 5704"];
5704 [label="context 5705"];
5705 [label="GetNodeFlags(context) 5706"];
5706 [label="param GetNodeFlags(SyntaxFactoryContext context) 5707"];
5707 [label="SyntaxNodeCache.GetDefaultNodeFlags() 5708"];
5708 [label="flags = SyntaxNodeCache.GetDefaultNodeFlags() 5709"];
5709 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 5710"];
5710 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 5711"];
5711 [label="return flags; 5712"];
5712 [label="out hash 5713"];
5713 [label="SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash) 5714"];
5714 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 5715"];
5715 [label="param CSharpSyntaxNode(this) 5716"];
5716 [label="this 5717"];
5717 [label="param SetFactoryContext(SyntaxFactoryContext context) 5718"];
5718 [label="param SetFactoryContext(this) 5719"];
5719 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 5720"];
5720 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 5721"];
5721 [label="_tokenOffset >= _tokenCount 5722"];
5722 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5723"];
5723 [label="leftOperand 5724"];
5724 [label="leftOperand 5725"];
5725 [label="precedence 5726"];
5726 [label="ParseExpressionContinued(leftOperand, precedence) 5727"];
5727 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 5728"];
5728 [label="param ParseExpressionContinued(Precedence precedence) 5729"];
5729 [label="param ParseExpressionContinued(this) 5730"];
5730 [label="true 5731"];
5731 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 5732"];
5732 [label="this.CurrentToken 5733"];
5733 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5734"];
5734 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 5735"];
5735 [label="this.CurrentToken.ContextualKind 5736"];
5736 [label="get\n            {\n                return this.Kind;\n            } 5737"];
5737 [label="tk = this.CurrentToken.ContextualKind 5738"];
5738 [label="false 5739"];
5739 [label="isAssignmentOperator = false 5740"];
5740 [label="opKind 5741"];
5741 [label="tk 5742"];
5742 [label="IsExpectedBinaryOperator(tk) 5743"];
5743 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 5744"];
5744 [label="kind 5745"];
5745 [label="SyntaxFacts.IsBinaryExpression(kind) 5746"];
5746 [label="param IsBinaryExpression(SyntaxKind token) 5747"];
5747 [label="token 5748"];
5748 [label="GetBinaryExpression(token) 5749"];
5749 [label="param GetBinaryExpression(SyntaxKind token) 5750"];
5750 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 5751"];
5751 [label="return SyntaxKind.None; 5752"];
5752 [label="GetBinaryExpression(token) != SyntaxKind.None 5753"];
5753 [label="return GetBinaryExpression(token) != SyntaxKind.None; 5754"];
5754 [label="return SyntaxFacts.IsBinaryExpression(kind); 5755"];
5755 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 5756"];
5756 [label="tk 5757"];
5757 [label="IsExpectedAssignmentOperator(tk) 5758"];
5758 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 5759"];
5759 [label="kind 5760"];
5760 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 5761"];
5761 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 5762"];
5762 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 5763"];
5763 [label="false 5764"];
5764 [label="return false; 5765"];
5765 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 5766"];
5766 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 5767"];
5767 [label="tk == SyntaxKind.DotDotToken 5768"];
5768 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 5769"];
5769 [label="tk == SyntaxKind.SwitchKeyword 5770"];
5770 [label="tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken 5771"];
5771 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 5772"];
5772 [label="tk == SyntaxKind.WithKeyword 5773"];
5773 [label="tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken 5774"];
5774 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 5775"];
5775 [label="CurrentToken 5776"];
5776 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5777"];
5777 [label="_currentToken ?? (_currentToken = this.FetchCurrentToken()) 5778"];
5778 [label="CurrentToken.Kind 5779"];
5779 [label="get { return (SyntaxKind)this.RawKind; } 5780"];
5780 [label="CurrentToken.Kind == SyntaxKind.QuestionToken 5781"];
5781 [label="CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional 5782"];
5782 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 5783"];
5783 [label="return leftOperand; 5784"];
5784 [label="return ParseExpressionContinued(leftOperand, precedence); 5785"];
5785 [label="result = ParseSubExpressionCore(precedence) 5786"];
5786 [label="_ 5787"];
5787 [label="result.Kind 5788"];
5788 [label="get { return (SyntaxKind)this.RawKind; } 5789"];
5789 [label="GetPrecedence(result.Kind) 5790"];
5790 [label="param GetPrecedence(SyntaxKind op) 5791"];
5791 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 5792"];
5792 [label="return Precedence.Primary; 5793"];
5793 [label="_ 5794"];
5794 [label="_recursionDepth 5795"];
5795 [label="return result; 5796"];
5796 [label="return this.ParseSubExpression(Precedence.Expression); 5797"];
5797 [label="ParseExpressionStatement(attributes, this.ParseExpressionCore()) 5798"];
5798 [label="param ParseExpressionStatement(SyntaxList<AttributeListSyntax> attributes) 5799"];
5799 [label="param ParseExpressionStatement(ExpressionSyntax expression) 5800"];
5800 [label="param ParseExpressionStatement(this) 5801"];
5801 [label="semicolon 5802"];
5802 [label="IsScript 5803"];
5803 [label="get { return Options.Kind == SourceCodeKind.Script; } 5804"];
5804 [label="Options 5805"];
5805 [label="get { return this.lexer.Options; } 5806"];
5806 [label="this.lexer.Options 5807"];
5807 [label="get { return _options; } 5808"];
5808 [label="return _options; 5809"];
5809 [label="return this.lexer.Options; 5810"];
5810 [label="Options.Kind == SourceCodeKind.Script 5811"];
5811 [label="return Options.Kind == SourceCodeKind.Script; 5812"];
5812 [label="IsScript && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken 5813"];
5813 [label="if (IsScript && this.CurrentToken.Kind == SyntaxKind.EndOfFileToken)\n            {\n                semicolon = SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken);\n            }\n            else\n            {\n                // Do not report an error if the expression is not a statement expression.\n                // The error is reported in semantic analysis.\n                semicolon = this.EatToken(SyntaxKind.SemicolonToken);\n            } 5814"];
5814 [label="SyntaxKind.SemicolonToken 5815"];
5815 [label="this.EatToken(SyntaxKind.SemicolonToken) 5816"];
5816 [label="param EatToken(SyntaxKind kind) 5817"];
5817 [label="param EatToken(this) 5818"];
5818 [label="kind 5819"];
5819 [label="SyntaxFacts.IsAnyToken(kind) 5820"];
5820 [label="param IsAnyToken(SyntaxKind kind) 5821"];
5821 [label="kind >= SyntaxKind.TildeToken 5822"];
5822 [label="kind < SyntaxKind.EndOfLineTrivia 5823"];
5823 [label="kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia 5824"];
5824 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 5825"];
5825 [label="true 5826"];
5826 [label="return true; 5827"];
5827 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)) 5828"];
5828 [label="this.CurrentToken 5829"];
5829 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5830"];
5830 [label="ct = this.CurrentToken 5831"];
5831 [label="ct.Kind 5832"];
5832 [label="get { return (SyntaxKind)this.RawKind; } 5833"];
5833 [label="ct.Kind == kind 5834"];
5834 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 5835"];
5835 [label="MoveToNextToken() 5836"];
5836 [label="param GetTrailingTrivia(this) 5837"];
5837 [label="null 5838"];
5838 [label="_blendedTokens != null 5839"];
5839 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 5840"];
5840 [label="return ct; 5841"];
5841 [label="semicolon 5842"];
5842 [label="attributes 5843"];
5843 [label="expression 5844"];
5844 [label="semicolon 5845"];
5845 [label="_syntaxFactory.ExpressionStatement(attributes, expression, semicolon) 5846"];
5846 [label="_syntaxFactory.ExpressionStatement(attributes, expression, semicolon) 5847"];
5847 [label="param TryGetNode(SyntaxFactoryContext context) 5848"];
5848 [label="context 5849"];
5849 [label="GetNodeFlags(context) 5850"];
5850 [label="param GetNodeFlags(SyntaxFactoryContext context) 5851"];
5851 [label="SyntaxNodeCache.GetDefaultNodeFlags() 5852"];
5852 [label="flags = SyntaxNodeCache.GetDefaultNodeFlags() 5853"];
5853 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 5854"];
5854 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 5855"];
5855 [label="return flags; 5856"];
5856 [label="param CSharpSyntaxNode(this) 5857"];
5857 [label="this 5858"];
5858 [label="param SetFactoryContext(SyntaxFactoryContext context) 5859"];
5859 [label="param SetFactoryContext(this) 5860"];
5860 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 5861"];
5861 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 5862"];
5862 [label="return _syntaxFactory.ExpressionStatement(attributes, expression, semicolon); 5863"];
5863 [label="return ParseExpressionStatement(attributes, this.ParseExpressionCore()); 5864"];
5864 [label="return this.ParseExpressionStatement(attributes); 5865"];
5865 [label="return ParseStatementCoreRest(attributes, isGlobal, ref resetPointBeforeStatement); 5866"];
5866 [label="_recursionDepth 5867"];
5867 [label="ref resetPointBeforeStatement 5868"];
5868 [label="this.Release(ref resetPointBeforeStatement) 5869"];
5869 [label="param Release(ref ResetPoint state) 5870"];
5870 [label="param Release(this) 5871"];
5871 [label="ref state.BaseResetPoint 5872"];
5872 [label="base.Release(ref state.BaseResetPoint) 5873"];
5873 [label="param Release(ref ResetPoint point) 5874"];
5874 [label="param Release(this) 5875"];
5875 [label="_resetCount == point.ResetCount 5876"];
5876 [label="Debug.Assert(_resetCount == point.ResetCount) 5877"];
5877 [label="_resetCount 5878"];
5878 [label="0 5879"];
5879 [label="_resetCount == 0 5880"];
5880 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 5881"];
5881 [label="1 5882"];
5882 [label="_resetStart 5883"];
5883 [label="parseFunc() 5884"];
5884 [label="return parseFunc(); 5885"];
5885 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 5886"];
5886 [label="node = parser.ParseStatement() 5887"];
5887 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 5888"];
5888 [label="node 5889"];
5889 [label="parser.ConsumeUnexpectedTokens(node) 5890"];
5890 [label="param ConsumeUnexpectedTokens(TNode node) 5891"];
5891 [label="param ConsumeUnexpectedTokens(this) 5892"];
5892 [label="this.CurrentToken 5893"];
5893 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 5894"];
5894 [label="this.FetchCurrentToken() 5895"];
5895 [label="param FetchCurrentToken(this) 5896"];
5896 [label="_tokenOffset >= _tokenCount 5897"];
5897 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 5898"];
5898 [label="null 5899"];
5899 [label="_blendedTokens != null 5900"];
5900 [label="this.CurrentToken.Kind 5901"];
5901 [label="get { return (SyntaxKind)this.RawKind; } 5902"];
5902 [label="this.CurrentToken.Kind == SyntaxKind.EndOfFileToken 5903"];
5903 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 5904"];
5904 [label="return node; 5905"];
5905 [label="node 5906"];
5906 [label="node.CreateRed() 5907"];
5907 [label="node.CreateRed() 5908"];
5908 [label="node.CreateRed() 5909"];
5909 [label="param CSharpSyntaxNode(GreenNode green) 5910"];
5910 [label="param CSharpSyntaxNode(SyntaxNode? parent) 5911"];
5911 [label="param CSharpSyntaxNode(int position) 5912"];
5912 [label="param CSharpSyntaxNode(this) 5913"];
5913 [label="green 5914"];
5914 [label="parent 5915"];
5915 [label="position 5916"];
5916 [label="param CSharpSyntaxNode(this) 5917"];
5917 [label="param CSharpSyntaxNode(this) 5918"];
5918 [label="return (StatementSyntax)node.CreateRed(); 5919"];
5919 [label="return SyntaxFactory.ParseStatement(text, offset, options); 5920"];
5920 [label="statement = this.ParseStatement(text) 5921"];
5921 [label="statement 5922"];
5922 [label="Assert.NotNull(statement) 5923"];
5923 [label="SyntaxKind.ExpressionStatement 5924"];
5924 [label="statement.Kind() 5925"];
5925 [label="param Kind(this) 5926"];
5926 [label="return (SyntaxKind)this.Green.RawKind; 5927"];
5927 [label="Assert.Equal(SyntaxKind.ExpressionStatement, statement.Kind()) 5928"];
5928 [label="text 5929"];
5929 [label="statement.ToString() 5930"];
5930 [label="statement.ToString() 5931"];
5931 [label="=> true 5932"];
5932 [label="true 5933"];
5933 [label="statement.ToString() 5934"];
5934 [label="param WriteTokenTo(System.IO.TextWriter writer) 5935"];
5935 [label="param WriteTokenTo(bool leading) 5936"];
5936 [label="param WriteTokenTo(bool trailing) 5937"];
5937 [label="param WriteTokenTo(this) 5938"];
5938 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 5939"];
5939 [label="this.Text 5940"];
5940 [label="writer.Write(this.Text) 5941"];
5941 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 5942"];
5942 [label="this.GetTrailingTrivia() 5943"];
5943 [label="param GetTrailingTrivia(this) 5944"];
5944 [label="trivia = this.GetTrailingTrivia() 5945"];
5945 [label="null 5946"];
5946 [label="trivia != null 5947"];
5947 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 5948"];
5948 [label="this.GetLeadingTrivia() 5949"];
5949 [label="param GetLeadingTrivia(this) 5950"];
5950 [label="null 5951"];
5951 [label="return null; 5952"];
5952 [label="trivia = this.GetLeadingTrivia() 5953"];
5953 [label="null 5954"];
5954 [label="trivia != null 5955"];
5955 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 5956"];
5956 [label="this.Text 5957"];
5957 [label="get { return SyntaxFacts.GetText(this.Kind); } 5958"];
5958 [label="this.Kind 5959"];
5959 [label="get { return (SyntaxKind)this.RawKind; } 5960"];
5960 [label="return (SyntaxKind)this.RawKind; 5961"];
5961 [label="SyntaxFacts.GetText(this.Kind) 5962"];
5962 [label="param GetText(SyntaxKind kind) 5963"];
5963 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 5964"];
5964 [label="'(' 5965"];
5965 [label="return '('; 5966"];
5966 [label="return SyntaxFacts.GetText(this.Kind); 5967"];
5967 [label="')' 5968"];
5968 [label="return ')'; 5969"];
5969 [label="';' 5970"];
5970 [label="return ';'; 5971"];
5971 [label="Assert.Equal(text, statement.ToString()) 5972"];
5972 [label="0 5973"];
5973 [label="statement 5974"];
5974 [label="statement.Errors() 5975"];
5975 [label="param Errors(this SyntaxNode node) 5976"];
5976 [label="node.Green 5977"];
5977 [label="true 5978"];
5978 [label="errorsOnly: true 5979"];
5979 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 5980"];
5980 [label="param ErrorsOrWarnings(this GreenNode node) 5981"];
5981 [label="param ErrorsOrWarnings(bool errorsOnly) 5982"];
5982 [label="ArrayBuilder<DiagnosticInfo>.GetInstance() 5983"];
5983 [label="b = ArrayBuilder<DiagnosticInfo>.GetInstance() 5984"];
5984 [label="node 5985"];
5985 [label="new SyntaxDiagnosticInfoList(node) 5986"];
5986 [label="l = new SyntaxDiagnosticInfoList(node) 5987"];
5987 [label="l 5988"];
5988 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 5989"];
5989 [label="b.ToImmutableAndFree() 5990"];
5990 [label="return b.ToImmutableAndFree(); 5991"];
5991 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 5992"];
5992 [label="statement.Errors().Length 5993"];
5993 [label="Assert.Equal(0, statement.Errors().Length) 5994"];
20 -> 0;
21 -> 20;
21 -> 0;
26 -> 25;
27 -> 24;
28 -> 23;
29 -> 22;
30 -> 21;
31 -> 19;
32 -> 18;
33 -> 17;
34 -> 16;
35 -> 15;
36 -> 14;
37 -> 13;
38 -> 12;
39 -> 11;
40 -> 10;
41 -> 9;
42 -> 8;
43 -> 7;
44 -> 6;
45 -> 5;
46 -> 4;
47 -> 3;
48 -> 2;
49 -> 1;
51 -> 50;
52 -> 50;
53 -> 51;
53 -> 50;
54 -> 53;
54 -> 52;
55 -> 52;
56 -> 55;
57 -> 55;
57 -> 52;
58 -> 55;
58 -> 52;
59 -> 55;
59 -> 52;
60 -> 54;
60 -> 55;
60 -> 52;
61 -> 50;
61 -> 56;
61 -> 57;
61 -> 58;
61 -> 59;
61 -> 60;
62 -> 50;
63 -> 50;
64 -> 63;
64 -> 50;
65 -> 64;
65 -> 50;
66 -> 50;
67 -> 65;
67 -> 66;
68 -> 66;
69 -> 66;
70 -> 62;
70 -> 66;
71 -> 67;
71 -> 66;
72 -> 68;
72 -> 66;
73 -> 69;
73 -> 66;
74 -> 66;
75 -> 71;
75 -> 74;
76 -> 72;
76 -> 74;
77 -> 73;
77 -> 74;
78 -> 74;
79 -> 75;
79 -> 74;
80 -> 76;
80 -> 74;
81 -> 77;
81 -> 74;
82 -> 74;
83 -> 79;
83 -> 82;
84 -> 80;
84 -> 82;
85 -> 81;
85 -> 82;
86 -> 83;
86 -> 82;
87 -> 84;
87 -> 82;
88 -> 82;
89 -> 86;
89 -> 88;
90 -> 87;
90 -> 88;
91 -> 89;
91 -> 88;
92 -> 0;
92 -> 88;
93 -> 88;
94 -> 91;
94 -> 92;
94 -> 93;
94 -> 0;
94 -> 88;
95 -> 90;
95 -> 88;
96 -> 94;
96 -> 95;
96 -> 88;
97 -> 96;
97 -> 88;
98 -> 97;
98 -> 82;
100 -> 99;
101 -> 99;
102 -> 99;
103 -> 99;
104 -> 99;
105 -> 100;
105 -> 99;
106 -> 101;
106 -> 99;
107 -> 102;
107 -> 99;
108 -> 103;
108 -> 99;
109 -> 108;
109 -> 99;
110 -> 0;
110 -> 99;
111 -> 105;
111 -> 104;
112 -> 106;
112 -> 104;
113 -> 107;
113 -> 104;
114 -> 109;
114 -> 104;
115 -> 110;
115 -> 104;
116 -> 104;
117 -> 113;
117 -> 104;
118 -> 112;
118 -> 104;
119 -> 116;
119 -> 117;
119 -> 118;
119 -> 104;
120 -> 116;
120 -> 104;
121 -> 116;
121 -> 104;
122 -> 116;
122 -> 104;
123 -> 111;
123 -> 116;
123 -> 104;
124 -> 111;
124 -> 104;
125 -> 104;
126 -> 124;
126 -> 125;
127 -> 126;
127 -> 125;
128 -> 0;
128 -> 127;
129 -> 128;
129 -> 116;
129 -> 104;
130 -> 114;
130 -> 104;
131 -> 130;
131 -> 109;
131 -> 104;
132 -> 131;
132 -> 116;
132 -> 104;
133 -> 115;
133 -> 104;
134 -> 133;
134 -> 0;
134 -> 104;
135 -> 0;
135 -> 104;
136 -> 135;
136 -> 134;
136 -> 104;
137 -> 136;
137 -> 116;
137 -> 104;
138 -> 99;
145 -> 144;
155 -> 146;
155 -> 143;
156 -> 147;
156 -> 143;
157 -> 148;
157 -> 143;
158 -> 149;
158 -> 143;
159 -> 150;
159 -> 143;
160 -> 151;
160 -> 143;
161 -> 152;
161 -> 143;
162 -> 153;
162 -> 143;
163 -> 154;
163 -> 143;
164 -> 143;
165 -> 142;
166 -> 141;
167 -> 139;
168 -> 138;
168 -> 82;
169 -> 168;
169 -> 85;
169 -> 82;
170 -> 169;
170 -> 82;
171 -> 82;
172 -> 98;
172 -> 171;
173 -> 170;
173 -> 171;
174 -> 171;
175 -> 171;
176 -> 171;
177 -> 172;
177 -> 171;
178 -> 177;
178 -> 176;
179 -> 176;
180 -> 179;
180 -> 176;
181 -> 179;
181 -> 176;
184 -> 183;
185 -> 184;
186 -> 182;
187 -> 0;
188 -> 178;
188 -> 176;
189 -> 176;
190 -> 188;
190 -> 189;
191 -> 189;
192 -> 191;
192 -> 189;
193 -> 191;
193 -> 189;
194 -> 191;
194 -> 189;
195 -> 191;
195 -> 189;
196 -> 191;
196 -> 189;
197 -> 191;
197 -> 189;
198 -> 191;
198 -> 189;
199 -> 191;
199 -> 189;
200 -> 190;
200 -> 191;
200 -> 189;
201 -> 189;
202 -> 201;
202 -> 191;
202 -> 189;
203 -> 189;
204 -> 203;
204 -> 191;
204 -> 189;
205 -> 190;
205 -> 96;
205 -> 191;
205 -> 189;
206 -> 189;
207 -> 206;
207 -> 191;
207 -> 189;
208 -> 185;
208 -> 184;
208 -> 189;
209 -> 208;
209 -> 191;
209 -> 189;
210 -> 189;
211 -> 210;
211 -> 191;
211 -> 189;
212 -> 189;
212 -> 179;
212 -> 176;
213 -> 176;
213 -> 171;
214 -> 176;
214 -> 171;
215 -> 176;
215 -> 171;
216 -> 176;
216 -> 171;
217 -> 176;
217 -> 171;
218 -> 176;
218 -> 171;
219 -> 176;
219 -> 171;
220 -> 176;
220 -> 171;
221 -> 176;
221 -> 171;
222 -> 176;
222 -> 171;
223 -> 171;
224 -> 223;
224 -> 171;
225 -> 224;
225 -> 176;
225 -> 171;
226 -> 171;
227 -> 226;
227 -> 171;
228 -> 227;
228 -> 176;
228 -> 171;
229 -> 176;
229 -> 171;
230 -> 176;
230 -> 171;
231 -> 171;
232 -> 173;
232 -> 231;
232 -> 171;
233 -> 232;
233 -> 171;
234 -> 173;
234 -> 176;
234 -> 171;
235 -> 171;
236 -> 235;
236 -> 176;
236 -> 171;
237 -> 171;
238 -> 237;
238 -> 171;
239 -> 238;
239 -> 176;
239 -> 171;
242 -> 240;
242 -> 241;
244 -> 243;
245 -> 242;
246 -> 171;
247 -> 246;
248 -> 247;
248 -> 246;
249 -> 247;
249 -> 246;
250 -> 247;
250 -> 246;
251 -> 246;
252 -> 251;
252 -> 247;
252 -> 246;
253 -> 246;
254 -> 253;
254 -> 247;
254 -> 246;
255 -> 245;
255 -> 242;
255 -> 246;
256 -> 255;
256 -> 247;
256 -> 246;
257 -> 246;
257 -> 176;
257 -> 171;
258 -> 176;
258 -> 171;
259 -> 174;
259 -> 176;
259 -> 171;
260 -> 175;
260 -> 176;
260 -> 171;
261 -> 171;
261 -> 82;
262 -> 261;
262 -> 74;
263 -> 262;
263 -> 74;
264 -> 74;
265 -> 263;
265 -> 264;
266 -> 0;
267 -> 265;
267 -> 264;
268 -> 264;
269 -> 268;
269 -> 264;
270 -> 264;
271 -> 270;
271 -> 264;
272 -> 264;
273 -> 267;
273 -> 272;
274 -> 269;
274 -> 272;
275 -> 271;
275 -> 272;
276 -> 272;
277 -> 272;
278 -> 272;
281 -> 279;
281 -> 280;
282 -> 281;
283 -> 273;
283 -> 272;
284 -> 276;
284 -> 272;
285 -> 274;
285 -> 272;
286 -> 275;
286 -> 272;
287 -> 272;
288 -> 272;
289 -> 277;
289 -> 272;
290 -> 283;
290 -> 278;
291 -> 284;
291 -> 278;
292 -> 285;
292 -> 278;
293 -> 286;
293 -> 278;
294 -> 287;
294 -> 278;
295 -> 288;
295 -> 278;
296 -> 289;
296 -> 278;
297 -> 278;
298 -> 297;
298 -> 278;
299 -> 297;
299 -> 278;
300 -> 297;
300 -> 278;
301 -> 297;
301 -> 278;
302 -> 297;
302 -> 278;
303 -> 297;
303 -> 278;
304 -> 297;
304 -> 278;
305 -> 297;
305 -> 278;
306 -> 297;
306 -> 278;
307 -> 297;
307 -> 278;
308 -> 297;
308 -> 278;
309 -> 297;
309 -> 278;
310 -> 297;
310 -> 278;
311 -> 290;
311 -> 297;
311 -> 278;
312 -> 291;
312 -> 297;
312 -> 278;
313 -> 294;
313 -> 297;
313 -> 278;
314 -> 296;
314 -> 297;
314 -> 278;
315 -> 278;
316 -> 315;
316 -> 297;
316 -> 278;
317 -> 278;
318 -> 292;
318 -> 317;
318 -> 278;
319 -> 318;
319 -> 297;
319 -> 278;
320 -> 278;
321 -> 297;
321 -> 320;
322 -> 321;
322 -> 319;
322 -> 320;
323 -> 322;
323 -> 294;
323 -> 278;
324 -> 323;
324 -> 278;
325 -> 324;
326 -> 325;
326 -> 297;
326 -> 324;
327 -> 324;
328 -> 327;
328 -> 324;
329 -> 328;
329 -> 297;
329 -> 324;
330 -> 278;
331 -> 297;
331 -> 330;
332 -> 331;
332 -> 319;
332 -> 330;
333 -> 295;
333 -> 332;
333 -> 278;
334 -> 333;
334 -> 296;
334 -> 278;
335 -> 334;
335 -> 278;
336 -> 335;
337 -> 297;
337 -> 336;
338 -> 336;
339 -> 336;
340 -> 336;
341 -> 337;
341 -> 311;
341 -> 212;
341 -> 340;
342 -> 341;
342 -> 200;
342 -> 340;
343 -> 336;
344 -> 342;
344 -> 96;
344 -> 343;
344 -> 336;
345 -> 339;
345 -> 344;
345 -> 336;
346 -> 338;
346 -> 345;
346 -> 336;
347 -> 346;
347 -> 336;
348 -> 347;
348 -> 336;
349 -> 348;
349 -> 337;
349 -> 336;
350 -> 337;
350 -> 311;
350 -> 336;
351 -> 337;
351 -> 312;
351 -> 336;
352 -> 336;
353 -> 352;
353 -> 336;
354 -> 353;
354 -> 347;
354 -> 336;
355 -> 354;
355 -> 336;
356 -> 351;
356 -> 355;
357 -> 355;
358 -> 356;
358 -> 357;
359 -> 350;
359 -> 357;
360 -> 140;
360 -> 357;
361 -> 358;
361 -> 359;
361 -> 357;
362 -> 359;
362 -> 361;
362 -> 357;
363 -> 359;
363 -> 212;
363 -> 181;
363 -> 234;
363 -> 361;
363 -> 236;
363 -> 239;
363 -> 217;
363 -> 257;
363 -> 259;
363 -> 260;
363 -> 221;
363 -> 222;
363 -> 225;
363 -> 228;
363 -> 229;
363 -> 258;
363 -> 200;
363 -> 202;
363 -> 204;
363 -> 205;
363 -> 209;
363 -> 197;
363 -> 211;
363 -> 207;
363 -> 96;
363 -> 224;
363 -> 227;
363 -> 119;
363 -> 120;
363 -> 137;
363 -> 121;
363 -> 129;
363 -> 122;
363 -> 123;
363 -> 132;
363 -> 134;
363 -> 131;
363 -> 235;
363 -> 238;
363 -> 252;
363 -> 254;
363 -> 256;
363 -> 255;
363 -> 253;
363 -> 251;
363 -> 206;
363 -> 208;
363 -> 362;
364 -> 362;
365 -> 363;
365 -> 364;
366 -> 364;
367 -> 365;
367 -> 363;
367 -> 366;
368 -> 367;
368 -> 363;
368 -> 366;
369 -> 364;
370 -> 369;
370 -> 365;
370 -> 364;
371 -> 363;
371 -> 364;
372 -> 371;
372 -> 363;
372 -> 364;
373 -> 363;
373 -> 372;
373 -> 368;
373 -> 370;
373 -> 362;
374 -> 363;
374 -> 364;
375 -> 374;
375 -> 373;
375 -> 364;
376 -> 363;
376 -> 364;
377 -> 376;
377 -> 375;
377 -> 364;
378 -> 363;
378 -> 364;
379 -> 363;
379 -> 364;
380 -> 379;
380 -> 377;
380 -> 378;
380 -> 364;
381 -> 380;
381 -> 379;
381 -> 364;
382 -> 363;
382 -> 364;
383 -> 382;
383 -> 377;
383 -> 364;
384 -> 383;
384 -> 364;
385 -> 363;
385 -> 384;
385 -> 377;
385 -> 381;
385 -> 362;
386 -> 363;
386 -> 364;
387 -> 363;
387 -> 364;
388 -> 386;
388 -> 387;
388 -> 385;
388 -> 364;
389 -> 388;
389 -> 364;
390 -> 364;
391 -> 389;
391 -> 390;
391 -> 364;
392 -> 389;
392 -> 387;
392 -> 385;
392 -> 364;
393 -> 391;
393 -> 392;
393 -> 364;
394 -> 393;
394 -> 364;
395 -> 389;
395 -> 387;
395 -> 394;
396 -> 362;
397 -> 359;
397 -> 396;
398 -> 397;
398 -> 395;
398 -> 396;
399 -> 396;
400 -> 397;
400 -> 398;
400 -> 399;
401 -> 400;
401 -> 398;
401 -> 399;
402 -> 401;
402 -> 399;
403 -> 396;
404 -> 402;
404 -> 403;
404 -> 396;
405 -> 404;
405 -> 396;
406 -> 396;
407 -> 406;
407 -> 396;
408 -> 397;
408 -> 398;
408 -> 396;
409 -> 396;
410 -> 405;
410 -> 409;
411 -> 407;
411 -> 409;
412 -> 408;
412 -> 409;
413 -> 397;
413 -> 409;
414 -> 411;
414 -> 409;
415 -> 409;
416 -> 415;
416 -> 409;
417 -> 416;
418 -> 413;
418 -> 417;
419 -> 417;
420 -> 418;
420 -> 398;
420 -> 419;
421 -> 417;
422 -> 421;
422 -> 418;
422 -> 417;
423 -> 416;
424 -> 413;
424 -> 398;
424 -> 423;
425 -> 424;
425 -> 398;
425 -> 423;
426 -> 423;
427 -> 424;
427 -> 426;
428 -> 427;
428 -> 398;
428 -> 426;
429 -> 428;
429 -> 426;
430 -> 429;
431 -> 427;
431 -> 430;
432 -> 431;
432 -> 398;
432 -> 430;
433 -> 432;
433 -> 430;
434 -> 433;
434 -> 427;
434 -> 398;
434 -> 429;
435 -> 434;
435 -> 429;
436 -> 429;
437 -> 427;
437 -> 398;
437 -> 436;
437 -> 429;
438 -> 427;
438 -> 398;
438 -> 420;
438 -> 437;
438 -> 429;
439 -> 438;
439 -> 429;
440 -> 427;
440 -> 398;
440 -> 420;
440 -> 422;
440 -> 429;
441 -> 440;
441 -> 429;
442 -> 427;
442 -> 398;
442 -> 429;
443 -> 427;
443 -> 398;
443 -> 442;
443 -> 429;
444 -> 427;
444 -> 398;
444 -> 420;
444 -> 422;
444 -> 429;
445 -> 443;
445 -> 444;
445 -> 429;
446 -> 445;
446 -> 429;
447 -> 427;
447 -> 398;
447 -> 429;
448 -> 427;
448 -> 398;
448 -> 429;
449 -> 427;
449 -> 398;
449 -> 429;
450 -> 446;
450 -> 429;
451 -> 427;
451 -> 398;
451 -> 447;
451 -> 448;
451 -> 449;
451 -> 450;
451 -> 420;
451 -> 422;
451 -> 429;
452 -> 427;
452 -> 451;
452 -> 446;
452 -> 429;
453 -> 452;
453 -> 427;
453 -> 429;
454 -> 429;
455 -> 446;
455 -> 454;
455 -> 429;
456 -> 455;
456 -> 429;
457 -> 425;
457 -> 456;
457 -> 423;
458 -> 457;
458 -> 423;
459 -> 424;
459 -> 451;
459 -> 453;
459 -> 423;
460 -> 459;
460 -> 423;
461 -> 460;
461 -> 416;
462 -> 416;
463 -> 461;
463 -> 462;
463 -> 416;
464 -> 463;
464 -> 416;
465 -> 464;
466 -> 461;
466 -> 465;
466 -> 464;
467 -> 466;
467 -> 464;
468 -> 461;
468 -> 416;
469 -> 468;
470 -> 397;
470 -> 451;
470 -> 412;
470 -> 396;
471 -> 396;
472 -> 471;
472 -> 396;
473 -> 396;
474 -> 397;
474 -> 473;
475 -> 473;
476 -> 474;
476 -> 451;
476 -> 475;
477 -> 473;
478 -> 477;
478 -> 474;
478 -> 473;
479 -> 472;
479 -> 396;
480 -> 479;
480 -> 397;
480 -> 451;
480 -> 453;
480 -> 476;
480 -> 412;
480 -> 478;
480 -> 396;
481 -> 396;
482 -> 480;
482 -> 481;
483 -> 482;
483 -> 480;
483 -> 481;
484 -> 483;
484 -> 481;
485 -> 480;
485 -> 484;
485 -> 481;
486 -> 485;
486 -> 481;
487 -> 486;
487 -> 481;
488 -> 480;
488 -> 484;
488 -> 481;
489 -> 488;
489 -> 481;
490 -> 480;
490 -> 481;
491 -> 480;
491 -> 481;
492 -> 0;
492 -> 490;
492 -> 481;
493 -> 490;
493 -> 481;
494 -> 481;
495 -> 493;
495 -> 494;
496 -> 491;
496 -> 494;
497 -> 495;
497 -> 494;
498 -> 497;
498 -> 496;
498 -> 489;
498 -> 494;
499 -> 494;
500 -> 498;
500 -> 499;
501 -> 498;
501 -> 499;
502 -> 498;
502 -> 499;
503 -> 498;
503 -> 499;
504 -> 500;
504 -> 499;
505 -> 501;
505 -> 499;
506 -> 502;
506 -> 499;
507 -> 503;
507 -> 498;
507 -> 504;
507 -> 505;
507 -> 506;
507 -> 499;
508 -> 507;
508 -> 499;
509 -> 508;
509 -> 494;
510 -> 509;
510 -> 494;
511 -> 510;
511 -> 481;
512 -> 508;
512 -> 511;
513 -> 512;
513 -> 511;
514 -> 0;
514 -> 513;
515 -> 513;
516 -> 514;
516 -> 515;
517 -> 491;
517 -> 515;
518 -> 517;
518 -> 508;
518 -> 515;
519 -> 515;
520 -> 518;
520 -> 519;
521 -> 520;
521 -> 0;
521 -> 519;
522 -> 521;
522 -> 519;
523 -> 522;
523 -> 516;
523 -> 515;
524 -> 523;
524 -> 515;
525 -> 524;
525 -> 513;
526 -> 508;
526 -> 525;
527 -> 508;
527 -> 525;
528 -> 525;
529 -> 526;
529 -> 528;
530 -> 527;
530 -> 528;
531 -> 491;
531 -> 508;
531 -> 528;
532 -> 529;
532 -> 244;
532 -> 528;
533 -> 532;
533 -> 528;
535 -> 534;
536 -> 529;
536 -> 528;
537 -> 536;
537 -> 531;
537 -> 508;
537 -> 528;
538 -> 528;
539 -> 537;
539 -> 538;
540 -> 539;
540 -> 538;
541 -> 0;
541 -> 540;
542 -> 537;
542 -> 538;
543 -> 542;
543 -> 538;
544 -> 0;
544 -> 543;
545 -> 537;
545 -> 544;
545 -> 541;
545 -> 528;
546 -> 545;
546 -> 528;
547 -> 546;
547 -> 0;
547 -> 528;
548 -> 547;
548 -> 528;
549 -> 548;
549 -> 525;
550 -> 0;
550 -> 508;
550 -> 549;
551 -> 0;
551 -> 508;
551 -> 549;
552 -> 508;
552 -> 0;
552 -> 513;
553 -> 552;
553 -> 513;
554 -> 511;
555 -> 554;
555 -> 511;
556 -> 397;
556 -> 479;
556 -> 484;
556 -> 489;
556 -> 555;
556 -> 545;
556 -> 396;
557 -> 470;
557 -> 396;
558 -> 396;
559 -> 557;
559 -> 558;
560 -> 558;
561 -> 560;
561 -> 558;
562 -> 558;
563 -> 559;
563 -> 562;
563 -> 558;
564 -> 563;
564 -> 558;
565 -> 564;
566 -> 565;
566 -> 564;
567 -> 566;
567 -> 559;
567 -> 556;
567 -> 564;
568 -> 567;
568 -> 564;
569 -> 561;
569 -> 558;
570 -> 396;
571 -> 569;
571 -> 570;
572 -> 397;
572 -> 570;
573 -> 570;
574 -> 572;
574 -> 556;
574 -> 573;
574 -> 570;
575 -> 574;
575 -> 570;
576 -> 575;
577 -> 576;
577 -> 575;
578 -> 577;
578 -> 396;
579 -> 397;
579 -> 556;
579 -> 396;
580 -> 396;
581 -> 580;
581 -> 396;
582 -> 396;
583 -> 582;
583 -> 396;
584 -> 397;
584 -> 579;
584 -> 396;
585 -> 397;
585 -> 581;
585 -> 583;
585 -> 584;
585 -> 579;
585 -> 396;
586 -> 397;
586 -> 585;
586 -> 396;
587 -> 556;
587 -> 396;
588 -> 470;
588 -> 396;
589 -> 586;
589 -> 396;
590 -> 578;
590 -> 396;
591 -> 396;
592 -> 587;
592 -> 591;
593 -> 588;
593 -> 591;
594 -> 589;
594 -> 591;
595 -> 590;
595 -> 591;
596 -> 397;
596 -> 591;
597 -> 592;
597 -> 0;
597 -> 591;
598 -> 591;
599 -> 592;
599 -> 598;
599 -> 591;
600 -> 597;
600 -> 599;
600 -> 591;
601 -> 600;
601 -> 591;
602 -> 593;
602 -> 585;
602 -> 591;
603 -> 602;
603 -> 591;
604 -> 594;
604 -> 602;
604 -> 591;
605 -> 604;
605 -> 591;
606 -> 591;
607 -> 592;
607 -> 591;
608 -> 592;
608 -> 607;
610 -> 0;
612 -> 610;
612 -> 611;
613 -> 611;
614 -> 611;
615 -> 614;
615 -> 611;
616 -> 612;
616 -> 611;
617 -> 613;
617 -> 616;
618 -> 0;
618 -> 617;
619 -> 618;
619 -> 616;
620 -> 611;
621 -> 619;
621 -> 620;
621 -> 611;
622 -> 621;
622 -> 611;
625 -> 623;
625 -> 624;
626 -> 0;
626 -> 611;
627 -> 612;
627 -> 611;
628 -> 611;
629 -> 626;
629 -> 628;
630 -> 627;
630 -> 628;
631 -> 629;
631 -> 628;
632 -> 630;
632 -> 628;
633 -> 628;
634 -> 631;
634 -> 633;
635 -> 632;
635 -> 633;
636 -> 633;
637 -> 633;
638 -> 633;
639 -> 634;
639 -> 633;
640 -> 636;
640 -> 633;
641 -> 637;
641 -> 633;
643 -> 642;
644 -> 635;
644 -> 633;
645 -> 639;
645 -> 638;
646 -> 640;
646 -> 638;
647 -> 641;
647 -> 638;
648 -> 644;
648 -> 638;
649 -> 638;
650 -> 645;
650 -> 638;
651 -> 646;
651 -> 638;
652 -> 647;
652 -> 638;
653 -> 648;
653 -> 638;
654 -> 649;
654 -> 650;
654 -> 651;
654 -> 652;
654 -> 653;
654 -> 638;
655 -> 649;
655 -> 638;
656 -> 655;
656 -> 654;
656 -> 638;
657 -> 638;
657 -> 633;
658 -> 635;
658 -> 638;
658 -> 633;
659 -> 634;
659 -> 0;
659 -> 633;
660 -> 659;
660 -> 633;
661 -> 633;
661 -> 628;
662 -> 661;
662 -> 611;
663 -> 613;
663 -> 611;
664 -> 662;
664 -> 663;
667 -> 665;
667 -> 666;
668 -> 666;
669 -> 666;
670 -> 669;
670 -> 666;
671 -> 667;
671 -> 666;
672 -> 668;
672 -> 671;
673 -> 0;
673 -> 672;
674 -> 673;
674 -> 671;
675 -> 666;
676 -> 674;
676 -> 675;
676 -> 666;
677 -> 676;
677 -> 666;
678 -> 0;
678 -> 666;
679 -> 667;
679 -> 666;
680 -> 666;
681 -> 678;
681 -> 680;
682 -> 679;
682 -> 680;
683 -> 681;
683 -> 680;
684 -> 682;
684 -> 680;
685 -> 680;
686 -> 683;
686 -> 685;
687 -> 684;
687 -> 685;
688 -> 685;
689 -> 685;
690 -> 685;
691 -> 686;
691 -> 685;
692 -> 688;
692 -> 685;
693 -> 689;
693 -> 685;
694 -> 687;
694 -> 685;
695 -> 691;
695 -> 690;
696 -> 692;
696 -> 690;
697 -> 693;
697 -> 690;
698 -> 694;
698 -> 690;
699 -> 690;
700 -> 695;
700 -> 690;
701 -> 696;
701 -> 690;
702 -> 697;
702 -> 690;
703 -> 698;
703 -> 690;
704 -> 699;
704 -> 700;
704 -> 701;
704 -> 702;
704 -> 703;
704 -> 690;
705 -> 699;
705 -> 690;
706 -> 705;
706 -> 704;
706 -> 690;
707 -> 690;
707 -> 685;
708 -> 687;
708 -> 690;
708 -> 685;
709 -> 686;
709 -> 0;
709 -> 685;
710 -> 709;
710 -> 685;
711 -> 685;
711 -> 680;
712 -> 711;
712 -> 666;
713 -> 668;
713 -> 666;
714 -> 712;
714 -> 713;
717 -> 715;
717 -> 716;
718 -> 716;
719 -> 716;
720 -> 719;
720 -> 716;
721 -> 717;
721 -> 716;
722 -> 718;
722 -> 721;
723 -> 0;
723 -> 722;
724 -> 723;
724 -> 721;
725 -> 716;
726 -> 724;
726 -> 725;
726 -> 716;
727 -> 726;
727 -> 716;
728 -> 0;
728 -> 716;
729 -> 717;
729 -> 716;
730 -> 716;
731 -> 728;
731 -> 730;
732 -> 729;
732 -> 730;
733 -> 731;
733 -> 730;
734 -> 732;
734 -> 730;
735 -> 730;
736 -> 733;
736 -> 735;
737 -> 734;
737 -> 735;
738 -> 735;
739 -> 735;
740 -> 735;
741 -> 736;
741 -> 735;
742 -> 738;
742 -> 735;
743 -> 739;
743 -> 735;
744 -> 737;
744 -> 735;
745 -> 741;
745 -> 740;
746 -> 742;
746 -> 740;
747 -> 743;
747 -> 740;
748 -> 744;
748 -> 740;
749 -> 740;
750 -> 745;
750 -> 740;
751 -> 746;
751 -> 740;
752 -> 747;
752 -> 740;
753 -> 748;
753 -> 740;
754 -> 749;
754 -> 750;
754 -> 751;
754 -> 752;
754 -> 753;
754 -> 740;
755 -> 749;
755 -> 740;
756 -> 755;
756 -> 754;
756 -> 740;
757 -> 740;
757 -> 735;
758 -> 737;
758 -> 740;
758 -> 735;
759 -> 736;
759 -> 0;
759 -> 735;
760 -> 759;
760 -> 735;
761 -> 735;
761 -> 730;
762 -> 761;
762 -> 716;
763 -> 718;
763 -> 716;
764 -> 762;
764 -> 763;
767 -> 765;
767 -> 766;
768 -> 766;
769 -> 0;
769 -> 766;
770 -> 767;
770 -> 766;
771 -> 766;
772 -> 769;
772 -> 771;
773 -> 770;
773 -> 771;
774 -> 772;
774 -> 771;
775 -> 773;
775 -> 771;
776 -> 771;
777 -> 774;
777 -> 776;
778 -> 775;
778 -> 776;
779 -> 776;
780 -> 776;
781 -> 776;
782 -> 777;
782 -> 776;
783 -> 779;
783 -> 776;
784 -> 780;
784 -> 776;
785 -> 778;
785 -> 776;
786 -> 782;
786 -> 781;
787 -> 783;
787 -> 781;
788 -> 784;
788 -> 781;
789 -> 785;
789 -> 781;
790 -> 781;
791 -> 786;
791 -> 781;
792 -> 787;
792 -> 781;
793 -> 788;
793 -> 781;
794 -> 789;
794 -> 781;
795 -> 790;
795 -> 791;
795 -> 792;
795 -> 793;
795 -> 794;
795 -> 781;
796 -> 790;
796 -> 781;
797 -> 796;
797 -> 795;
797 -> 781;
798 -> 781;
798 -> 776;
799 -> 778;
799 -> 781;
799 -> 776;
800 -> 777;
800 -> 0;
800 -> 776;
801 -> 800;
801 -> 776;
802 -> 776;
802 -> 771;
803 -> 802;
803 -> 766;
804 -> 768;
804 -> 766;
805 -> 803;
805 -> 804;
808 -> 806;
808 -> 807;
809 -> 807;
810 -> 0;
810 -> 807;
811 -> 808;
811 -> 807;
812 -> 807;
813 -> 810;
813 -> 812;
814 -> 811;
814 -> 812;
815 -> 813;
815 -> 812;
816 -> 814;
816 -> 812;
817 -> 812;
818 -> 815;
818 -> 817;
819 -> 816;
819 -> 817;
820 -> 817;
821 -> 817;
822 -> 817;
823 -> 818;
823 -> 817;
824 -> 820;
824 -> 817;
825 -> 821;
825 -> 817;
826 -> 819;
826 -> 817;
827 -> 823;
827 -> 822;
828 -> 824;
828 -> 822;
829 -> 825;
829 -> 822;
830 -> 826;
830 -> 822;
831 -> 822;
832 -> 827;
832 -> 822;
833 -> 828;
833 -> 822;
834 -> 829;
834 -> 822;
835 -> 830;
835 -> 822;
836 -> 831;
836 -> 832;
836 -> 833;
836 -> 834;
836 -> 835;
836 -> 822;
837 -> 831;
837 -> 822;
838 -> 837;
838 -> 836;
838 -> 822;
839 -> 822;
839 -> 817;
840 -> 819;
840 -> 822;
840 -> 817;
841 -> 818;
841 -> 0;
841 -> 817;
842 -> 841;
842 -> 817;
843 -> 817;
843 -> 812;
844 -> 843;
844 -> 807;
845 -> 809;
845 -> 807;
846 -> 844;
846 -> 845;
847 -> 0;
849 -> 848;
851 -> 847;
851 -> 850;
852 -> 849;
852 -> 850;
853 -> 850;
854 -> 853;
854 -> 850;
855 -> 851;
855 -> 850;
856 -> 852;
856 -> 855;
857 -> 0;
857 -> 856;
858 -> 857;
858 -> 855;
859 -> 850;
860 -> 858;
860 -> 859;
860 -> 850;
861 -> 860;
861 -> 850;
862 -> 0;
862 -> 850;
863 -> 851;
863 -> 850;
864 -> 850;
865 -> 862;
865 -> 864;
866 -> 863;
866 -> 864;
867 -> 865;
867 -> 864;
868 -> 866;
868 -> 864;
869 -> 864;
870 -> 867;
870 -> 869;
871 -> 868;
871 -> 869;
872 -> 869;
873 -> 869;
874 -> 869;
875 -> 870;
875 -> 869;
876 -> 872;
876 -> 869;
877 -> 873;
877 -> 869;
878 -> 871;
878 -> 869;
879 -> 875;
879 -> 874;
880 -> 876;
880 -> 874;
881 -> 877;
881 -> 874;
882 -> 878;
882 -> 874;
883 -> 874;
884 -> 879;
884 -> 874;
885 -> 880;
885 -> 874;
886 -> 881;
886 -> 874;
887 -> 882;
887 -> 874;
888 -> 883;
888 -> 884;
888 -> 885;
888 -> 886;
888 -> 887;
888 -> 874;
889 -> 883;
889 -> 874;
890 -> 889;
890 -> 888;
890 -> 874;
891 -> 874;
891 -> 869;
892 -> 871;
892 -> 874;
892 -> 869;
893 -> 870;
893 -> 0;
893 -> 869;
894 -> 893;
894 -> 869;
895 -> 869;
895 -> 864;
896 -> 895;
896 -> 850;
897 -> 852;
897 -> 850;
898 -> 896;
898 -> 850;
899 -> 850;
900 -> 898;
900 -> 899;
900 -> 890;
900 -> 891;
900 -> 892;
900 -> 0;
900 -> 850;
901 -> 850;
902 -> 900;
902 -> 901;
903 -> 900;
903 -> 901;
904 -> 901;
905 -> 903;
905 -> 904;
906 -> 905;
906 -> 900;
906 -> 904;
907 -> 903;
907 -> 900;
907 -> 901;
908 -> 903;
908 -> 900;
908 -> 901;
909 -> 902;
909 -> 901;
910 -> 901;
911 -> 906;
911 -> 910;
912 -> 907;
912 -> 910;
913 -> 908;
913 -> 910;
914 -> 909;
914 -> 910;
915 -> 910;
916 -> 915;
917 -> 916;
917 -> 911;
917 -> 913;
917 -> 914;
917 -> 912;
917 -> 908;
917 -> 915;
918 -> 916;
918 -> 915;
919 -> 915;
919 -> 910;
920 -> 911;
920 -> 0;
920 -> 910;
921 -> 920;
921 -> 910;
922 -> 910;
922 -> 901;
923 -> 900;
923 -> 922;
923 -> 917;
923 -> 919;
923 -> 912;
923 -> 850;
924 -> 923;
924 -> 850;
927 -> 926;
929 -> 925;
929 -> 928;
930 -> 927;
930 -> 928;
931 -> 928;
932 -> 931;
932 -> 928;
933 -> 929;
933 -> 928;
934 -> 930;
934 -> 933;
935 -> 0;
935 -> 934;
936 -> 935;
936 -> 933;
937 -> 928;
938 -> 936;
938 -> 937;
938 -> 928;
939 -> 938;
939 -> 928;
940 -> 0;
940 -> 928;
941 -> 929;
941 -> 928;
942 -> 928;
943 -> 940;
943 -> 942;
944 -> 941;
944 -> 942;
945 -> 943;
945 -> 942;
946 -> 944;
946 -> 942;
947 -> 942;
948 -> 945;
948 -> 947;
949 -> 946;
949 -> 947;
950 -> 947;
951 -> 947;
952 -> 947;
953 -> 948;
953 -> 947;
954 -> 950;
954 -> 947;
955 -> 951;
955 -> 947;
956 -> 949;
956 -> 947;
957 -> 953;
957 -> 952;
958 -> 954;
958 -> 952;
959 -> 955;
959 -> 952;
960 -> 956;
960 -> 952;
961 -> 952;
962 -> 957;
962 -> 952;
963 -> 958;
963 -> 952;
964 -> 959;
964 -> 952;
965 -> 960;
965 -> 952;
966 -> 961;
966 -> 962;
966 -> 963;
966 -> 964;
966 -> 965;
966 -> 952;
967 -> 961;
967 -> 952;
968 -> 967;
968 -> 966;
968 -> 952;
969 -> 952;
969 -> 947;
970 -> 949;
970 -> 952;
970 -> 947;
971 -> 948;
971 -> 0;
971 -> 947;
972 -> 971;
972 -> 947;
973 -> 947;
973 -> 942;
974 -> 973;
974 -> 928;
975 -> 930;
975 -> 928;
976 -> 974;
976 -> 928;
977 -> 928;
978 -> 976;
978 -> 977;
978 -> 968;
978 -> 969;
978 -> 970;
978 -> 923;
978 -> 928;
979 -> 928;
980 -> 979;
981 -> 979;
982 -> 981;
983 -> 982;
984 -> 983;
984 -> 982;
985 -> 982;
985 -> 981;
986 -> 978;
986 -> 0;
986 -> 981;
987 -> 986;
987 -> 981;
988 -> 981;
988 -> 979;
989 -> 978;
989 -> 928;
992 -> 991;
994 -> 990;
994 -> 993;
995 -> 992;
995 -> 993;
996 -> 993;
997 -> 996;
997 -> 993;
998 -> 994;
998 -> 993;
999 -> 995;
999 -> 998;
1000 -> 0;
1000 -> 999;
1001 -> 1000;
1001 -> 998;
1002 -> 993;
1003 -> 1001;
1003 -> 1002;
1003 -> 993;
1004 -> 1003;
1004 -> 993;
1005 -> 0;
1005 -> 993;
1006 -> 994;
1006 -> 993;
1007 -> 993;
1008 -> 1005;
1008 -> 1007;
1009 -> 1006;
1009 -> 1007;
1010 -> 1008;
1010 -> 1007;
1011 -> 1009;
1011 -> 1007;
1012 -> 1007;
1013 -> 1010;
1013 -> 1012;
1014 -> 1011;
1014 -> 1012;
1015 -> 1012;
1016 -> 1012;
1017 -> 1012;
1018 -> 1013;
1018 -> 1012;
1019 -> 1015;
1019 -> 1012;
1020 -> 1016;
1020 -> 1012;
1021 -> 1014;
1021 -> 1012;
1022 -> 1018;
1022 -> 1017;
1023 -> 1019;
1023 -> 1017;
1024 -> 1020;
1024 -> 1017;
1025 -> 1021;
1025 -> 1017;
1026 -> 1017;
1027 -> 1022;
1027 -> 1017;
1028 -> 1023;
1028 -> 1017;
1029 -> 1024;
1029 -> 1017;
1030 -> 1025;
1030 -> 1017;
1031 -> 1026;
1031 -> 1027;
1031 -> 1028;
1031 -> 1029;
1031 -> 1030;
1031 -> 1017;
1032 -> 1026;
1032 -> 1017;
1033 -> 1032;
1033 -> 1031;
1033 -> 1017;
1034 -> 1017;
1034 -> 1012;
1035 -> 1014;
1035 -> 1017;
1035 -> 1012;
1036 -> 1013;
1036 -> 0;
1036 -> 1012;
1037 -> 1036;
1037 -> 1012;
1038 -> 1012;
1038 -> 1007;
1039 -> 1038;
1039 -> 993;
1040 -> 995;
1040 -> 993;
1041 -> 1039;
1041 -> 993;
1042 -> 993;
1043 -> 1041;
1043 -> 1042;
1043 -> 1033;
1043 -> 1034;
1043 -> 1035;
1043 -> 978;
1043 -> 993;
1044 -> 993;
1045 -> 1044;
1046 -> 1044;
1047 -> 1046;
1048 -> 1047;
1049 -> 1048;
1049 -> 1047;
1050 -> 1047;
1050 -> 1046;
1051 -> 1043;
1051 -> 0;
1051 -> 1046;
1052 -> 1051;
1052 -> 1046;
1053 -> 1046;
1053 -> 1044;
1054 -> 1043;
1054 -> 993;
1057 -> 1056;
1059 -> 1055;
1059 -> 1058;
1060 -> 1057;
1060 -> 1058;
1061 -> 0;
1061 -> 1058;
1062 -> 1059;
1062 -> 1058;
1063 -> 1058;
1064 -> 1061;
1064 -> 1063;
1065 -> 1062;
1065 -> 1063;
1066 -> 1064;
1066 -> 1063;
1067 -> 1065;
1067 -> 1063;
1068 -> 1063;
1069 -> 1066;
1069 -> 1068;
1070 -> 1067;
1070 -> 1068;
1071 -> 1068;
1072 -> 1068;
1073 -> 1068;
1074 -> 1069;
1074 -> 1068;
1075 -> 1071;
1075 -> 1068;
1076 -> 1072;
1076 -> 1068;
1077 -> 1070;
1077 -> 1068;
1078 -> 1074;
1078 -> 1073;
1079 -> 1075;
1079 -> 1073;
1080 -> 1076;
1080 -> 1073;
1081 -> 1077;
1081 -> 1073;
1082 -> 1073;
1083 -> 1078;
1083 -> 1073;
1084 -> 1079;
1084 -> 1073;
1085 -> 1080;
1085 -> 1073;
1086 -> 1081;
1086 -> 1073;
1087 -> 1082;
1087 -> 1083;
1087 -> 1084;
1087 -> 1085;
1087 -> 1086;
1087 -> 1073;
1088 -> 1082;
1088 -> 1073;
1089 -> 1088;
1089 -> 1087;
1089 -> 1073;
1090 -> 1073;
1090 -> 1068;
1091 -> 1070;
1091 -> 1073;
1091 -> 1068;
1092 -> 1069;
1092 -> 0;
1092 -> 1068;
1093 -> 1092;
1093 -> 1068;
1094 -> 1068;
1094 -> 1063;
1095 -> 1094;
1095 -> 1058;
1096 -> 1060;
1096 -> 1058;
1097 -> 1095;
1097 -> 1058;
1098 -> 1058;
1099 -> 1097;
1099 -> 1098;
1099 -> 1089;
1099 -> 1090;
1099 -> 1091;
1099 -> 1043;
1099 -> 1058;
1100 -> 1058;
1101 -> 1100;
1102 -> 1100;
1103 -> 1102;
1104 -> 1103;
1105 -> 1104;
1105 -> 1103;
1106 -> 1103;
1106 -> 1102;
1107 -> 1099;
1107 -> 0;
1107 -> 1102;
1108 -> 1107;
1108 -> 1102;
1109 -> 1102;
1109 -> 1100;
1110 -> 1099;
1110 -> 1058;
1113 -> 1112;
1115 -> 1111;
1115 -> 1114;
1116 -> 1113;
1116 -> 1114;
1117 -> 0;
1117 -> 1114;
1118 -> 1115;
1118 -> 1114;
1119 -> 1114;
1120 -> 1117;
1120 -> 1119;
1121 -> 1118;
1121 -> 1119;
1122 -> 1120;
1122 -> 1119;
1123 -> 1121;
1123 -> 1119;
1124 -> 1119;
1125 -> 1122;
1125 -> 1124;
1126 -> 1123;
1126 -> 1124;
1127 -> 1124;
1128 -> 1124;
1129 -> 1124;
1130 -> 1125;
1130 -> 1124;
1131 -> 1127;
1131 -> 1124;
1132 -> 1128;
1132 -> 1124;
1133 -> 1126;
1133 -> 1124;
1134 -> 1130;
1134 -> 1129;
1135 -> 1131;
1135 -> 1129;
1136 -> 1132;
1136 -> 1129;
1137 -> 1133;
1137 -> 1129;
1138 -> 1129;
1139 -> 1134;
1139 -> 1129;
1140 -> 1135;
1140 -> 1129;
1141 -> 1136;
1141 -> 1129;
1142 -> 1137;
1142 -> 1129;
1143 -> 1138;
1143 -> 1139;
1143 -> 1140;
1143 -> 1141;
1143 -> 1142;
1143 -> 1129;
1144 -> 1138;
1144 -> 1129;
1145 -> 1144;
1145 -> 1143;
1145 -> 1129;
1146 -> 1129;
1146 -> 1124;
1147 -> 1126;
1147 -> 1129;
1147 -> 1124;
1148 -> 1125;
1148 -> 0;
1148 -> 1124;
1149 -> 1148;
1149 -> 1124;
1150 -> 1124;
1150 -> 1119;
1151 -> 1150;
1151 -> 1114;
1152 -> 1116;
1152 -> 1114;
1153 -> 1151;
1153 -> 1114;
1154 -> 1114;
1155 -> 1153;
1155 -> 1154;
1155 -> 1145;
1155 -> 1146;
1155 -> 1147;
1155 -> 1099;
1155 -> 1114;
1156 -> 1114;
1157 -> 1156;
1158 -> 1156;
1159 -> 1158;
1160 -> 1159;
1161 -> 1160;
1161 -> 1159;
1162 -> 1159;
1162 -> 1158;
1163 -> 1155;
1163 -> 0;
1163 -> 1158;
1164 -> 1163;
1164 -> 1158;
1165 -> 1158;
1165 -> 1156;
1166 -> 1155;
1166 -> 1114;
1167 -> 0;
1169 -> 1168;
1171 -> 1167;
1171 -> 1170;
1172 -> 1169;
1172 -> 1170;
1173 -> 0;
1173 -> 1170;
1174 -> 1171;
1174 -> 1170;
1175 -> 1170;
1176 -> 1173;
1176 -> 1175;
1177 -> 1174;
1177 -> 1175;
1178 -> 1176;
1178 -> 1175;
1179 -> 1177;
1179 -> 1175;
1180 -> 1175;
1181 -> 1178;
1181 -> 1180;
1182 -> 1179;
1182 -> 1180;
1183 -> 1180;
1184 -> 1180;
1185 -> 1180;
1186 -> 1181;
1186 -> 1180;
1187 -> 1183;
1187 -> 1180;
1188 -> 1184;
1188 -> 1180;
1189 -> 1182;
1189 -> 1180;
1190 -> 1186;
1190 -> 1185;
1191 -> 1187;
1191 -> 1185;
1192 -> 1188;
1192 -> 1185;
1193 -> 1189;
1193 -> 1185;
1194 -> 1185;
1195 -> 1190;
1195 -> 1185;
1196 -> 1191;
1196 -> 1185;
1197 -> 1192;
1197 -> 1185;
1198 -> 1193;
1198 -> 1185;
1199 -> 1194;
1199 -> 1195;
1199 -> 1196;
1199 -> 1197;
1199 -> 1198;
1199 -> 1185;
1200 -> 1194;
1200 -> 1185;
1201 -> 1200;
1201 -> 1199;
1201 -> 1185;
1202 -> 1185;
1202 -> 1180;
1203 -> 1182;
1203 -> 1185;
1203 -> 1180;
1204 -> 1181;
1204 -> 0;
1204 -> 1180;
1205 -> 1204;
1205 -> 1180;
1206 -> 1180;
1206 -> 1175;
1207 -> 1206;
1207 -> 1170;
1208 -> 1172;
1208 -> 1170;
1209 -> 1207;
1209 -> 1170;
1210 -> 1170;
1211 -> 1209;
1211 -> 1210;
1211 -> 1201;
1211 -> 1202;
1211 -> 1203;
1211 -> 1155;
1211 -> 1170;
1212 -> 1170;
1213 -> 1212;
1214 -> 1212;
1215 -> 1214;
1216 -> 1215;
1217 -> 1216;
1217 -> 1215;
1218 -> 1215;
1218 -> 1214;
1219 -> 1211;
1219 -> 0;
1219 -> 1214;
1220 -> 1219;
1220 -> 1214;
1221 -> 1214;
1221 -> 1212;
1222 -> 1211;
1222 -> 1170;
1224 -> 1222;
1225 -> 1166;
1226 -> 1110;
1227 -> 1054;
1228 -> 989;
1229 -> 924;
1230 -> 846;
1231 -> 805;
1232 -> 764;
1233 -> 714;
1234 -> 664;
1235 -> 609;
1236 -> 592;
1236 -> 608;
1237 -> 603;
1237 -> 608;
1238 -> 592;
1238 -> 608;
1239 -> 592;
1239 -> 608;
1240 -> 605;
1240 -> 608;
1241 -> 608;
1242 -> 1236;
1242 -> 1241;
1243 -> 1237;
1243 -> 1241;
1244 -> 1238;
1244 -> 1241;
1245 -> 1239;
1245 -> 1241;
1246 -> 1240;
1246 -> 1241;
1248 -> 0;
1248 -> 1247;
1249 -> 1248;
1250 -> 1249;
1252 -> 0;
1252 -> 1251;
1253 -> 1252;
1254 -> 1253;
1256 -> 0;
1256 -> 1255;
1257 -> 1256;
1258 -> 1257;
1260 -> 0;
1260 -> 1259;
1261 -> 1260;
1262 -> 1261;
1263 -> 0;
1264 -> 0;
1267 -> 1265;
1267 -> 1266;
1268 -> 1264;
1269 -> 1268;
1269 -> 1263;
1270 -> 1269;
1271 -> 1262;
1271 -> 1261;
1271 -> 1268;
1271 -> 1270;
1272 -> 1268;
1272 -> 1270;
1273 -> 1270;
1274 -> 1272;
1274 -> 1273;
1275 -> 1273;
1276 -> 1274;
1276 -> 1273;
1277 -> 1276;
1277 -> 1275;
1278 -> 1275;
1279 -> 1277;
1279 -> 1275;
1280 -> 1278;
1280 -> 1279;
1280 -> 1275;
1281 -> 1278;
1281 -> 1275;
1282 -> 1281;
1282 -> 1280;
1282 -> 1275;
1283 -> 1273;
1284 -> 1275;
1284 -> 1283;
1285 -> 1283;
1286 -> 1284;
1286 -> 1285;
1287 -> 1286;
1287 -> 1282;
1287 -> 1285;
1288 -> 1283;
1289 -> 1287;
1289 -> 1288;
1290 -> 1289;
1290 -> 1288;
1291 -> 1290;
1292 -> 1291;
1292 -> 1290;
1293 -> 1292;
1293 -> 1283;
1294 -> 1293;
1294 -> 1275;
1294 -> 1273;
1295 -> 1275;
1295 -> 1282;
1295 -> 0;
1295 -> 1273;
1296 -> 1295;
1296 -> 1275;
1296 -> 1273;
1297 -> 1273;
1297 -> 1271;
1297 -> 1270;
1298 -> 1258;
1298 -> 1257;
1298 -> 1268;
1298 -> 1270;
1299 -> 1268;
1299 -> 1270;
1300 -> 1224;
1300 -> 1270;
1301 -> 1224;
1301 -> 1270;
1302 -> 1299;
1302 -> 1300;
1302 -> 1301;
1302 -> 1270;
1303 -> 1299;
1303 -> 1300;
1303 -> 1301;
1303 -> 1211;
1303 -> 1270;
1304 -> 1270;
1305 -> 1303;
1305 -> 1304;
1306 -> 1302;
1306 -> 1304;
1307 -> 1305;
1307 -> 1304;
1308 -> 1304;
1309 -> 1307;
1309 -> 1308;
1310 -> 1306;
1310 -> 1308;
1311 -> 1309;
1311 -> 1308;
1312 -> 1308;
1313 -> 1312;
1313 -> 1311;
1313 -> 1308;
1314 -> 1312;
1314 -> 1308;
1315 -> 1314;
1315 -> 1313;
1315 -> 1308;
1316 -> 1304;
1317 -> 1306;
1317 -> 1316;
1318 -> 1316;
1319 -> 1317;
1319 -> 1318;
1320 -> 1319;
1320 -> 1315;
1320 -> 1318;
1321 -> 1316;
1322 -> 1320;
1322 -> 1321;
1323 -> 1322;
1323 -> 1321;
1324 -> 1323;
1325 -> 1324;
1325 -> 1323;
1326 -> 1325;
1326 -> 1316;
1327 -> 1326;
1327 -> 1306;
1327 -> 1304;
1328 -> 1306;
1328 -> 1315;
1328 -> 0;
1328 -> 1304;
1329 -> 1328;
1329 -> 1306;
1329 -> 1304;
1330 -> 1303;
1330 -> 1302;
1330 -> 1315;
1330 -> 1327;
1330 -> 1329;
1330 -> 1270;
1331 -> 1330;
1331 -> 1298;
1331 -> 1270;
1332 -> 1254;
1332 -> 1253;
1332 -> 1268;
1332 -> 1270;
1333 -> 1268;
1333 -> 1270;
1334 -> 1270;
1335 -> 1231;
1335 -> 1270;
1336 -> 1333;
1336 -> 1334;
1336 -> 1335;
1336 -> 1270;
1337 -> 1333;
1337 -> 1334;
1337 -> 1335;
1337 -> 797;
1337 -> 798;
1337 -> 799;
1337 -> 1270;
1338 -> 1270;
1339 -> 1337;
1339 -> 1338;
1340 -> 1336;
1340 -> 1338;
1341 -> 1339;
1341 -> 1338;
1342 -> 1338;
1343 -> 1341;
1343 -> 1342;
1344 -> 1340;
1344 -> 1342;
1345 -> 1343;
1345 -> 1342;
1346 -> 1342;
1347 -> 1346;
1347 -> 1345;
1347 -> 1342;
1348 -> 1346;
1348 -> 1342;
1349 -> 1348;
1349 -> 1347;
1349 -> 1342;
1350 -> 1338;
1351 -> 1340;
1351 -> 1350;
1352 -> 1350;
1353 -> 1351;
1353 -> 1352;
1354 -> 1353;
1354 -> 1349;
1354 -> 1352;
1355 -> 1350;
1356 -> 1354;
1356 -> 1355;
1357 -> 1356;
1357 -> 1355;
1358 -> 1357;
1359 -> 1358;
1359 -> 1357;
1360 -> 1359;
1360 -> 1350;
1361 -> 1360;
1361 -> 1340;
1361 -> 1338;
1362 -> 1340;
1362 -> 1349;
1362 -> 0;
1362 -> 1338;
1363 -> 1362;
1363 -> 1340;
1363 -> 1338;
1364 -> 1337;
1364 -> 1336;
1364 -> 1349;
1364 -> 1361;
1364 -> 1363;
1364 -> 1270;
1365 -> 1364;
1365 -> 1332;
1365 -> 1270;
1366 -> 1250;
1366 -> 1249;
1366 -> 1268;
1366 -> 1270;
1367 -> 1268;
1367 -> 1270;
1368 -> 1270;
1369 -> 1234;
1369 -> 1270;
1370 -> 1367;
1370 -> 1368;
1370 -> 1369;
1370 -> 1270;
1371 -> 1367;
1371 -> 1368;
1371 -> 1369;
1371 -> 656;
1371 -> 657;
1371 -> 658;
1371 -> 1270;
1372 -> 1270;
1373 -> 1371;
1373 -> 1372;
1374 -> 1370;
1374 -> 1372;
1375 -> 1373;
1375 -> 1372;
1376 -> 1372;
1377 -> 1375;
1377 -> 1376;
1378 -> 1374;
1378 -> 1376;
1379 -> 1377;
1379 -> 1376;
1380 -> 1376;
1381 -> 1380;
1381 -> 1379;
1381 -> 1376;
1382 -> 1380;
1382 -> 1376;
1383 -> 1382;
1383 -> 1381;
1383 -> 1376;
1384 -> 1372;
1385 -> 1374;
1385 -> 1384;
1386 -> 1384;
1387 -> 1385;
1387 -> 1386;
1388 -> 1387;
1388 -> 1383;
1388 -> 1386;
1389 -> 1384;
1390 -> 1388;
1390 -> 1389;
1391 -> 1390;
1391 -> 1389;
1392 -> 1391;
1393 -> 1392;
1393 -> 1391;
1394 -> 1393;
1394 -> 1384;
1395 -> 1394;
1395 -> 1374;
1395 -> 1372;
1396 -> 1374;
1396 -> 1383;
1396 -> 0;
1396 -> 1372;
1397 -> 1396;
1397 -> 1374;
1397 -> 1372;
1398 -> 1371;
1398 -> 1370;
1398 -> 1383;
1398 -> 1395;
1398 -> 1397;
1398 -> 1270;
1399 -> 1398;
1399 -> 1366;
1399 -> 1270;
1400 -> 1268;
1400 -> 1270;
1401 -> 1262;
1401 -> 1261;
1401 -> 1400;
1402 -> 1400;
1403 -> 1400;
1404 -> 1402;
1404 -> 1403;
1405 -> 1403;
1406 -> 1404;
1406 -> 1403;
1407 -> 1406;
1407 -> 1405;
1408 -> 1405;
1409 -> 1407;
1409 -> 1405;
1410 -> 1408;
1410 -> 1409;
1410 -> 1405;
1411 -> 1408;
1411 -> 1405;
1412 -> 1411;
1412 -> 1410;
1412 -> 1405;
1413 -> 1403;
1414 -> 1405;
1414 -> 1413;
1415 -> 1413;
1416 -> 1414;
1416 -> 1415;
1417 -> 1416;
1417 -> 1412;
1417 -> 1415;
1418 -> 1413;
1419 -> 1417;
1419 -> 1418;
1420 -> 1419;
1420 -> 1418;
1421 -> 1420;
1422 -> 1421;
1422 -> 1420;
1423 -> 1422;
1423 -> 1413;
1424 -> 1423;
1424 -> 1405;
1424 -> 1403;
1425 -> 1405;
1425 -> 1412;
1425 -> 0;
1425 -> 1403;
1426 -> 1425;
1426 -> 1405;
1426 -> 1403;
1427 -> 1403;
1427 -> 1401;
1427 -> 1400;
1428 -> 1258;
1428 -> 1257;
1428 -> 1400;
1429 -> 1400;
1430 -> 1224;
1430 -> 1400;
1431 -> 1224;
1431 -> 1400;
1432 -> 1429;
1432 -> 1430;
1432 -> 1431;
1432 -> 1400;
1433 -> 1429;
1433 -> 1430;
1433 -> 1431;
1433 -> 1330;
1433 -> 1400;
1434 -> 1400;
1435 -> 1432;
1435 -> 1434;
1436 -> 1434;
1437 -> 1435;
1437 -> 1436;
1438 -> 1436;
1439 -> 1438;
1439 -> 1436;
1440 -> 1434;
1441 -> 1435;
1441 -> 1440;
1442 -> 1440;
1443 -> 1441;
1443 -> 1442;
1444 -> 1440;
1445 -> 1433;
1446 -> 1445;
1446 -> 1433;
1447 -> 1446;
1447 -> 1428;
1447 -> 1400;
1448 -> 1254;
1448 -> 1253;
1448 -> 1400;
1449 -> 1400;
1450 -> 1400;
1451 -> 1231;
1451 -> 1400;
1452 -> 1449;
1452 -> 1450;
1452 -> 1451;
1452 -> 1400;
1453 -> 1449;
1453 -> 1450;
1453 -> 1451;
1453 -> 1364;
1453 -> 1400;
1454 -> 1400;
1455 -> 1452;
1455 -> 1454;
1456 -> 1454;
1457 -> 1455;
1457 -> 1456;
1458 -> 1456;
1459 -> 1458;
1459 -> 1456;
1460 -> 1454;
1461 -> 1455;
1461 -> 1460;
1462 -> 1460;
1463 -> 1461;
1463 -> 1462;
1464 -> 1460;
1465 -> 1453;
1466 -> 1465;
1466 -> 1453;
1467 -> 1466;
1467 -> 1448;
1467 -> 1400;
1468 -> 1250;
1468 -> 1249;
1468 -> 1400;
1469 -> 1400;
1470 -> 1400;
1471 -> 1234;
1471 -> 1400;
1472 -> 1469;
1472 -> 1470;
1472 -> 1471;
1472 -> 1400;
1473 -> 1469;
1473 -> 1470;
1473 -> 1471;
1473 -> 1398;
1473 -> 1400;
1474 -> 1400;
1475 -> 1472;
1475 -> 1474;
1476 -> 1474;
1477 -> 1475;
1477 -> 1476;
1478 -> 1476;
1479 -> 1478;
1479 -> 1476;
1480 -> 1474;
1481 -> 1475;
1481 -> 1480;
1482 -> 1480;
1483 -> 1481;
1483 -> 1482;
1484 -> 1480;
1485 -> 1473;
1486 -> 1485;
1486 -> 1473;
1487 -> 1486;
1487 -> 1468;
1487 -> 1400;
1488 -> 1420;
1489 -> 1488;
1489 -> 1420;
1490 -> 1489;
1490 -> 1413;
1491 -> 1490;
1491 -> 1405;
1491 -> 1403;
1492 -> 1446;
1493 -> 1492;
1493 -> 1446;
1494 -> 1493;
1494 -> 1428;
1494 -> 1400;
1495 -> 1466;
1496 -> 1495;
1496 -> 1466;
1497 -> 1496;
1497 -> 1448;
1497 -> 1400;
1498 -> 1486;
1499 -> 1498;
1499 -> 1486;
1500 -> 1499;
1500 -> 1468;
1500 -> 1400;
1501 -> 1420;
1502 -> 1501;
1502 -> 1420;
1503 -> 1502;
1503 -> 1413;
1504 -> 1503;
1504 -> 1405;
1504 -> 1403;
1505 -> 1493;
1506 -> 1505;
1506 -> 1493;
1507 -> 1506;
1507 -> 1428;
1507 -> 1400;
1508 -> 1496;
1509 -> 1508;
1509 -> 1496;
1510 -> 1509;
1510 -> 1448;
1510 -> 1400;
1511 -> 1499;
1512 -> 1511;
1512 -> 1499;
1513 -> 1512;
1513 -> 1468;
1513 -> 1400;
1514 -> 1420;
1515 -> 1514;
1515 -> 1420;
1516 -> 1515;
1516 -> 1413;
1517 -> 1516;
1517 -> 1405;
1517 -> 1403;
1518 -> 1506;
1519 -> 1518;
1519 -> 1506;
1520 -> 1519;
1520 -> 1428;
1520 -> 1400;
1521 -> 1509;
1522 -> 1521;
1522 -> 1509;
1523 -> 1522;
1523 -> 1448;
1523 -> 1400;
1524 -> 1512;
1525 -> 1524;
1525 -> 1512;
1526 -> 1525;
1526 -> 1468;
1526 -> 1400;
1527 -> 1420;
1528 -> 1527;
1528 -> 1420;
1529 -> 1528;
1529 -> 1413;
1530 -> 1529;
1530 -> 1405;
1530 -> 1403;
1531 -> 1519;
1532 -> 1531;
1532 -> 1519;
1533 -> 1532;
1533 -> 1428;
1533 -> 1400;
1534 -> 1522;
1535 -> 1534;
1535 -> 1522;
1536 -> 1535;
1536 -> 1448;
1536 -> 1400;
1537 -> 1525;
1538 -> 1537;
1538 -> 1525;
1539 -> 1538;
1539 -> 1468;
1539 -> 1400;
1540 -> 1420;
1541 -> 1540;
1541 -> 1420;
1542 -> 1541;
1542 -> 1413;
1543 -> 1542;
1543 -> 1405;
1543 -> 1403;
1544 -> 1532;
1545 -> 1544;
1545 -> 1532;
1546 -> 1545;
1546 -> 1428;
1546 -> 1400;
1547 -> 1535;
1548 -> 1547;
1548 -> 1535;
1549 -> 1548;
1549 -> 1448;
1549 -> 1400;
1550 -> 1538;
1551 -> 1550;
1551 -> 1538;
1552 -> 1551;
1552 -> 1468;
1552 -> 1400;
1553 -> 1420;
1554 -> 1553;
1554 -> 1420;
1555 -> 1554;
1555 -> 1413;
1556 -> 1555;
1556 -> 1405;
1556 -> 1403;
1557 -> 1545;
1558 -> 1557;
1558 -> 1545;
1559 -> 1558;
1559 -> 1428;
1559 -> 1400;
1560 -> 1548;
1561 -> 1560;
1561 -> 1548;
1562 -> 1561;
1562 -> 1448;
1562 -> 1400;
1563 -> 1551;
1564 -> 1563;
1564 -> 1551;
1565 -> 1564;
1565 -> 1468;
1565 -> 1400;
1566 -> 1420;
1567 -> 1566;
1567 -> 1420;
1568 -> 1567;
1568 -> 1413;
1569 -> 1568;
1569 -> 1405;
1569 -> 1403;
1570 -> 1558;
1571 -> 1570;
1571 -> 1558;
1572 -> 1571;
1572 -> 1428;
1572 -> 1400;
1573 -> 1561;
1574 -> 1573;
1574 -> 1561;
1575 -> 1574;
1575 -> 1448;
1575 -> 1400;
1576 -> 1564;
1577 -> 1576;
1577 -> 1564;
1578 -> 1577;
1578 -> 1468;
1578 -> 1400;
1579 -> 1420;
1580 -> 1579;
1580 -> 1420;
1581 -> 1580;
1581 -> 1413;
1582 -> 1581;
1582 -> 1405;
1582 -> 1403;
1583 -> 1571;
1584 -> 1583;
1584 -> 1571;
1585 -> 1584;
1585 -> 1428;
1585 -> 1400;
1586 -> 1574;
1587 -> 1586;
1587 -> 1574;
1588 -> 1587;
1588 -> 1448;
1588 -> 1400;
1589 -> 1577;
1590 -> 1589;
1590 -> 1577;
1591 -> 1590;
1591 -> 1468;
1591 -> 1400;
1592 -> 1420;
1593 -> 1592;
1593 -> 1420;
1594 -> 1593;
1594 -> 1413;
1595 -> 1594;
1595 -> 1405;
1595 -> 1403;
1596 -> 1584;
1597 -> 1596;
1597 -> 1584;
1598 -> 1597;
1598 -> 1428;
1598 -> 1400;
1599 -> 1587;
1600 -> 1599;
1600 -> 1587;
1601 -> 1600;
1601 -> 1448;
1601 -> 1400;
1602 -> 1590;
1603 -> 1602;
1603 -> 1590;
1604 -> 1603;
1604 -> 1468;
1604 -> 1400;
1605 -> 1420;
1606 -> 1605;
1606 -> 1420;
1607 -> 1606;
1607 -> 1413;
1608 -> 1607;
1608 -> 1405;
1608 -> 1403;
1609 -> 1597;
1610 -> 1609;
1610 -> 1597;
1611 -> 1610;
1611 -> 1428;
1611 -> 1400;
1612 -> 1600;
1613 -> 1612;
1613 -> 1600;
1614 -> 1613;
1614 -> 1448;
1614 -> 1400;
1615 -> 1603;
1616 -> 1615;
1616 -> 1603;
1617 -> 1616;
1617 -> 1468;
1617 -> 1400;
1618 -> 1420;
1619 -> 1618;
1619 -> 1420;
1620 -> 1619;
1620 -> 1413;
1621 -> 1620;
1621 -> 1405;
1621 -> 1403;
1622 -> 1610;
1623 -> 1622;
1623 -> 1610;
1624 -> 1623;
1624 -> 1428;
1624 -> 1400;
1625 -> 1613;
1626 -> 1625;
1626 -> 1613;
1627 -> 1626;
1627 -> 1448;
1627 -> 1400;
1628 -> 1616;
1629 -> 1628;
1629 -> 1616;
1630 -> 1629;
1630 -> 1468;
1630 -> 1400;
1631 -> 1420;
1632 -> 1631;
1632 -> 1420;
1633 -> 1632;
1633 -> 1413;
1634 -> 1633;
1634 -> 1405;
1634 -> 1403;
1635 -> 1623;
1636 -> 1635;
1636 -> 1623;
1637 -> 1636;
1637 -> 1428;
1637 -> 1400;
1638 -> 1626;
1639 -> 1638;
1639 -> 1626;
1640 -> 1639;
1640 -> 1448;
1640 -> 1400;
1641 -> 1629;
1642 -> 1641;
1642 -> 1629;
1643 -> 1642;
1643 -> 1468;
1643 -> 1400;
1644 -> 1420;
1645 -> 1644;
1645 -> 1420;
1646 -> 1645;
1646 -> 1413;
1647 -> 1646;
1647 -> 1405;
1647 -> 1403;
1648 -> 1636;
1649 -> 1648;
1649 -> 1636;
1650 -> 1649;
1650 -> 1428;
1650 -> 1400;
1651 -> 1639;
1652 -> 1651;
1652 -> 1639;
1653 -> 1652;
1653 -> 1448;
1653 -> 1400;
1654 -> 1642;
1655 -> 1654;
1655 -> 1642;
1656 -> 1655;
1656 -> 1468;
1656 -> 1400;
1657 -> 1420;
1658 -> 1657;
1658 -> 1420;
1659 -> 1658;
1659 -> 1413;
1660 -> 1659;
1660 -> 1405;
1660 -> 1403;
1661 -> 1649;
1662 -> 1661;
1662 -> 1649;
1663 -> 1662;
1663 -> 1428;
1663 -> 1400;
1664 -> 1652;
1665 -> 1664;
1665 -> 1652;
1666 -> 1665;
1666 -> 1448;
1666 -> 1400;
1667 -> 1655;
1668 -> 1667;
1668 -> 1655;
1669 -> 1668;
1669 -> 1468;
1669 -> 1400;
1670 -> 1420;
1671 -> 1670;
1671 -> 1420;
1672 -> 1671;
1672 -> 1413;
1673 -> 1672;
1673 -> 1405;
1673 -> 1403;
1674 -> 1662;
1675 -> 1674;
1675 -> 1662;
1676 -> 1675;
1676 -> 1428;
1676 -> 1400;
1677 -> 1665;
1678 -> 1677;
1678 -> 1665;
1679 -> 1678;
1679 -> 1448;
1679 -> 1400;
1680 -> 1668;
1681 -> 1680;
1681 -> 1668;
1682 -> 1681;
1682 -> 1468;
1682 -> 1400;
1683 -> 1420;
1684 -> 1683;
1684 -> 1420;
1685 -> 1684;
1685 -> 1413;
1686 -> 1685;
1686 -> 1405;
1686 -> 1403;
1687 -> 1675;
1688 -> 1687;
1688 -> 1675;
1689 -> 1688;
1689 -> 1428;
1689 -> 1400;
1690 -> 1678;
1691 -> 1690;
1691 -> 1678;
1692 -> 1691;
1692 -> 1448;
1692 -> 1400;
1693 -> 1681;
1694 -> 1693;
1694 -> 1681;
1695 -> 1694;
1695 -> 1468;
1695 -> 1400;
1696 -> 1420;
1697 -> 1696;
1697 -> 1420;
1698 -> 1697;
1698 -> 1413;
1699 -> 1698;
1699 -> 1405;
1699 -> 1403;
1700 -> 1688;
1701 -> 1700;
1701 -> 1688;
1702 -> 1701;
1702 -> 1428;
1702 -> 1400;
1703 -> 1691;
1704 -> 1703;
1704 -> 1691;
1705 -> 1704;
1705 -> 1448;
1705 -> 1400;
1706 -> 1694;
1707 -> 1706;
1707 -> 1694;
1708 -> 1707;
1708 -> 1468;
1708 -> 1400;
1709 -> 1420;
1710 -> 1709;
1710 -> 1420;
1711 -> 1710;
1711 -> 1413;
1712 -> 1711;
1712 -> 1405;
1712 -> 1403;
1713 -> 1701;
1714 -> 1713;
1714 -> 1701;
1715 -> 1714;
1715 -> 1428;
1715 -> 1400;
1716 -> 1704;
1717 -> 1716;
1717 -> 1704;
1718 -> 1717;
1718 -> 1448;
1718 -> 1400;
1719 -> 1707;
1720 -> 1719;
1720 -> 1707;
1721 -> 1720;
1721 -> 1468;
1721 -> 1400;
1722 -> 1420;
1723 -> 1722;
1723 -> 1420;
1724 -> 1723;
1724 -> 1413;
1725 -> 1724;
1725 -> 1405;
1725 -> 1403;
1726 -> 1714;
1727 -> 1726;
1727 -> 1714;
1728 -> 1727;
1728 -> 1428;
1728 -> 1400;
1729 -> 1717;
1730 -> 1729;
1730 -> 1717;
1731 -> 1730;
1731 -> 1448;
1731 -> 1400;
1732 -> 1720;
1733 -> 1732;
1733 -> 1720;
1734 -> 1733;
1734 -> 1468;
1734 -> 1400;
1735 -> 1420;
1736 -> 1735;
1736 -> 1420;
1737 -> 1736;
1737 -> 1413;
1738 -> 1737;
1738 -> 1405;
1738 -> 1403;
1739 -> 1727;
1740 -> 1739;
1740 -> 1727;
1741 -> 1740;
1741 -> 1428;
1741 -> 1400;
1742 -> 1730;
1743 -> 1742;
1743 -> 1730;
1744 -> 1743;
1744 -> 1448;
1744 -> 1400;
1745 -> 1733;
1746 -> 1745;
1746 -> 1733;
1747 -> 1746;
1747 -> 1468;
1747 -> 1400;
1748 -> 1420;
1749 -> 1748;
1749 -> 1420;
1750 -> 1749;
1750 -> 1413;
1751 -> 1750;
1751 -> 1405;
1751 -> 1403;
1752 -> 1740;
1753 -> 1752;
1753 -> 1740;
1754 -> 1753;
1754 -> 1428;
1754 -> 1400;
1755 -> 1743;
1756 -> 1755;
1756 -> 1743;
1757 -> 1756;
1757 -> 1448;
1757 -> 1400;
1758 -> 1746;
1759 -> 1758;
1759 -> 1746;
1760 -> 1759;
1760 -> 1468;
1760 -> 1400;
1761 -> 1420;
1762 -> 1761;
1762 -> 1420;
1763 -> 1762;
1763 -> 1413;
1764 -> 1763;
1764 -> 1405;
1764 -> 1403;
1765 -> 1753;
1766 -> 1765;
1766 -> 1753;
1767 -> 1766;
1767 -> 1428;
1767 -> 1400;
1768 -> 1756;
1769 -> 1768;
1769 -> 1756;
1770 -> 1769;
1770 -> 1448;
1770 -> 1400;
1771 -> 1759;
1772 -> 1771;
1772 -> 1759;
1773 -> 1772;
1773 -> 1468;
1773 -> 1400;
1774 -> 1420;
1775 -> 1774;
1775 -> 1420;
1776 -> 1775;
1776 -> 1413;
1777 -> 1776;
1777 -> 1405;
1777 -> 1403;
1778 -> 1766;
1779 -> 1778;
1779 -> 1766;
1780 -> 1779;
1780 -> 1428;
1780 -> 1400;
1781 -> 1769;
1782 -> 1781;
1782 -> 1769;
1783 -> 1782;
1783 -> 1448;
1783 -> 1400;
1784 -> 1772;
1785 -> 1784;
1785 -> 1772;
1786 -> 1785;
1786 -> 1468;
1786 -> 1400;
1787 -> 1420;
1788 -> 1787;
1788 -> 1420;
1789 -> 1788;
1789 -> 1413;
1790 -> 1789;
1790 -> 1405;
1790 -> 1403;
1791 -> 1779;
1792 -> 1791;
1792 -> 1779;
1793 -> 1792;
1793 -> 1428;
1793 -> 1400;
1794 -> 1782;
1795 -> 1794;
1795 -> 1782;
1796 -> 1795;
1796 -> 1448;
1796 -> 1400;
1797 -> 1785;
1798 -> 1797;
1798 -> 1785;
1799 -> 1798;
1799 -> 1468;
1799 -> 1400;
1800 -> 1420;
1801 -> 1800;
1801 -> 1420;
1802 -> 1801;
1802 -> 1413;
1803 -> 1802;
1803 -> 1405;
1803 -> 1403;
1804 -> 1792;
1805 -> 1804;
1805 -> 1792;
1806 -> 1805;
1806 -> 1428;
1806 -> 1400;
1807 -> 1795;
1808 -> 1807;
1808 -> 1795;
1809 -> 1808;
1809 -> 1448;
1809 -> 1400;
1810 -> 1798;
1811 -> 1810;
1811 -> 1798;
1812 -> 1811;
1812 -> 1468;
1812 -> 1400;
1813 -> 1420;
1814 -> 1813;
1814 -> 1420;
1815 -> 1814;
1815 -> 1413;
1816 -> 1815;
1816 -> 1405;
1816 -> 1403;
1817 -> 1805;
1818 -> 1817;
1818 -> 1805;
1819 -> 1818;
1819 -> 1428;
1819 -> 1400;
1820 -> 1808;
1821 -> 1820;
1821 -> 1808;
1822 -> 1821;
1822 -> 1448;
1822 -> 1400;
1823 -> 1811;
1824 -> 1823;
1824 -> 1811;
1825 -> 1824;
1825 -> 1468;
1825 -> 1400;
1826 -> 1420;
1827 -> 1826;
1827 -> 1420;
1828 -> 1827;
1828 -> 1413;
1829 -> 1828;
1829 -> 1405;
1829 -> 1403;
1830 -> 1818;
1831 -> 1830;
1831 -> 1818;
1832 -> 1831;
1832 -> 1428;
1832 -> 1400;
1833 -> 1821;
1834 -> 1833;
1834 -> 1821;
1835 -> 1834;
1835 -> 1448;
1835 -> 1400;
1836 -> 1824;
1837 -> 1836;
1837 -> 1824;
1838 -> 1837;
1838 -> 1468;
1838 -> 1400;
1839 -> 1420;
1840 -> 1839;
1840 -> 1420;
1841 -> 1840;
1841 -> 1413;
1842 -> 1841;
1842 -> 1405;
1842 -> 1403;
1843 -> 1831;
1844 -> 1843;
1844 -> 1831;
1845 -> 1844;
1845 -> 1428;
1845 -> 1400;
1846 -> 1834;
1847 -> 1846;
1847 -> 1834;
1848 -> 1847;
1848 -> 1448;
1848 -> 1400;
1849 -> 1837;
1850 -> 1849;
1850 -> 1837;
1851 -> 1850;
1851 -> 1468;
1851 -> 1400;
1852 -> 0;
1852 -> 1420;
1853 -> 1852;
1853 -> 1413;
1854 -> 1853;
1854 -> 1405;
1854 -> 1403;
1855 -> 0;
1855 -> 1844;
1856 -> 1855;
1856 -> 1428;
1856 -> 1400;
1857 -> 0;
1857 -> 1847;
1858 -> 1857;
1858 -> 1448;
1858 -> 1400;
1859 -> 0;
1859 -> 1850;
1860 -> 1859;
1860 -> 1468;
1860 -> 1400;
1861 -> 1420;
1862 -> 1861;
1862 -> 1420;
1863 -> 1862;
1863 -> 1413;
1864 -> 1863;
1864 -> 1405;
1864 -> 1403;
1865 -> 1855;
1866 -> 1865;
1866 -> 1855;
1867 -> 1866;
1867 -> 1428;
1867 -> 1400;
1868 -> 1857;
1869 -> 1868;
1869 -> 1857;
1870 -> 1869;
1870 -> 1448;
1870 -> 1400;
1871 -> 1859;
1872 -> 1871;
1872 -> 1859;
1873 -> 1872;
1873 -> 1468;
1873 -> 1400;
1874 -> 1420;
1875 -> 1874;
1875 -> 1420;
1876 -> 1875;
1876 -> 1413;
1877 -> 1876;
1877 -> 1405;
1877 -> 1403;
1878 -> 1866;
1879 -> 1878;
1879 -> 1866;
1880 -> 1879;
1880 -> 1428;
1880 -> 1400;
1881 -> 1869;
1882 -> 1881;
1882 -> 1869;
1883 -> 1882;
1883 -> 1448;
1883 -> 1400;
1884 -> 1872;
1885 -> 1884;
1885 -> 1872;
1886 -> 1885;
1886 -> 1468;
1886 -> 1400;
1887 -> 1420;
1888 -> 1887;
1888 -> 1420;
1889 -> 1888;
1889 -> 1413;
1890 -> 1889;
1890 -> 1405;
1890 -> 1403;
1891 -> 1879;
1892 -> 1891;
1892 -> 1879;
1893 -> 1892;
1893 -> 1428;
1893 -> 1400;
1894 -> 1882;
1895 -> 1894;
1895 -> 1882;
1896 -> 1895;
1896 -> 1448;
1896 -> 1400;
1897 -> 1885;
1898 -> 1897;
1898 -> 1885;
1899 -> 1898;
1899 -> 1468;
1899 -> 1400;
1900 -> 1420;
1901 -> 1900;
1901 -> 1420;
1902 -> 1901;
1902 -> 1413;
1903 -> 1902;
1903 -> 1405;
1903 -> 1403;
1904 -> 1892;
1905 -> 1904;
1905 -> 1892;
1906 -> 1905;
1906 -> 1428;
1906 -> 1400;
1907 -> 1895;
1908 -> 1907;
1908 -> 1895;
1909 -> 1908;
1909 -> 1448;
1909 -> 1400;
1910 -> 1898;
1911 -> 1910;
1911 -> 1898;
1912 -> 1911;
1912 -> 1468;
1912 -> 1400;
1913 -> 1420;
1914 -> 1913;
1914 -> 1420;
1915 -> 1914;
1915 -> 1413;
1916 -> 1915;
1916 -> 1405;
1916 -> 1403;
1917 -> 1905;
1918 -> 1917;
1918 -> 1905;
1919 -> 1918;
1919 -> 1428;
1919 -> 1400;
1920 -> 1908;
1921 -> 1920;
1921 -> 1908;
1922 -> 1921;
1922 -> 1448;
1922 -> 1400;
1923 -> 1911;
1924 -> 1923;
1924 -> 1911;
1925 -> 1924;
1925 -> 1468;
1925 -> 1400;
1926 -> 1420;
1927 -> 1926;
1927 -> 1420;
1928 -> 1927;
1928 -> 1413;
1929 -> 1928;
1929 -> 1405;
1929 -> 1403;
1930 -> 1918;
1931 -> 1930;
1931 -> 1918;
1932 -> 1931;
1932 -> 1428;
1932 -> 1400;
1933 -> 1921;
1934 -> 1933;
1934 -> 1921;
1935 -> 1934;
1935 -> 1448;
1935 -> 1400;
1936 -> 1924;
1937 -> 1936;
1937 -> 1924;
1938 -> 1937;
1938 -> 1468;
1938 -> 1400;
1939 -> 1420;
1940 -> 1939;
1940 -> 1420;
1941 -> 1940;
1941 -> 1413;
1942 -> 1941;
1942 -> 1405;
1942 -> 1403;
1943 -> 1931;
1944 -> 1943;
1944 -> 1931;
1945 -> 1944;
1945 -> 1428;
1945 -> 1400;
1946 -> 1934;
1947 -> 1946;
1947 -> 1934;
1948 -> 1947;
1948 -> 1448;
1948 -> 1400;
1949 -> 1937;
1950 -> 1949;
1950 -> 1937;
1951 -> 1950;
1951 -> 1468;
1951 -> 1400;
1952 -> 1420;
1953 -> 1952;
1953 -> 1420;
1954 -> 1953;
1954 -> 1413;
1955 -> 1954;
1955 -> 1405;
1955 -> 1403;
1956 -> 1944;
1957 -> 1956;
1957 -> 1944;
1958 -> 1957;
1958 -> 1428;
1958 -> 1400;
1959 -> 1947;
1960 -> 1959;
1960 -> 1947;
1961 -> 1960;
1961 -> 1448;
1961 -> 1400;
1962 -> 1950;
1963 -> 1962;
1963 -> 1950;
1964 -> 1963;
1964 -> 1468;
1964 -> 1400;
1965 -> 1420;
1966 -> 1965;
1966 -> 1420;
1967 -> 1966;
1967 -> 1413;
1968 -> 1967;
1968 -> 1405;
1968 -> 1403;
1969 -> 1957;
1970 -> 1969;
1970 -> 1957;
1971 -> 1970;
1971 -> 1428;
1971 -> 1400;
1972 -> 1960;
1973 -> 1972;
1973 -> 1960;
1974 -> 1973;
1974 -> 1448;
1974 -> 1400;
1975 -> 1963;
1976 -> 1975;
1976 -> 1963;
1977 -> 1976;
1977 -> 1468;
1977 -> 1400;
1978 -> 1420;
1979 -> 1978;
1979 -> 1420;
1980 -> 1979;
1980 -> 1413;
1981 -> 1980;
1981 -> 1405;
1981 -> 1403;
1982 -> 1970;
1983 -> 1982;
1983 -> 1970;
1984 -> 1983;
1984 -> 1428;
1984 -> 1400;
1985 -> 1973;
1986 -> 1985;
1986 -> 1973;
1987 -> 1986;
1987 -> 1448;
1987 -> 1400;
1988 -> 1976;
1989 -> 1988;
1989 -> 1976;
1990 -> 1989;
1990 -> 1468;
1990 -> 1400;
1991 -> 1420;
1992 -> 1991;
1992 -> 1420;
1993 -> 1992;
1993 -> 1413;
1994 -> 1993;
1994 -> 1405;
1994 -> 1403;
1995 -> 1983;
1996 -> 1995;
1996 -> 1983;
1997 -> 1996;
1997 -> 1428;
1997 -> 1400;
1998 -> 1986;
1999 -> 1998;
1999 -> 1986;
2000 -> 1999;
2000 -> 1448;
2000 -> 1400;
2001 -> 1989;
2002 -> 2001;
2002 -> 1989;
2003 -> 2002;
2003 -> 1468;
2003 -> 1400;
2004 -> 1420;
2005 -> 2004;
2005 -> 1420;
2006 -> 2005;
2006 -> 1413;
2007 -> 2006;
2007 -> 1405;
2007 -> 1403;
2008 -> 1996;
2009 -> 2008;
2009 -> 1996;
2010 -> 2009;
2010 -> 1428;
2010 -> 1400;
2011 -> 1999;
2012 -> 2011;
2012 -> 1999;
2013 -> 2012;
2013 -> 1448;
2013 -> 1400;
2014 -> 2002;
2015 -> 2014;
2015 -> 2002;
2016 -> 2015;
2016 -> 1468;
2016 -> 1400;
2017 -> 1420;
2018 -> 2017;
2018 -> 1420;
2019 -> 2018;
2019 -> 1413;
2020 -> 2019;
2020 -> 1405;
2020 -> 1403;
2021 -> 2009;
2022 -> 2021;
2022 -> 2009;
2023 -> 2022;
2023 -> 1428;
2023 -> 1400;
2024 -> 2012;
2025 -> 2024;
2025 -> 2012;
2026 -> 2025;
2026 -> 1448;
2026 -> 1400;
2027 -> 2015;
2028 -> 2027;
2028 -> 2015;
2029 -> 2028;
2029 -> 1468;
2029 -> 1400;
2030 -> 1420;
2031 -> 2030;
2031 -> 1420;
2032 -> 2031;
2032 -> 1413;
2033 -> 2032;
2033 -> 1405;
2033 -> 1403;
2034 -> 2022;
2035 -> 2034;
2035 -> 2022;
2036 -> 2035;
2036 -> 1428;
2036 -> 1400;
2037 -> 2025;
2038 -> 2037;
2038 -> 2025;
2039 -> 2038;
2039 -> 1448;
2039 -> 1400;
2040 -> 2028;
2041 -> 2040;
2041 -> 2028;
2042 -> 2041;
2042 -> 1468;
2042 -> 1400;
2043 -> 1420;
2044 -> 2043;
2044 -> 1420;
2045 -> 2044;
2045 -> 1413;
2046 -> 2045;
2046 -> 1405;
2046 -> 1403;
2047 -> 2035;
2048 -> 2047;
2048 -> 2035;
2049 -> 2048;
2049 -> 1428;
2049 -> 1400;
2050 -> 2038;
2051 -> 2050;
2051 -> 2038;
2052 -> 2051;
2052 -> 1448;
2052 -> 1400;
2053 -> 2041;
2054 -> 2053;
2054 -> 2041;
2055 -> 2054;
2055 -> 1468;
2055 -> 1400;
2056 -> 1420;
2057 -> 2056;
2057 -> 1420;
2058 -> 2057;
2058 -> 1413;
2059 -> 2058;
2059 -> 1405;
2059 -> 1403;
2060 -> 2048;
2061 -> 2060;
2061 -> 2048;
2062 -> 2061;
2062 -> 1428;
2062 -> 1400;
2063 -> 2051;
2064 -> 2063;
2064 -> 2051;
2065 -> 2064;
2065 -> 1448;
2065 -> 1400;
2066 -> 2054;
2067 -> 2066;
2067 -> 2054;
2068 -> 2067;
2068 -> 1468;
2068 -> 1400;
2069 -> 1420;
2070 -> 2069;
2070 -> 1420;
2071 -> 2070;
2071 -> 1413;
2072 -> 2071;
2072 -> 1405;
2072 -> 1403;
2073 -> 2061;
2074 -> 2073;
2074 -> 2061;
2075 -> 2074;
2075 -> 1428;
2075 -> 1400;
2076 -> 2064;
2077 -> 2076;
2077 -> 2064;
2078 -> 2077;
2078 -> 1448;
2078 -> 1400;
2079 -> 2067;
2080 -> 2079;
2080 -> 2067;
2081 -> 2080;
2081 -> 1468;
2081 -> 1400;
2082 -> 1420;
2083 -> 2082;
2083 -> 1420;
2084 -> 2083;
2084 -> 1413;
2085 -> 2084;
2085 -> 1405;
2085 -> 1403;
2086 -> 2074;
2087 -> 2086;
2087 -> 2074;
2088 -> 2087;
2088 -> 1428;
2088 -> 1400;
2089 -> 2077;
2090 -> 2089;
2090 -> 2077;
2091 -> 2090;
2091 -> 1448;
2091 -> 1400;
2092 -> 2080;
2093 -> 2092;
2093 -> 2080;
2094 -> 2093;
2094 -> 1468;
2094 -> 1400;
2095 -> 1420;
2096 -> 2095;
2096 -> 1420;
2097 -> 2096;
2097 -> 1413;
2098 -> 2097;
2098 -> 1405;
2098 -> 1403;
2099 -> 2087;
2100 -> 2099;
2100 -> 2087;
2101 -> 2100;
2101 -> 1428;
2101 -> 1400;
2102 -> 2090;
2103 -> 2102;
2103 -> 2090;
2104 -> 2103;
2104 -> 1448;
2104 -> 1400;
2105 -> 2093;
2106 -> 2105;
2106 -> 2093;
2107 -> 2106;
2107 -> 1468;
2107 -> 1400;
2108 -> 1420;
2109 -> 2108;
2109 -> 1420;
2110 -> 2109;
2110 -> 1413;
2111 -> 2110;
2111 -> 1405;
2111 -> 1403;
2112 -> 2100;
2113 -> 2112;
2113 -> 2100;
2114 -> 2113;
2114 -> 1428;
2114 -> 1400;
2115 -> 2103;
2116 -> 2115;
2116 -> 2103;
2117 -> 2116;
2117 -> 1448;
2117 -> 1400;
2118 -> 2106;
2119 -> 2118;
2119 -> 2106;
2120 -> 2119;
2120 -> 1468;
2120 -> 1400;
2121 -> 1420;
2122 -> 2121;
2122 -> 1420;
2123 -> 2122;
2123 -> 1413;
2124 -> 2123;
2124 -> 1405;
2124 -> 1403;
2125 -> 2113;
2126 -> 2125;
2126 -> 2113;
2127 -> 2126;
2127 -> 1428;
2127 -> 1400;
2128 -> 2116;
2129 -> 2128;
2129 -> 2116;
2130 -> 2129;
2130 -> 1448;
2130 -> 1400;
2131 -> 2119;
2132 -> 2131;
2132 -> 2119;
2133 -> 2132;
2133 -> 1468;
2133 -> 1400;
2134 -> 1420;
2135 -> 2134;
2135 -> 1420;
2136 -> 2135;
2136 -> 1413;
2137 -> 2136;
2137 -> 1405;
2137 -> 1403;
2138 -> 2126;
2139 -> 2138;
2139 -> 2126;
2140 -> 2139;
2140 -> 1428;
2140 -> 1400;
2141 -> 2129;
2142 -> 2141;
2142 -> 2129;
2143 -> 2142;
2143 -> 1448;
2143 -> 1400;
2144 -> 2132;
2145 -> 2144;
2145 -> 2132;
2146 -> 2145;
2146 -> 1468;
2146 -> 1400;
2147 -> 1420;
2148 -> 2147;
2148 -> 1420;
2149 -> 2148;
2149 -> 1413;
2150 -> 2149;
2150 -> 1405;
2150 -> 1403;
2151 -> 2139;
2152 -> 2151;
2152 -> 2139;
2153 -> 2152;
2153 -> 1428;
2153 -> 1400;
2154 -> 2142;
2155 -> 2154;
2155 -> 2142;
2156 -> 2155;
2156 -> 1448;
2156 -> 1400;
2157 -> 2145;
2158 -> 2157;
2158 -> 2145;
2159 -> 2158;
2159 -> 1468;
2159 -> 1400;
2160 -> 1420;
2161 -> 2160;
2161 -> 1420;
2162 -> 2161;
2162 -> 1413;
2163 -> 2162;
2163 -> 1405;
2163 -> 1403;
2164 -> 2152;
2165 -> 2164;
2165 -> 2152;
2166 -> 2165;
2166 -> 1428;
2166 -> 1400;
2167 -> 2155;
2168 -> 2167;
2168 -> 2155;
2169 -> 2168;
2169 -> 1448;
2169 -> 1400;
2170 -> 2158;
2171 -> 2170;
2171 -> 2158;
2172 -> 2171;
2172 -> 1468;
2172 -> 1400;
2173 -> 1420;
2174 -> 2173;
2174 -> 1420;
2175 -> 2174;
2175 -> 1413;
2176 -> 2175;
2176 -> 1405;
2176 -> 1403;
2177 -> 2165;
2178 -> 2177;
2178 -> 2165;
2179 -> 2178;
2179 -> 1428;
2179 -> 1400;
2180 -> 2168;
2181 -> 2180;
2181 -> 2168;
2182 -> 2181;
2182 -> 1448;
2182 -> 1400;
2183 -> 2171;
2184 -> 2183;
2184 -> 2171;
2185 -> 2184;
2185 -> 1468;
2185 -> 1400;
2186 -> 1420;
2187 -> 2186;
2187 -> 1420;
2188 -> 2187;
2188 -> 1413;
2189 -> 2188;
2189 -> 1405;
2189 -> 1403;
2190 -> 2178;
2191 -> 2190;
2191 -> 2178;
2192 -> 2191;
2192 -> 1428;
2192 -> 1400;
2193 -> 2181;
2194 -> 2193;
2194 -> 2181;
2195 -> 2194;
2195 -> 1448;
2195 -> 1400;
2196 -> 2184;
2197 -> 2196;
2197 -> 2184;
2198 -> 2197;
2198 -> 1468;
2198 -> 1400;
2199 -> 1420;
2200 -> 2199;
2200 -> 1420;
2201 -> 2200;
2201 -> 1413;
2202 -> 2201;
2202 -> 1405;
2202 -> 1403;
2203 -> 2191;
2204 -> 2203;
2204 -> 2191;
2205 -> 2204;
2205 -> 1428;
2205 -> 1400;
2206 -> 2194;
2207 -> 2206;
2207 -> 2194;
2208 -> 2207;
2208 -> 1448;
2208 -> 1400;
2209 -> 2197;
2210 -> 2209;
2210 -> 2197;
2211 -> 2210;
2211 -> 1468;
2211 -> 1400;
2212 -> 1420;
2213 -> 2212;
2213 -> 1420;
2214 -> 2213;
2214 -> 1413;
2215 -> 2214;
2215 -> 1405;
2215 -> 1403;
2216 -> 2204;
2217 -> 2216;
2217 -> 2204;
2218 -> 2217;
2218 -> 1428;
2218 -> 1400;
2219 -> 2207;
2220 -> 2219;
2220 -> 2207;
2221 -> 2220;
2221 -> 1448;
2221 -> 1400;
2222 -> 2210;
2223 -> 2222;
2223 -> 2210;
2224 -> 2223;
2224 -> 1468;
2224 -> 1400;
2225 -> 1420;
2226 -> 2225;
2226 -> 1420;
2227 -> 2226;
2227 -> 1413;
2228 -> 2227;
2228 -> 1405;
2228 -> 1403;
2229 -> 2217;
2230 -> 2229;
2230 -> 2217;
2231 -> 2230;
2231 -> 1428;
2231 -> 1400;
2232 -> 2220;
2233 -> 2232;
2233 -> 2220;
2234 -> 2233;
2234 -> 1448;
2234 -> 1400;
2235 -> 2223;
2236 -> 2235;
2236 -> 2223;
2237 -> 2236;
2237 -> 1468;
2237 -> 1400;
2238 -> 1420;
2239 -> 2238;
2239 -> 1420;
2240 -> 2239;
2240 -> 1413;
2241 -> 2240;
2241 -> 1405;
2241 -> 1403;
2242 -> 2230;
2243 -> 2242;
2243 -> 2230;
2244 -> 2243;
2244 -> 1428;
2244 -> 1400;
2245 -> 2233;
2246 -> 2245;
2246 -> 2233;
2247 -> 2246;
2247 -> 1448;
2247 -> 1400;
2248 -> 2236;
2249 -> 2248;
2249 -> 2236;
2250 -> 2249;
2250 -> 1468;
2250 -> 1400;
2251 -> 1420;
2252 -> 2251;
2252 -> 1420;
2253 -> 2252;
2253 -> 1413;
2254 -> 2253;
2254 -> 1405;
2254 -> 1403;
2255 -> 2243;
2256 -> 2255;
2256 -> 2243;
2257 -> 2256;
2257 -> 1428;
2257 -> 1400;
2258 -> 2246;
2259 -> 2258;
2259 -> 2246;
2260 -> 2259;
2260 -> 1448;
2260 -> 1400;
2261 -> 2249;
2262 -> 2261;
2262 -> 2249;
2263 -> 2262;
2263 -> 1468;
2263 -> 1400;
2264 -> 1420;
2265 -> 2264;
2265 -> 1420;
2266 -> 2265;
2266 -> 1413;
2267 -> 2266;
2267 -> 1405;
2267 -> 1403;
2268 -> 2256;
2269 -> 2268;
2269 -> 2256;
2270 -> 2269;
2270 -> 1428;
2270 -> 1400;
2271 -> 2259;
2272 -> 2271;
2272 -> 2259;
2273 -> 2272;
2273 -> 1448;
2273 -> 1400;
2274 -> 2262;
2275 -> 2274;
2275 -> 2262;
2276 -> 2275;
2276 -> 1468;
2276 -> 1400;
2277 -> 1420;
2278 -> 2277;
2278 -> 1420;
2279 -> 2278;
2279 -> 1413;
2280 -> 2279;
2280 -> 1405;
2280 -> 1403;
2281 -> 2269;
2282 -> 2281;
2282 -> 2269;
2283 -> 2282;
2283 -> 1428;
2283 -> 1400;
2284 -> 2272;
2285 -> 2284;
2285 -> 2272;
2286 -> 2285;
2286 -> 1448;
2286 -> 1400;
2287 -> 2275;
2288 -> 2287;
2288 -> 2275;
2289 -> 2288;
2289 -> 1468;
2289 -> 1400;
2290 -> 1420;
2291 -> 2290;
2291 -> 1420;
2292 -> 2291;
2292 -> 1413;
2293 -> 2292;
2293 -> 1405;
2293 -> 1403;
2294 -> 2282;
2295 -> 2294;
2295 -> 2282;
2296 -> 2295;
2296 -> 1428;
2296 -> 1400;
2297 -> 2285;
2298 -> 2297;
2298 -> 2285;
2299 -> 2298;
2299 -> 1448;
2299 -> 1400;
2300 -> 2288;
2301 -> 2300;
2301 -> 2288;
2302 -> 2301;
2302 -> 1468;
2302 -> 1400;
2303 -> 1420;
2304 -> 2303;
2304 -> 1420;
2305 -> 2304;
2305 -> 1413;
2306 -> 2305;
2306 -> 1405;
2306 -> 1403;
2307 -> 2295;
2308 -> 2307;
2308 -> 2295;
2309 -> 2308;
2309 -> 1428;
2309 -> 1400;
2310 -> 2298;
2311 -> 2310;
2311 -> 2298;
2312 -> 2311;
2312 -> 1448;
2312 -> 1400;
2313 -> 2301;
2314 -> 2313;
2314 -> 2301;
2315 -> 2314;
2315 -> 1468;
2315 -> 1400;
2316 -> 1420;
2317 -> 2316;
2317 -> 1420;
2318 -> 2317;
2318 -> 1413;
2319 -> 2318;
2319 -> 1405;
2319 -> 1403;
2320 -> 2308;
2321 -> 2320;
2321 -> 2308;
2322 -> 2321;
2322 -> 1428;
2322 -> 1400;
2323 -> 2311;
2324 -> 2323;
2324 -> 2311;
2325 -> 2324;
2325 -> 1448;
2325 -> 1400;
2326 -> 2314;
2327 -> 2326;
2327 -> 2314;
2328 -> 2327;
2328 -> 1468;
2328 -> 1400;
2329 -> 1420;
2330 -> 2329;
2330 -> 1420;
2331 -> 2330;
2331 -> 1413;
2332 -> 2331;
2332 -> 1405;
2332 -> 1403;
2333 -> 2321;
2334 -> 2333;
2334 -> 2321;
2335 -> 2334;
2335 -> 1428;
2335 -> 1400;
2336 -> 2324;
2337 -> 2336;
2337 -> 2324;
2338 -> 2337;
2338 -> 1448;
2338 -> 1400;
2339 -> 2327;
2340 -> 2339;
2340 -> 2327;
2341 -> 2340;
2341 -> 1468;
2341 -> 1400;
2342 -> 1420;
2343 -> 2342;
2343 -> 1420;
2344 -> 2343;
2344 -> 1413;
2345 -> 2344;
2345 -> 1405;
2345 -> 1403;
2346 -> 2334;
2347 -> 2346;
2347 -> 2334;
2348 -> 2347;
2348 -> 1428;
2348 -> 1400;
2349 -> 2337;
2350 -> 2349;
2350 -> 2337;
2351 -> 2350;
2351 -> 1448;
2351 -> 1400;
2352 -> 2340;
2353 -> 2352;
2353 -> 2340;
2354 -> 2353;
2354 -> 1468;
2354 -> 1400;
2355 -> 1420;
2356 -> 2355;
2356 -> 1420;
2357 -> 2356;
2357 -> 1413;
2358 -> 2357;
2358 -> 1405;
2358 -> 1403;
2359 -> 2347;
2360 -> 2359;
2360 -> 2347;
2361 -> 2360;
2361 -> 1428;
2361 -> 1400;
2362 -> 2350;
2363 -> 2362;
2363 -> 2350;
2364 -> 2363;
2364 -> 1448;
2364 -> 1400;
2365 -> 2353;
2366 -> 2365;
2366 -> 2353;
2367 -> 2366;
2367 -> 1468;
2367 -> 1400;
2368 -> 1420;
2369 -> 2368;
2369 -> 1420;
2370 -> 2369;
2370 -> 1413;
2371 -> 2370;
2371 -> 1405;
2371 -> 1403;
2372 -> 2360;
2373 -> 2372;
2373 -> 2360;
2374 -> 2373;
2374 -> 1428;
2374 -> 1400;
2375 -> 2363;
2376 -> 2375;
2376 -> 2363;
2377 -> 2376;
2377 -> 1448;
2377 -> 1400;
2378 -> 2366;
2379 -> 2378;
2379 -> 2366;
2380 -> 2379;
2380 -> 1468;
2380 -> 1400;
2381 -> 1420;
2382 -> 2381;
2382 -> 1420;
2383 -> 2382;
2383 -> 1413;
2384 -> 2383;
2384 -> 1405;
2384 -> 1403;
2385 -> 2373;
2386 -> 2385;
2386 -> 2373;
2387 -> 2386;
2387 -> 1428;
2387 -> 1400;
2388 -> 2376;
2389 -> 2388;
2389 -> 2376;
2390 -> 2389;
2390 -> 1448;
2390 -> 1400;
2391 -> 2379;
2392 -> 2391;
2392 -> 2379;
2393 -> 2392;
2393 -> 1468;
2393 -> 1400;
2394 -> 1420;
2395 -> 2394;
2395 -> 1420;
2396 -> 2395;
2396 -> 1413;
2397 -> 2396;
2397 -> 1405;
2397 -> 1403;
2398 -> 2386;
2399 -> 2398;
2399 -> 2386;
2400 -> 2399;
2400 -> 1428;
2400 -> 1400;
2401 -> 2389;
2402 -> 2401;
2402 -> 2389;
2403 -> 2402;
2403 -> 1448;
2403 -> 1400;
2404 -> 2392;
2405 -> 2404;
2405 -> 2392;
2406 -> 2405;
2406 -> 1468;
2406 -> 1400;
2407 -> 1420;
2408 -> 2407;
2408 -> 1420;
2409 -> 2408;
2409 -> 1413;
2410 -> 2409;
2410 -> 1405;
2410 -> 1403;
2411 -> 2399;
2412 -> 2411;
2412 -> 2399;
2413 -> 2412;
2413 -> 1428;
2413 -> 1400;
2414 -> 2402;
2415 -> 2414;
2415 -> 2402;
2416 -> 2415;
2416 -> 1448;
2416 -> 1400;
2417 -> 2405;
2418 -> 2417;
2418 -> 2405;
2419 -> 2418;
2419 -> 1468;
2419 -> 1400;
2420 -> 1420;
2421 -> 2420;
2421 -> 1420;
2422 -> 2421;
2422 -> 1413;
2423 -> 2422;
2423 -> 1405;
2423 -> 1403;
2424 -> 2412;
2425 -> 2424;
2425 -> 2412;
2426 -> 2425;
2426 -> 1428;
2426 -> 1400;
2427 -> 2415;
2428 -> 2427;
2428 -> 2415;
2429 -> 2428;
2429 -> 1448;
2429 -> 1400;
2430 -> 2418;
2431 -> 2430;
2431 -> 2418;
2432 -> 2431;
2432 -> 1468;
2432 -> 1400;
2433 -> 1420;
2434 -> 2433;
2434 -> 1420;
2435 -> 2434;
2435 -> 1413;
2436 -> 2435;
2436 -> 1405;
2436 -> 1403;
2437 -> 2425;
2438 -> 2437;
2438 -> 2425;
2439 -> 2438;
2439 -> 1428;
2439 -> 1400;
2440 -> 2428;
2441 -> 2440;
2441 -> 2428;
2442 -> 2441;
2442 -> 1448;
2442 -> 1400;
2443 -> 2431;
2444 -> 2443;
2444 -> 2431;
2445 -> 2444;
2445 -> 1468;
2445 -> 1400;
2446 -> 1420;
2447 -> 2446;
2447 -> 1420;
2448 -> 2447;
2448 -> 1413;
2449 -> 2448;
2449 -> 1405;
2449 -> 1403;
2450 -> 2438;
2451 -> 2450;
2451 -> 2438;
2452 -> 2451;
2452 -> 1428;
2452 -> 1400;
2453 -> 2441;
2454 -> 2453;
2454 -> 2441;
2455 -> 2454;
2455 -> 1448;
2455 -> 1400;
2456 -> 2444;
2457 -> 2456;
2457 -> 2444;
2458 -> 2457;
2458 -> 1468;
2458 -> 1400;
2459 -> 1420;
2460 -> 2459;
2460 -> 1420;
2461 -> 2460;
2461 -> 1413;
2462 -> 2461;
2462 -> 1405;
2462 -> 1403;
2463 -> 2451;
2464 -> 2463;
2464 -> 2451;
2465 -> 2464;
2465 -> 1428;
2465 -> 1400;
2466 -> 2454;
2467 -> 2466;
2467 -> 2454;
2468 -> 2467;
2468 -> 1448;
2468 -> 1400;
2469 -> 2457;
2470 -> 2469;
2470 -> 2457;
2471 -> 2470;
2471 -> 1468;
2471 -> 1400;
2472 -> 1420;
2473 -> 2472;
2473 -> 1420;
2474 -> 2473;
2474 -> 1413;
2475 -> 2474;
2475 -> 1405;
2475 -> 1403;
2476 -> 2464;
2477 -> 2476;
2477 -> 2464;
2478 -> 2477;
2478 -> 1428;
2478 -> 1400;
2479 -> 2467;
2480 -> 2479;
2480 -> 2467;
2481 -> 2480;
2481 -> 1448;
2481 -> 1400;
2482 -> 2470;
2483 -> 2482;
2483 -> 2470;
2484 -> 2483;
2484 -> 1468;
2484 -> 1400;
2485 -> 1420;
2486 -> 2485;
2486 -> 1420;
2487 -> 2486;
2487 -> 1413;
2488 -> 2487;
2488 -> 1405;
2488 -> 1403;
2489 -> 2477;
2490 -> 2489;
2490 -> 2477;
2491 -> 2490;
2491 -> 1428;
2491 -> 1400;
2492 -> 2480;
2493 -> 2492;
2493 -> 2480;
2494 -> 2493;
2494 -> 1448;
2494 -> 1400;
2495 -> 2483;
2496 -> 2495;
2496 -> 2483;
2497 -> 2496;
2497 -> 1468;
2497 -> 1400;
2498 -> 1420;
2499 -> 2498;
2499 -> 1420;
2500 -> 2499;
2500 -> 1413;
2501 -> 2500;
2501 -> 1405;
2501 -> 1403;
2502 -> 2490;
2503 -> 2502;
2503 -> 2490;
2504 -> 2503;
2504 -> 1428;
2504 -> 1400;
2505 -> 2493;
2506 -> 2505;
2506 -> 2493;
2507 -> 2506;
2507 -> 1448;
2507 -> 1400;
2508 -> 2496;
2509 -> 2508;
2509 -> 2496;
2510 -> 2509;
2510 -> 1468;
2510 -> 1400;
2511 -> 1420;
2512 -> 2511;
2512 -> 1420;
2513 -> 2512;
2513 -> 1413;
2514 -> 2513;
2514 -> 1405;
2514 -> 1403;
2515 -> 2503;
2516 -> 2515;
2516 -> 2503;
2517 -> 2516;
2517 -> 1428;
2517 -> 1400;
2518 -> 2506;
2519 -> 2518;
2519 -> 2506;
2520 -> 2519;
2520 -> 1448;
2520 -> 1400;
2521 -> 2509;
2522 -> 2521;
2522 -> 2509;
2523 -> 2522;
2523 -> 1468;
2523 -> 1400;
2524 -> 1420;
2525 -> 2524;
2525 -> 1420;
2526 -> 2525;
2526 -> 1413;
2527 -> 2526;
2527 -> 1405;
2527 -> 1403;
2528 -> 2516;
2529 -> 2528;
2529 -> 2516;
2530 -> 2529;
2530 -> 1428;
2530 -> 1400;
2531 -> 2519;
2532 -> 2531;
2532 -> 2519;
2533 -> 2532;
2533 -> 1448;
2533 -> 1400;
2534 -> 2522;
2535 -> 2534;
2535 -> 2522;
2536 -> 2535;
2536 -> 1468;
2536 -> 1400;
2537 -> 1420;
2538 -> 2537;
2538 -> 1420;
2539 -> 2538;
2539 -> 1413;
2540 -> 2539;
2540 -> 1405;
2540 -> 1403;
2541 -> 2529;
2542 -> 2541;
2542 -> 2529;
2543 -> 2542;
2543 -> 1428;
2543 -> 1400;
2544 -> 2532;
2545 -> 2544;
2545 -> 2532;
2546 -> 2545;
2546 -> 1448;
2546 -> 1400;
2547 -> 2535;
2548 -> 2547;
2548 -> 2535;
2549 -> 2548;
2549 -> 1468;
2549 -> 1400;
2550 -> 1420;
2551 -> 2550;
2551 -> 1420;
2552 -> 2551;
2552 -> 1413;
2553 -> 2552;
2553 -> 1405;
2553 -> 1403;
2554 -> 2542;
2555 -> 2554;
2555 -> 2542;
2556 -> 2555;
2556 -> 1428;
2556 -> 1400;
2557 -> 2545;
2558 -> 2557;
2558 -> 2545;
2559 -> 2558;
2559 -> 1448;
2559 -> 1400;
2560 -> 2548;
2561 -> 2560;
2561 -> 2548;
2562 -> 2561;
2562 -> 1468;
2562 -> 1400;
2563 -> 1420;
2564 -> 2563;
2564 -> 1420;
2565 -> 2564;
2565 -> 1413;
2566 -> 2565;
2566 -> 1405;
2566 -> 1403;
2567 -> 2555;
2568 -> 2567;
2568 -> 2555;
2569 -> 2568;
2569 -> 1428;
2569 -> 1400;
2570 -> 2558;
2571 -> 2570;
2571 -> 2558;
2572 -> 2571;
2572 -> 1448;
2572 -> 1400;
2573 -> 2561;
2574 -> 2573;
2574 -> 2561;
2575 -> 2574;
2575 -> 1468;
2575 -> 1400;
2576 -> 1420;
2577 -> 2576;
2577 -> 1420;
2578 -> 2577;
2578 -> 1413;
2579 -> 2578;
2579 -> 1405;
2579 -> 1403;
2580 -> 2568;
2581 -> 2580;
2581 -> 2568;
2582 -> 2581;
2582 -> 1428;
2582 -> 1400;
2583 -> 2571;
2584 -> 2583;
2584 -> 2571;
2585 -> 2584;
2585 -> 1448;
2585 -> 1400;
2586 -> 2574;
2587 -> 2586;
2587 -> 2574;
2588 -> 2587;
2588 -> 1468;
2588 -> 1400;
2589 -> 1420;
2590 -> 2589;
2590 -> 1420;
2591 -> 2590;
2591 -> 1413;
2592 -> 2591;
2592 -> 1405;
2592 -> 1403;
2593 -> 2581;
2594 -> 2593;
2594 -> 2581;
2595 -> 2594;
2595 -> 1428;
2595 -> 1400;
2596 -> 2584;
2597 -> 2596;
2597 -> 2584;
2598 -> 2597;
2598 -> 1448;
2598 -> 1400;
2599 -> 2587;
2600 -> 2599;
2600 -> 2587;
2601 -> 2600;
2601 -> 1468;
2601 -> 1400;
2602 -> 1420;
2603 -> 2602;
2603 -> 1420;
2604 -> 2603;
2604 -> 1413;
2605 -> 2604;
2605 -> 1405;
2605 -> 1403;
2606 -> 2594;
2607 -> 2606;
2607 -> 2594;
2608 -> 2607;
2608 -> 1428;
2608 -> 1400;
2609 -> 2597;
2610 -> 2609;
2610 -> 2597;
2611 -> 2610;
2611 -> 1448;
2611 -> 1400;
2612 -> 2600;
2613 -> 2612;
2613 -> 2600;
2614 -> 2613;
2614 -> 1468;
2614 -> 1400;
2615 -> 1420;
2616 -> 2615;
2616 -> 1420;
2617 -> 2616;
2617 -> 1413;
2618 -> 2617;
2618 -> 1405;
2618 -> 1403;
2619 -> 2607;
2620 -> 2619;
2620 -> 2607;
2621 -> 2620;
2621 -> 1428;
2621 -> 1400;
2622 -> 2610;
2623 -> 2622;
2623 -> 2610;
2624 -> 2623;
2624 -> 1448;
2624 -> 1400;
2625 -> 2613;
2626 -> 2625;
2626 -> 2613;
2627 -> 2626;
2627 -> 1468;
2627 -> 1400;
2628 -> 1420;
2629 -> 2628;
2629 -> 1420;
2630 -> 2629;
2630 -> 1413;
2631 -> 2630;
2631 -> 1405;
2631 -> 1403;
2632 -> 2620;
2633 -> 2632;
2633 -> 2620;
2634 -> 2633;
2634 -> 1428;
2634 -> 1400;
2635 -> 2623;
2636 -> 2635;
2636 -> 2623;
2637 -> 2636;
2637 -> 1448;
2637 -> 1400;
2638 -> 2626;
2639 -> 2638;
2639 -> 2626;
2640 -> 2639;
2640 -> 1468;
2640 -> 1400;
2641 -> 1420;
2642 -> 2641;
2642 -> 1420;
2643 -> 2642;
2643 -> 1413;
2644 -> 2643;
2644 -> 1405;
2644 -> 1403;
2645 -> 2633;
2646 -> 2645;
2646 -> 2633;
2647 -> 2646;
2647 -> 1428;
2647 -> 1400;
2648 -> 2636;
2649 -> 2648;
2649 -> 2636;
2650 -> 2649;
2650 -> 1448;
2650 -> 1400;
2651 -> 2639;
2652 -> 2651;
2652 -> 2639;
2653 -> 2652;
2653 -> 1468;
2653 -> 1400;
2654 -> 1420;
2655 -> 2654;
2655 -> 1420;
2656 -> 2655;
2656 -> 1413;
2657 -> 2656;
2657 -> 1405;
2657 -> 1403;
2658 -> 2646;
2659 -> 2658;
2659 -> 2646;
2660 -> 2659;
2660 -> 1428;
2660 -> 1400;
2661 -> 2649;
2662 -> 2661;
2662 -> 2649;
2663 -> 2662;
2663 -> 1448;
2663 -> 1400;
2664 -> 2652;
2665 -> 2664;
2665 -> 2652;
2666 -> 2665;
2666 -> 1468;
2666 -> 1400;
2667 -> 1420;
2668 -> 2667;
2668 -> 1420;
2669 -> 2668;
2669 -> 1413;
2670 -> 2669;
2670 -> 1405;
2670 -> 1403;
2671 -> 2659;
2672 -> 2671;
2672 -> 2659;
2673 -> 2672;
2673 -> 1428;
2673 -> 1400;
2674 -> 2662;
2675 -> 2674;
2675 -> 2662;
2676 -> 2675;
2676 -> 1448;
2676 -> 1400;
2677 -> 2665;
2678 -> 2677;
2678 -> 2665;
2679 -> 2678;
2679 -> 1468;
2679 -> 1400;
2680 -> 1420;
2681 -> 2680;
2681 -> 1420;
2682 -> 2681;
2682 -> 1413;
2683 -> 2682;
2683 -> 1405;
2683 -> 1403;
2684 -> 2672;
2685 -> 2684;
2685 -> 2672;
2686 -> 2685;
2686 -> 1428;
2686 -> 1400;
2687 -> 2675;
2688 -> 2687;
2688 -> 2675;
2689 -> 2688;
2689 -> 1448;
2689 -> 1400;
2690 -> 2678;
2691 -> 2690;
2691 -> 2678;
2692 -> 2691;
2692 -> 1468;
2692 -> 1400;
2693 -> 1420;
2694 -> 2693;
2694 -> 1420;
2695 -> 2694;
2695 -> 1413;
2696 -> 2695;
2696 -> 1405;
2696 -> 1403;
2697 -> 2685;
2698 -> 2697;
2698 -> 2685;
2699 -> 2698;
2699 -> 1428;
2699 -> 1400;
2700 -> 2688;
2701 -> 2700;
2701 -> 2688;
2702 -> 2701;
2702 -> 1448;
2702 -> 1400;
2703 -> 2691;
2704 -> 2703;
2704 -> 2691;
2705 -> 2704;
2705 -> 1468;
2705 -> 1400;
2706 -> 1420;
2707 -> 2706;
2707 -> 1420;
2708 -> 2707;
2708 -> 1413;
2709 -> 2708;
2709 -> 1405;
2709 -> 1403;
2710 -> 2698;
2711 -> 2710;
2711 -> 2698;
2712 -> 2711;
2712 -> 1428;
2712 -> 1400;
2713 -> 2701;
2714 -> 2713;
2714 -> 2701;
2715 -> 2714;
2715 -> 1448;
2715 -> 1400;
2716 -> 2704;
2717 -> 2716;
2717 -> 2704;
2718 -> 2717;
2718 -> 1468;
2718 -> 1400;
2719 -> 1420;
2720 -> 2719;
2720 -> 1420;
2721 -> 2720;
2721 -> 1413;
2722 -> 2721;
2722 -> 1405;
2722 -> 1403;
2723 -> 2711;
2724 -> 2723;
2724 -> 2711;
2725 -> 2724;
2725 -> 1428;
2725 -> 1400;
2726 -> 2714;
2727 -> 2726;
2727 -> 2714;
2728 -> 2727;
2728 -> 1448;
2728 -> 1400;
2729 -> 2717;
2730 -> 2729;
2730 -> 2717;
2731 -> 2730;
2731 -> 1468;
2731 -> 1400;
2732 -> 1420;
2733 -> 2732;
2733 -> 1420;
2734 -> 2733;
2734 -> 1413;
2735 -> 2734;
2735 -> 1405;
2735 -> 1403;
2736 -> 2724;
2737 -> 2736;
2737 -> 2724;
2738 -> 2737;
2738 -> 1428;
2738 -> 1400;
2739 -> 2727;
2740 -> 2739;
2740 -> 2727;
2741 -> 2740;
2741 -> 1448;
2741 -> 1400;
2742 -> 2730;
2743 -> 2742;
2743 -> 2730;
2744 -> 2743;
2744 -> 1468;
2744 -> 1400;
2745 -> 1420;
2746 -> 2745;
2746 -> 1420;
2747 -> 2746;
2747 -> 1413;
2748 -> 2747;
2748 -> 1405;
2748 -> 1403;
2749 -> 2737;
2750 -> 2749;
2750 -> 2737;
2751 -> 2750;
2751 -> 1428;
2751 -> 1400;
2752 -> 2740;
2753 -> 2752;
2753 -> 2740;
2754 -> 2753;
2754 -> 1448;
2754 -> 1400;
2755 -> 2743;
2756 -> 2755;
2756 -> 2743;
2757 -> 2756;
2757 -> 1468;
2757 -> 1400;
2758 -> 1420;
2759 -> 2758;
2759 -> 1420;
2760 -> 2759;
2760 -> 1413;
2761 -> 2760;
2761 -> 1405;
2761 -> 1403;
2762 -> 2750;
2763 -> 2762;
2763 -> 2750;
2764 -> 2763;
2764 -> 1428;
2764 -> 1400;
2765 -> 2753;
2766 -> 2765;
2766 -> 2753;
2767 -> 2766;
2767 -> 1448;
2767 -> 1400;
2768 -> 2756;
2769 -> 2768;
2769 -> 2756;
2770 -> 2769;
2770 -> 1468;
2770 -> 1400;
2771 -> 1420;
2772 -> 2771;
2772 -> 1420;
2773 -> 2772;
2773 -> 1413;
2774 -> 2773;
2774 -> 1405;
2774 -> 1403;
2775 -> 2763;
2776 -> 2775;
2776 -> 2763;
2777 -> 2776;
2777 -> 1428;
2777 -> 1400;
2778 -> 2766;
2779 -> 2778;
2779 -> 2766;
2780 -> 2779;
2780 -> 1448;
2780 -> 1400;
2781 -> 2769;
2782 -> 2781;
2782 -> 2769;
2783 -> 2782;
2783 -> 1468;
2783 -> 1400;
2784 -> 1420;
2785 -> 2784;
2785 -> 1420;
2786 -> 2785;
2786 -> 1413;
2787 -> 2786;
2787 -> 1405;
2787 -> 1403;
2788 -> 2776;
2789 -> 2788;
2789 -> 2776;
2790 -> 2789;
2790 -> 1428;
2790 -> 1400;
2791 -> 2779;
2792 -> 2791;
2792 -> 2779;
2793 -> 2792;
2793 -> 1448;
2793 -> 1400;
2794 -> 2782;
2795 -> 2794;
2795 -> 2782;
2796 -> 2795;
2796 -> 1468;
2796 -> 1400;
2797 -> 1420;
2798 -> 2797;
2798 -> 1420;
2799 -> 2798;
2799 -> 1413;
2800 -> 2799;
2800 -> 1405;
2800 -> 1403;
2801 -> 2789;
2802 -> 2801;
2802 -> 2789;
2803 -> 2802;
2803 -> 1428;
2803 -> 1400;
2804 -> 2792;
2805 -> 2804;
2805 -> 2792;
2806 -> 2805;
2806 -> 1448;
2806 -> 1400;
2807 -> 2795;
2808 -> 2807;
2808 -> 2795;
2809 -> 2808;
2809 -> 1468;
2809 -> 1400;
2810 -> 1420;
2811 -> 2810;
2811 -> 1420;
2812 -> 2811;
2812 -> 1413;
2813 -> 2812;
2813 -> 1405;
2813 -> 1403;
2814 -> 2802;
2815 -> 2814;
2815 -> 2802;
2816 -> 2815;
2816 -> 1428;
2816 -> 1400;
2817 -> 2805;
2818 -> 2817;
2818 -> 2805;
2819 -> 2818;
2819 -> 1448;
2819 -> 1400;
2820 -> 2808;
2821 -> 2820;
2821 -> 2808;
2822 -> 2821;
2822 -> 1468;
2822 -> 1400;
2823 -> 1420;
2824 -> 2823;
2824 -> 1420;
2825 -> 2824;
2825 -> 1413;
2826 -> 2825;
2826 -> 1405;
2826 -> 1403;
2827 -> 2815;
2828 -> 2827;
2828 -> 2815;
2829 -> 2828;
2829 -> 1428;
2829 -> 1400;
2830 -> 2818;
2831 -> 2830;
2831 -> 2818;
2832 -> 2831;
2832 -> 1448;
2832 -> 1400;
2833 -> 2821;
2834 -> 2833;
2834 -> 2821;
2835 -> 2834;
2835 -> 1468;
2835 -> 1400;
2836 -> 1420;
2837 -> 2836;
2837 -> 1420;
2838 -> 2837;
2838 -> 1413;
2839 -> 2838;
2839 -> 1405;
2839 -> 1403;
2840 -> 2828;
2841 -> 2840;
2841 -> 2828;
2842 -> 2841;
2842 -> 1428;
2842 -> 1400;
2843 -> 2831;
2844 -> 2843;
2844 -> 2831;
2845 -> 2844;
2845 -> 1448;
2845 -> 1400;
2846 -> 2834;
2847 -> 2846;
2847 -> 2834;
2848 -> 2847;
2848 -> 1468;
2848 -> 1400;
2849 -> 1420;
2850 -> 2849;
2850 -> 1420;
2851 -> 2850;
2851 -> 1413;
2852 -> 2851;
2852 -> 1405;
2852 -> 1403;
2853 -> 2841;
2854 -> 2853;
2854 -> 2841;
2855 -> 2854;
2855 -> 1428;
2855 -> 1400;
2856 -> 2844;
2857 -> 2856;
2857 -> 2844;
2858 -> 2857;
2858 -> 1448;
2858 -> 1400;
2859 -> 2847;
2860 -> 2859;
2860 -> 2847;
2861 -> 2860;
2861 -> 1468;
2861 -> 1400;
2862 -> 1420;
2863 -> 2862;
2863 -> 1420;
2864 -> 2863;
2864 -> 1413;
2865 -> 2864;
2865 -> 1405;
2865 -> 1403;
2866 -> 2854;
2867 -> 2866;
2867 -> 2854;
2868 -> 2867;
2868 -> 1428;
2868 -> 1400;
2869 -> 2857;
2870 -> 2869;
2870 -> 2857;
2871 -> 2870;
2871 -> 1448;
2871 -> 1400;
2872 -> 2860;
2873 -> 2872;
2873 -> 2860;
2874 -> 2873;
2874 -> 1468;
2874 -> 1400;
2875 -> 1420;
2876 -> 2875;
2876 -> 1420;
2877 -> 2876;
2877 -> 1413;
2878 -> 2877;
2878 -> 1405;
2878 -> 1403;
2879 -> 2867;
2880 -> 2879;
2880 -> 2867;
2881 -> 2880;
2881 -> 1428;
2881 -> 1400;
2882 -> 2870;
2883 -> 2882;
2883 -> 2870;
2884 -> 2883;
2884 -> 1448;
2884 -> 1400;
2885 -> 2873;
2886 -> 2885;
2886 -> 2873;
2887 -> 2886;
2887 -> 1468;
2887 -> 1400;
2888 -> 1420;
2889 -> 2888;
2889 -> 1420;
2890 -> 2889;
2890 -> 1413;
2891 -> 2890;
2891 -> 1405;
2891 -> 1403;
2892 -> 2880;
2893 -> 2892;
2893 -> 2880;
2894 -> 2893;
2894 -> 1428;
2894 -> 1400;
2895 -> 2883;
2896 -> 2895;
2896 -> 2883;
2897 -> 2896;
2897 -> 1448;
2897 -> 1400;
2898 -> 2886;
2899 -> 2898;
2899 -> 2886;
2900 -> 2899;
2900 -> 1468;
2900 -> 1400;
2901 -> 1420;
2902 -> 2901;
2902 -> 1420;
2903 -> 2902;
2903 -> 1413;
2904 -> 2903;
2904 -> 1405;
2904 -> 1403;
2905 -> 2893;
2906 -> 2905;
2906 -> 2893;
2907 -> 2906;
2907 -> 1428;
2907 -> 1400;
2908 -> 2896;
2909 -> 2908;
2909 -> 2896;
2910 -> 2909;
2910 -> 1448;
2910 -> 1400;
2911 -> 2899;
2912 -> 2911;
2912 -> 2899;
2913 -> 2912;
2913 -> 1468;
2913 -> 1400;
2914 -> 1420;
2915 -> 2914;
2915 -> 1420;
2916 -> 2915;
2916 -> 1413;
2917 -> 2916;
2917 -> 1405;
2917 -> 1403;
2918 -> 2906;
2919 -> 2918;
2919 -> 2906;
2920 -> 2919;
2920 -> 1428;
2920 -> 1400;
2921 -> 2909;
2922 -> 2921;
2922 -> 2909;
2923 -> 2922;
2923 -> 1448;
2923 -> 1400;
2924 -> 2912;
2925 -> 2924;
2925 -> 2912;
2926 -> 2925;
2926 -> 1468;
2926 -> 1400;
2927 -> 1420;
2928 -> 2927;
2928 -> 1420;
2929 -> 2928;
2929 -> 1413;
2930 -> 2929;
2930 -> 1405;
2930 -> 1403;
2931 -> 2919;
2932 -> 2931;
2932 -> 2919;
2933 -> 2932;
2933 -> 1428;
2933 -> 1400;
2934 -> 2922;
2935 -> 2934;
2935 -> 2922;
2936 -> 2935;
2936 -> 1448;
2936 -> 1400;
2937 -> 2925;
2938 -> 2937;
2938 -> 2925;
2939 -> 2938;
2939 -> 1468;
2939 -> 1400;
2940 -> 1420;
2941 -> 2940;
2941 -> 1420;
2942 -> 2941;
2942 -> 1413;
2943 -> 2942;
2943 -> 1405;
2943 -> 1403;
2944 -> 2932;
2945 -> 2944;
2945 -> 2932;
2946 -> 2945;
2946 -> 1428;
2946 -> 1400;
2947 -> 2935;
2948 -> 2947;
2948 -> 2935;
2949 -> 2948;
2949 -> 1448;
2949 -> 1400;
2950 -> 2938;
2951 -> 2950;
2951 -> 2938;
2952 -> 2951;
2952 -> 1468;
2952 -> 1400;
2953 -> 1420;
2954 -> 2953;
2954 -> 1420;
2955 -> 2954;
2955 -> 1413;
2956 -> 2955;
2956 -> 1405;
2956 -> 1403;
2957 -> 2945;
2958 -> 2957;
2958 -> 2945;
2959 -> 2958;
2959 -> 1428;
2959 -> 1400;
2960 -> 2948;
2961 -> 2960;
2961 -> 2948;
2962 -> 2961;
2962 -> 1448;
2962 -> 1400;
2963 -> 2951;
2964 -> 2963;
2964 -> 2951;
2965 -> 2964;
2965 -> 1468;
2965 -> 1400;
2966 -> 1420;
2967 -> 2966;
2967 -> 1420;
2968 -> 2967;
2968 -> 1413;
2969 -> 2968;
2969 -> 1405;
2969 -> 1403;
2970 -> 2958;
2971 -> 2970;
2971 -> 2958;
2972 -> 2971;
2972 -> 1428;
2972 -> 1400;
2973 -> 2961;
2974 -> 2973;
2974 -> 2961;
2975 -> 2974;
2975 -> 1448;
2975 -> 1400;
2976 -> 2964;
2977 -> 2976;
2977 -> 2964;
2978 -> 2977;
2978 -> 1468;
2978 -> 1400;
2979 -> 1420;
2980 -> 2979;
2980 -> 1420;
2981 -> 2980;
2981 -> 1413;
2982 -> 2981;
2982 -> 1405;
2982 -> 1403;
2983 -> 2971;
2984 -> 2983;
2984 -> 2971;
2985 -> 2984;
2985 -> 1428;
2985 -> 1400;
2986 -> 2974;
2987 -> 2986;
2987 -> 2974;
2988 -> 2987;
2988 -> 1448;
2988 -> 1400;
2989 -> 2977;
2990 -> 2989;
2990 -> 2977;
2991 -> 2990;
2991 -> 1468;
2991 -> 1400;
2992 -> 1420;
2993 -> 2992;
2993 -> 1420;
2994 -> 2993;
2994 -> 1413;
2995 -> 2994;
2995 -> 1405;
2995 -> 1403;
2996 -> 2984;
2997 -> 2996;
2997 -> 2984;
2998 -> 2997;
2998 -> 1428;
2998 -> 1400;
2999 -> 2987;
3000 -> 2999;
3000 -> 2987;
3001 -> 3000;
3001 -> 1448;
3001 -> 1400;
3002 -> 2990;
3003 -> 3002;
3003 -> 2990;
3004 -> 3003;
3004 -> 1468;
3004 -> 1400;
3005 -> 1420;
3006 -> 3005;
3006 -> 1420;
3007 -> 3006;
3007 -> 1413;
3008 -> 3007;
3008 -> 1405;
3008 -> 1403;
3009 -> 2997;
3010 -> 3009;
3010 -> 2997;
3011 -> 3010;
3011 -> 1428;
3011 -> 1400;
3012 -> 3000;
3013 -> 3012;
3013 -> 3000;
3014 -> 3013;
3014 -> 1448;
3014 -> 1400;
3015 -> 3003;
3016 -> 3015;
3016 -> 3003;
3017 -> 3016;
3017 -> 1468;
3017 -> 1400;
3018 -> 1420;
3019 -> 3018;
3019 -> 1420;
3020 -> 3019;
3020 -> 1413;
3021 -> 3020;
3021 -> 1405;
3021 -> 1403;
3022 -> 3010;
3023 -> 3022;
3023 -> 3010;
3024 -> 3023;
3024 -> 1428;
3024 -> 1400;
3025 -> 3013;
3026 -> 3025;
3026 -> 3013;
3027 -> 3026;
3027 -> 1448;
3027 -> 1400;
3028 -> 3016;
3029 -> 3028;
3029 -> 3016;
3030 -> 3029;
3030 -> 1468;
3030 -> 1400;
3031 -> 1420;
3032 -> 3031;
3032 -> 1420;
3033 -> 3032;
3033 -> 1413;
3034 -> 3033;
3034 -> 1405;
3034 -> 1403;
3035 -> 3023;
3036 -> 3035;
3036 -> 3023;
3037 -> 3036;
3037 -> 1428;
3037 -> 1400;
3038 -> 3026;
3039 -> 3038;
3039 -> 3026;
3040 -> 3039;
3040 -> 1448;
3040 -> 1400;
3041 -> 3029;
3042 -> 3041;
3042 -> 3029;
3043 -> 3042;
3043 -> 1468;
3043 -> 1400;
3044 -> 1420;
3045 -> 3044;
3045 -> 1420;
3046 -> 3045;
3046 -> 1413;
3047 -> 3046;
3047 -> 1405;
3047 -> 1403;
3048 -> 3036;
3049 -> 3048;
3049 -> 3036;
3050 -> 3049;
3050 -> 1428;
3050 -> 1400;
3051 -> 3039;
3052 -> 3051;
3052 -> 3039;
3053 -> 3052;
3053 -> 1448;
3053 -> 1400;
3054 -> 3042;
3055 -> 3054;
3055 -> 3042;
3056 -> 3055;
3056 -> 1468;
3056 -> 1400;
3057 -> 1420;
3058 -> 3057;
3058 -> 1420;
3059 -> 3058;
3059 -> 1413;
3060 -> 3059;
3060 -> 1405;
3060 -> 1403;
3061 -> 3049;
3062 -> 3061;
3062 -> 3049;
3063 -> 3062;
3063 -> 1428;
3063 -> 1400;
3064 -> 3052;
3065 -> 3064;
3065 -> 3052;
3066 -> 3065;
3066 -> 1448;
3066 -> 1400;
3067 -> 3055;
3068 -> 3067;
3068 -> 3055;
3069 -> 3068;
3069 -> 1468;
3069 -> 1400;
3070 -> 1420;
3071 -> 3070;
3071 -> 1420;
3072 -> 3071;
3072 -> 1413;
3073 -> 3072;
3073 -> 1405;
3073 -> 1403;
3074 -> 3062;
3075 -> 3074;
3075 -> 3062;
3076 -> 3075;
3076 -> 1428;
3076 -> 1400;
3077 -> 3065;
3078 -> 3077;
3078 -> 3065;
3079 -> 3078;
3079 -> 1448;
3079 -> 1400;
3080 -> 3068;
3081 -> 3080;
3081 -> 3068;
3082 -> 3081;
3082 -> 1468;
3082 -> 1400;
3083 -> 1420;
3084 -> 3083;
3084 -> 1420;
3085 -> 3084;
3085 -> 1413;
3086 -> 3085;
3086 -> 1405;
3086 -> 1403;
3087 -> 3075;
3088 -> 3087;
3088 -> 3075;
3089 -> 3088;
3089 -> 1428;
3089 -> 1400;
3090 -> 3078;
3091 -> 3090;
3091 -> 3078;
3092 -> 3091;
3092 -> 1448;
3092 -> 1400;
3093 -> 3081;
3094 -> 3093;
3094 -> 3081;
3095 -> 3094;
3095 -> 1468;
3095 -> 1400;
3096 -> 1420;
3097 -> 3096;
3097 -> 1420;
3098 -> 3097;
3098 -> 1413;
3099 -> 3098;
3099 -> 1405;
3099 -> 1403;
3100 -> 3088;
3101 -> 3100;
3101 -> 3088;
3102 -> 3101;
3102 -> 1428;
3102 -> 1400;
3103 -> 3091;
3104 -> 3103;
3104 -> 3091;
3105 -> 3104;
3105 -> 1448;
3105 -> 1400;
3106 -> 3094;
3107 -> 3106;
3107 -> 3094;
3108 -> 3107;
3108 -> 1468;
3108 -> 1400;
3109 -> 1420;
3110 -> 3109;
3110 -> 1420;
3111 -> 3110;
3111 -> 1413;
3112 -> 3111;
3112 -> 1405;
3112 -> 1403;
3113 -> 3101;
3114 -> 3113;
3114 -> 3101;
3115 -> 3114;
3115 -> 1428;
3115 -> 1400;
3116 -> 3104;
3117 -> 3116;
3117 -> 3104;
3118 -> 3117;
3118 -> 1448;
3118 -> 1400;
3119 -> 3107;
3120 -> 3119;
3120 -> 3107;
3121 -> 3120;
3121 -> 1468;
3121 -> 1400;
3122 -> 1420;
3123 -> 3122;
3123 -> 1420;
3124 -> 3123;
3124 -> 1413;
3125 -> 3124;
3125 -> 1405;
3125 -> 1403;
3126 -> 3114;
3127 -> 3126;
3127 -> 3114;
3128 -> 3127;
3128 -> 1428;
3128 -> 1400;
3129 -> 3117;
3130 -> 3129;
3130 -> 3117;
3131 -> 3130;
3131 -> 1448;
3131 -> 1400;
3132 -> 3120;
3133 -> 3132;
3133 -> 3120;
3134 -> 3133;
3134 -> 1468;
3134 -> 1400;
3135 -> 1420;
3136 -> 3135;
3136 -> 1420;
3137 -> 3136;
3137 -> 1413;
3138 -> 3137;
3138 -> 1405;
3138 -> 1403;
3139 -> 3127;
3140 -> 3139;
3140 -> 3127;
3141 -> 3140;
3141 -> 1428;
3141 -> 1400;
3142 -> 3130;
3143 -> 3142;
3143 -> 3130;
3144 -> 3143;
3144 -> 1448;
3144 -> 1400;
3145 -> 3133;
3146 -> 3145;
3146 -> 3133;
3147 -> 3146;
3147 -> 1468;
3147 -> 1400;
3148 -> 1420;
3149 -> 3148;
3149 -> 1420;
3150 -> 3149;
3150 -> 1413;
3151 -> 3150;
3151 -> 1405;
3151 -> 1403;
3152 -> 3140;
3153 -> 3152;
3153 -> 3140;
3154 -> 3153;
3154 -> 1428;
3154 -> 1400;
3155 -> 3143;
3156 -> 3155;
3156 -> 3143;
3157 -> 3156;
3157 -> 1448;
3157 -> 1400;
3158 -> 3146;
3159 -> 3158;
3159 -> 3146;
3160 -> 3159;
3160 -> 1468;
3160 -> 1400;
3161 -> 1420;
3162 -> 3161;
3162 -> 1420;
3163 -> 3162;
3163 -> 1413;
3164 -> 3163;
3164 -> 1405;
3164 -> 1403;
3165 -> 3153;
3166 -> 3165;
3166 -> 3153;
3167 -> 3166;
3167 -> 1428;
3167 -> 1400;
3168 -> 3156;
3169 -> 3168;
3169 -> 3156;
3170 -> 3169;
3170 -> 1448;
3170 -> 1400;
3171 -> 3159;
3172 -> 3171;
3172 -> 3159;
3173 -> 3172;
3173 -> 1468;
3173 -> 1400;
3174 -> 1420;
3175 -> 3174;
3175 -> 1420;
3176 -> 3175;
3176 -> 1413;
3177 -> 3176;
3177 -> 1405;
3177 -> 1403;
3178 -> 3166;
3179 -> 3178;
3179 -> 3166;
3180 -> 3179;
3180 -> 1428;
3180 -> 1400;
3181 -> 3169;
3182 -> 3181;
3182 -> 3169;
3183 -> 3182;
3183 -> 1448;
3183 -> 1400;
3184 -> 3172;
3185 -> 3184;
3185 -> 3172;
3186 -> 3185;
3186 -> 1468;
3186 -> 1400;
3187 -> 1420;
3188 -> 3187;
3188 -> 1420;
3189 -> 3188;
3189 -> 1413;
3190 -> 3189;
3190 -> 1405;
3190 -> 1403;
3191 -> 3179;
3192 -> 3191;
3192 -> 3179;
3193 -> 3192;
3193 -> 1428;
3193 -> 1400;
3194 -> 3182;
3195 -> 3194;
3195 -> 3182;
3196 -> 3195;
3196 -> 1448;
3196 -> 1400;
3197 -> 3185;
3198 -> 3197;
3198 -> 3185;
3199 -> 3198;
3199 -> 1468;
3199 -> 1400;
3200 -> 1420;
3201 -> 3200;
3201 -> 1420;
3202 -> 3201;
3202 -> 1413;
3203 -> 3202;
3203 -> 1405;
3203 -> 1403;
3204 -> 3192;
3205 -> 3204;
3205 -> 3192;
3206 -> 3205;
3206 -> 1428;
3206 -> 1400;
3207 -> 3195;
3208 -> 3207;
3208 -> 3195;
3209 -> 3208;
3209 -> 1448;
3209 -> 1400;
3210 -> 3198;
3211 -> 3210;
3211 -> 3198;
3212 -> 3211;
3212 -> 1468;
3212 -> 1400;
3213 -> 1420;
3214 -> 3213;
3214 -> 1420;
3215 -> 3214;
3215 -> 1413;
3216 -> 3215;
3216 -> 1405;
3216 -> 1403;
3217 -> 3205;
3218 -> 3217;
3218 -> 3205;
3219 -> 3218;
3219 -> 1428;
3219 -> 1400;
3220 -> 3208;
3221 -> 3220;
3221 -> 3208;
3222 -> 3221;
3222 -> 1448;
3222 -> 1400;
3223 -> 3211;
3224 -> 3223;
3224 -> 3211;
3225 -> 3224;
3225 -> 1468;
3225 -> 1400;
3226 -> 1420;
3227 -> 3226;
3227 -> 1420;
3228 -> 3227;
3228 -> 1413;
3229 -> 3228;
3229 -> 1405;
3229 -> 1403;
3230 -> 3218;
3231 -> 3230;
3231 -> 3218;
3232 -> 3231;
3232 -> 1428;
3232 -> 1400;
3233 -> 3221;
3234 -> 3233;
3234 -> 3221;
3235 -> 3234;
3235 -> 1448;
3235 -> 1400;
3236 -> 3224;
3237 -> 3236;
3237 -> 3224;
3238 -> 3237;
3238 -> 1468;
3238 -> 1400;
3239 -> 1420;
3240 -> 3239;
3240 -> 1420;
3241 -> 3240;
3241 -> 1413;
3242 -> 3241;
3242 -> 1405;
3242 -> 1403;
3243 -> 3231;
3244 -> 3243;
3244 -> 3231;
3245 -> 3244;
3245 -> 1428;
3245 -> 1400;
3246 -> 3234;
3247 -> 3246;
3247 -> 3234;
3248 -> 3247;
3248 -> 1448;
3248 -> 1400;
3249 -> 3237;
3250 -> 3249;
3250 -> 3237;
3251 -> 3250;
3251 -> 1468;
3251 -> 1400;
3252 -> 1420;
3253 -> 3252;
3253 -> 1420;
3254 -> 3253;
3254 -> 1413;
3255 -> 3254;
3255 -> 1405;
3255 -> 1403;
3256 -> 3244;
3257 -> 3256;
3257 -> 3244;
3258 -> 3257;
3258 -> 1428;
3258 -> 1400;
3259 -> 3247;
3260 -> 3259;
3260 -> 3247;
3261 -> 3260;
3261 -> 1448;
3261 -> 1400;
3262 -> 3250;
3263 -> 3262;
3263 -> 3250;
3264 -> 3263;
3264 -> 1468;
3264 -> 1400;
3265 -> 1420;
3266 -> 3265;
3266 -> 1420;
3267 -> 3266;
3267 -> 1413;
3268 -> 3267;
3268 -> 1405;
3268 -> 1403;
3269 -> 3257;
3270 -> 3269;
3270 -> 3257;
3271 -> 3270;
3271 -> 1428;
3271 -> 1400;
3272 -> 3260;
3273 -> 3272;
3273 -> 3260;
3274 -> 3273;
3274 -> 1448;
3274 -> 1400;
3275 -> 3263;
3276 -> 3275;
3276 -> 3263;
3277 -> 3276;
3277 -> 1468;
3277 -> 1400;
3278 -> 1420;
3279 -> 3278;
3279 -> 1420;
3280 -> 3279;
3280 -> 1413;
3281 -> 3280;
3281 -> 1405;
3281 -> 1403;
3282 -> 3270;
3283 -> 3282;
3283 -> 3270;
3284 -> 3283;
3284 -> 1428;
3284 -> 1400;
3285 -> 3273;
3286 -> 3285;
3286 -> 3273;
3287 -> 3286;
3287 -> 1448;
3287 -> 1400;
3288 -> 3276;
3289 -> 3288;
3289 -> 3276;
3290 -> 3289;
3290 -> 1468;
3290 -> 1400;
3291 -> 1420;
3292 -> 3291;
3292 -> 1420;
3293 -> 3292;
3293 -> 1413;
3294 -> 3293;
3294 -> 1405;
3294 -> 1403;
3295 -> 3283;
3296 -> 3295;
3296 -> 3283;
3297 -> 3296;
3297 -> 1428;
3297 -> 1400;
3298 -> 3286;
3299 -> 3298;
3299 -> 3286;
3300 -> 3299;
3300 -> 1448;
3300 -> 1400;
3301 -> 3289;
3302 -> 3301;
3302 -> 3289;
3303 -> 3302;
3303 -> 1468;
3303 -> 1400;
3304 -> 1420;
3305 -> 3304;
3305 -> 1420;
3306 -> 3305;
3306 -> 1413;
3307 -> 3306;
3307 -> 1405;
3307 -> 1403;
3308 -> 3296;
3309 -> 3308;
3309 -> 3296;
3310 -> 3309;
3310 -> 1428;
3310 -> 1400;
3311 -> 3299;
3312 -> 3311;
3312 -> 3299;
3313 -> 3312;
3313 -> 1448;
3313 -> 1400;
3314 -> 3302;
3315 -> 3314;
3315 -> 3302;
3316 -> 3315;
3316 -> 1468;
3316 -> 1400;
3317 -> 1420;
3318 -> 3317;
3318 -> 1420;
3319 -> 3318;
3319 -> 1413;
3320 -> 3319;
3320 -> 1405;
3320 -> 1403;
3321 -> 3309;
3322 -> 3321;
3322 -> 3309;
3323 -> 3322;
3323 -> 1428;
3323 -> 1400;
3324 -> 3312;
3325 -> 3324;
3325 -> 3312;
3326 -> 3325;
3326 -> 1448;
3326 -> 1400;
3327 -> 3315;
3328 -> 3327;
3328 -> 3315;
3329 -> 3328;
3329 -> 1468;
3329 -> 1400;
3330 -> 1420;
3331 -> 3330;
3331 -> 1420;
3332 -> 3331;
3332 -> 1413;
3333 -> 3332;
3333 -> 1405;
3333 -> 1403;
3334 -> 3322;
3335 -> 3334;
3335 -> 3322;
3336 -> 3335;
3336 -> 1428;
3336 -> 1400;
3337 -> 3325;
3338 -> 3337;
3338 -> 3325;
3339 -> 3338;
3339 -> 1448;
3339 -> 1400;
3340 -> 3328;
3341 -> 3340;
3341 -> 3328;
3342 -> 3341;
3342 -> 1468;
3342 -> 1400;
3343 -> 1420;
3344 -> 3343;
3344 -> 1420;
3345 -> 3344;
3345 -> 1413;
3346 -> 3345;
3346 -> 1405;
3346 -> 1403;
3347 -> 3335;
3348 -> 3347;
3348 -> 3335;
3349 -> 3348;
3349 -> 1428;
3349 -> 1400;
3350 -> 3338;
3351 -> 3350;
3351 -> 3338;
3352 -> 3351;
3352 -> 1448;
3352 -> 1400;
3353 -> 3341;
3354 -> 3353;
3354 -> 3341;
3355 -> 3354;
3355 -> 1468;
3355 -> 1400;
3356 -> 1420;
3357 -> 3356;
3357 -> 1420;
3358 -> 3357;
3358 -> 1413;
3359 -> 3358;
3359 -> 1405;
3359 -> 1403;
3360 -> 3348;
3361 -> 3360;
3361 -> 3348;
3362 -> 3361;
3362 -> 1428;
3362 -> 1400;
3363 -> 3351;
3364 -> 3363;
3364 -> 3351;
3365 -> 3364;
3365 -> 1448;
3365 -> 1400;
3366 -> 3354;
3367 -> 3366;
3367 -> 3354;
3368 -> 3367;
3368 -> 1468;
3368 -> 1400;
3369 -> 1420;
3370 -> 3369;
3370 -> 1420;
3371 -> 3370;
3371 -> 1413;
3372 -> 3371;
3372 -> 1405;
3372 -> 1403;
3373 -> 3361;
3374 -> 3373;
3374 -> 3361;
3375 -> 3374;
3375 -> 1428;
3375 -> 1400;
3376 -> 3364;
3377 -> 3376;
3377 -> 3364;
3378 -> 3377;
3378 -> 1448;
3378 -> 1400;
3379 -> 3367;
3380 -> 3379;
3380 -> 3367;
3381 -> 3380;
3381 -> 1468;
3381 -> 1400;
3382 -> 1420;
3383 -> 3382;
3383 -> 1420;
3384 -> 3383;
3384 -> 1413;
3385 -> 3384;
3385 -> 1405;
3385 -> 1403;
3386 -> 3374;
3387 -> 3386;
3387 -> 3374;
3388 -> 3387;
3388 -> 1428;
3388 -> 1400;
3389 -> 3377;
3390 -> 3389;
3390 -> 3377;
3391 -> 3390;
3391 -> 1448;
3391 -> 1400;
3392 -> 3380;
3393 -> 3392;
3393 -> 3380;
3394 -> 3393;
3394 -> 1468;
3394 -> 1400;
3395 -> 1420;
3396 -> 3395;
3396 -> 1420;
3397 -> 3396;
3397 -> 1413;
3398 -> 3397;
3398 -> 1405;
3398 -> 1403;
3399 -> 3387;
3400 -> 3399;
3400 -> 3387;
3401 -> 3400;
3401 -> 1428;
3401 -> 1400;
3402 -> 3390;
3403 -> 3402;
3403 -> 3390;
3404 -> 3403;
3404 -> 1448;
3404 -> 1400;
3405 -> 3393;
3406 -> 3405;
3406 -> 3393;
3407 -> 3406;
3407 -> 1468;
3407 -> 1400;
3408 -> 1420;
3409 -> 3408;
3409 -> 1420;
3410 -> 3409;
3410 -> 1413;
3411 -> 3410;
3411 -> 1405;
3411 -> 1403;
3412 -> 3400;
3413 -> 3412;
3413 -> 3400;
3414 -> 3413;
3414 -> 1428;
3414 -> 1400;
3415 -> 3403;
3416 -> 3415;
3416 -> 3403;
3417 -> 3416;
3417 -> 1448;
3417 -> 1400;
3418 -> 3406;
3419 -> 3418;
3419 -> 3406;
3420 -> 3419;
3420 -> 1468;
3420 -> 1400;
3421 -> 1420;
3422 -> 3421;
3422 -> 1420;
3423 -> 3422;
3423 -> 1413;
3424 -> 3423;
3424 -> 1405;
3424 -> 1403;
3425 -> 3413;
3426 -> 3425;
3426 -> 3413;
3427 -> 3426;
3427 -> 1428;
3427 -> 1400;
3428 -> 3416;
3429 -> 3428;
3429 -> 3416;
3430 -> 3429;
3430 -> 1448;
3430 -> 1400;
3431 -> 3419;
3432 -> 3431;
3432 -> 3419;
3433 -> 3432;
3433 -> 1468;
3433 -> 1400;
3434 -> 1420;
3435 -> 3434;
3435 -> 1420;
3436 -> 3435;
3436 -> 1413;
3437 -> 3436;
3437 -> 1405;
3437 -> 1403;
3438 -> 3426;
3439 -> 3438;
3439 -> 3426;
3440 -> 3439;
3440 -> 1428;
3440 -> 1400;
3441 -> 3429;
3442 -> 3441;
3442 -> 3429;
3443 -> 3442;
3443 -> 1448;
3443 -> 1400;
3444 -> 3432;
3445 -> 3444;
3445 -> 3432;
3446 -> 3445;
3446 -> 1468;
3446 -> 1400;
3447 -> 1420;
3448 -> 3447;
3448 -> 1420;
3449 -> 3448;
3449 -> 1413;
3450 -> 3449;
3450 -> 1405;
3450 -> 1403;
3451 -> 3439;
3452 -> 3451;
3452 -> 3439;
3453 -> 3452;
3453 -> 1428;
3453 -> 1400;
3454 -> 3442;
3455 -> 3454;
3455 -> 3442;
3456 -> 3455;
3456 -> 1448;
3456 -> 1400;
3457 -> 3445;
3458 -> 3457;
3458 -> 3445;
3459 -> 3458;
3459 -> 1468;
3459 -> 1400;
3460 -> 1420;
3461 -> 3460;
3461 -> 1420;
3462 -> 3461;
3462 -> 1413;
3463 -> 3462;
3463 -> 1405;
3463 -> 1403;
3464 -> 3452;
3465 -> 3464;
3465 -> 3452;
3466 -> 3465;
3466 -> 1428;
3466 -> 1400;
3467 -> 3455;
3468 -> 3467;
3468 -> 3455;
3469 -> 3468;
3469 -> 1448;
3469 -> 1400;
3470 -> 3458;
3471 -> 3470;
3471 -> 3458;
3472 -> 3471;
3472 -> 1468;
3472 -> 1400;
3473 -> 1420;
3474 -> 3473;
3474 -> 1420;
3475 -> 3474;
3475 -> 1413;
3476 -> 3475;
3476 -> 1405;
3476 -> 1403;
3477 -> 3465;
3478 -> 3477;
3478 -> 3465;
3479 -> 3478;
3479 -> 1428;
3479 -> 1400;
3480 -> 3468;
3481 -> 3480;
3481 -> 3468;
3482 -> 3481;
3482 -> 1448;
3482 -> 1400;
3483 -> 3471;
3484 -> 3483;
3484 -> 3471;
3485 -> 3484;
3485 -> 1468;
3485 -> 1400;
3486 -> 1420;
3487 -> 3486;
3487 -> 1420;
3488 -> 3487;
3488 -> 1413;
3489 -> 3488;
3489 -> 1405;
3489 -> 1403;
3490 -> 3478;
3491 -> 3490;
3491 -> 3478;
3492 -> 3491;
3492 -> 1428;
3492 -> 1400;
3493 -> 3481;
3494 -> 3493;
3494 -> 3481;
3495 -> 3494;
3495 -> 1448;
3495 -> 1400;
3496 -> 3484;
3497 -> 3496;
3497 -> 3484;
3498 -> 3497;
3498 -> 1468;
3498 -> 1400;
3499 -> 1420;
3500 -> 3499;
3500 -> 1420;
3501 -> 3500;
3501 -> 1413;
3502 -> 3501;
3502 -> 1405;
3502 -> 1403;
3503 -> 3491;
3504 -> 3503;
3504 -> 3491;
3505 -> 3504;
3505 -> 1428;
3505 -> 1400;
3506 -> 3494;
3507 -> 3506;
3507 -> 3494;
3508 -> 3507;
3508 -> 1448;
3508 -> 1400;
3509 -> 3497;
3510 -> 3509;
3510 -> 3497;
3511 -> 3510;
3511 -> 1468;
3511 -> 1400;
3512 -> 1420;
3513 -> 3512;
3513 -> 1420;
3514 -> 3513;
3514 -> 1413;
3515 -> 3514;
3515 -> 1405;
3515 -> 1403;
3516 -> 3504;
3517 -> 3516;
3517 -> 3504;
3518 -> 3517;
3518 -> 1428;
3518 -> 1400;
3519 -> 3507;
3520 -> 3519;
3520 -> 3507;
3521 -> 3520;
3521 -> 1448;
3521 -> 1400;
3522 -> 3510;
3523 -> 3522;
3523 -> 3510;
3524 -> 3523;
3524 -> 1468;
3524 -> 1400;
3525 -> 1420;
3526 -> 3525;
3526 -> 1420;
3527 -> 3526;
3527 -> 1413;
3528 -> 3527;
3528 -> 1405;
3528 -> 1403;
3529 -> 3517;
3530 -> 3529;
3530 -> 3517;
3531 -> 3530;
3531 -> 1428;
3531 -> 1400;
3532 -> 3520;
3533 -> 3532;
3533 -> 3520;
3534 -> 3533;
3534 -> 1448;
3534 -> 1400;
3535 -> 3523;
3536 -> 3535;
3536 -> 3523;
3537 -> 3536;
3537 -> 1468;
3537 -> 1400;
3538 -> 1420;
3539 -> 3538;
3539 -> 1420;
3540 -> 3539;
3540 -> 1413;
3541 -> 3540;
3541 -> 1405;
3541 -> 1403;
3542 -> 3530;
3543 -> 3542;
3543 -> 3530;
3544 -> 3543;
3544 -> 1428;
3544 -> 1400;
3545 -> 3533;
3546 -> 3545;
3546 -> 3533;
3547 -> 3546;
3547 -> 1448;
3547 -> 1400;
3548 -> 3536;
3549 -> 3548;
3549 -> 3536;
3550 -> 3549;
3550 -> 1468;
3550 -> 1400;
3551 -> 1420;
3552 -> 3551;
3552 -> 1420;
3553 -> 3552;
3553 -> 1413;
3554 -> 3553;
3554 -> 1405;
3554 -> 1403;
3555 -> 3543;
3556 -> 3555;
3556 -> 3543;
3557 -> 3556;
3557 -> 1428;
3557 -> 1400;
3558 -> 3546;
3559 -> 3558;
3559 -> 3546;
3560 -> 3559;
3560 -> 1448;
3560 -> 1400;
3561 -> 3549;
3562 -> 3561;
3562 -> 3549;
3563 -> 3562;
3563 -> 1468;
3563 -> 1400;
3564 -> 1420;
3565 -> 3564;
3565 -> 1420;
3566 -> 3565;
3566 -> 1413;
3567 -> 3566;
3567 -> 1405;
3567 -> 1403;
3568 -> 3556;
3569 -> 3568;
3569 -> 3556;
3570 -> 3569;
3570 -> 1428;
3570 -> 1400;
3571 -> 3559;
3572 -> 3571;
3572 -> 3559;
3573 -> 3572;
3573 -> 1448;
3573 -> 1400;
3574 -> 3562;
3575 -> 3574;
3575 -> 3562;
3576 -> 3575;
3576 -> 1468;
3576 -> 1400;
3577 -> 1420;
3578 -> 3577;
3578 -> 1420;
3579 -> 3578;
3579 -> 1413;
3580 -> 3579;
3580 -> 1405;
3580 -> 1403;
3581 -> 3569;
3582 -> 3581;
3582 -> 3569;
3583 -> 3582;
3583 -> 1428;
3583 -> 1400;
3584 -> 3572;
3585 -> 3584;
3585 -> 3572;
3586 -> 3585;
3586 -> 1448;
3586 -> 1400;
3587 -> 3575;
3588 -> 3587;
3588 -> 3575;
3589 -> 3588;
3589 -> 1468;
3589 -> 1400;
3590 -> 1420;
3591 -> 3590;
3591 -> 1420;
3592 -> 3591;
3592 -> 1413;
3593 -> 3592;
3593 -> 1405;
3593 -> 1403;
3594 -> 3582;
3595 -> 3594;
3595 -> 3582;
3596 -> 3595;
3596 -> 1428;
3596 -> 1400;
3597 -> 3585;
3598 -> 3597;
3598 -> 3585;
3599 -> 3598;
3599 -> 1448;
3599 -> 1400;
3600 -> 3588;
3601 -> 3600;
3601 -> 3588;
3602 -> 3601;
3602 -> 1468;
3602 -> 1400;
3603 -> 1420;
3604 -> 3603;
3604 -> 1420;
3605 -> 3604;
3605 -> 1413;
3606 -> 3605;
3606 -> 1405;
3606 -> 1403;
3607 -> 3595;
3608 -> 3607;
3608 -> 3595;
3609 -> 3608;
3609 -> 1428;
3609 -> 1400;
3610 -> 3598;
3611 -> 3610;
3611 -> 3598;
3612 -> 3611;
3612 -> 1448;
3612 -> 1400;
3613 -> 3601;
3614 -> 3613;
3614 -> 3601;
3615 -> 3614;
3615 -> 1468;
3615 -> 1400;
3616 -> 1420;
3617 -> 3616;
3617 -> 1420;
3618 -> 3617;
3618 -> 1413;
3619 -> 3618;
3619 -> 1405;
3619 -> 1403;
3620 -> 3608;
3621 -> 3620;
3621 -> 3608;
3622 -> 3621;
3622 -> 1428;
3622 -> 1400;
3623 -> 3611;
3624 -> 3623;
3624 -> 3611;
3625 -> 3624;
3625 -> 1448;
3625 -> 1400;
3626 -> 3614;
3627 -> 3626;
3627 -> 3614;
3628 -> 3627;
3628 -> 1468;
3628 -> 1400;
3629 -> 1420;
3630 -> 3629;
3630 -> 1420;
3631 -> 3630;
3631 -> 1413;
3632 -> 3631;
3632 -> 1405;
3632 -> 1403;
3633 -> 3621;
3634 -> 3633;
3634 -> 3621;
3635 -> 3634;
3635 -> 1428;
3635 -> 1400;
3636 -> 3624;
3637 -> 3636;
3637 -> 3624;
3638 -> 3637;
3638 -> 1448;
3638 -> 1400;
3639 -> 3627;
3640 -> 3639;
3640 -> 3627;
3641 -> 3640;
3641 -> 1468;
3641 -> 1400;
3642 -> 1420;
3643 -> 3642;
3643 -> 1420;
3644 -> 3643;
3644 -> 1413;
3645 -> 3644;
3645 -> 1405;
3645 -> 1403;
3646 -> 3634;
3647 -> 3646;
3647 -> 3634;
3648 -> 3647;
3648 -> 1428;
3648 -> 1400;
3649 -> 3637;
3650 -> 3649;
3650 -> 3637;
3651 -> 3650;
3651 -> 1448;
3651 -> 1400;
3652 -> 3640;
3653 -> 3652;
3653 -> 3640;
3654 -> 3653;
3654 -> 1468;
3654 -> 1400;
3655 -> 1420;
3656 -> 3655;
3656 -> 1420;
3657 -> 3656;
3657 -> 1413;
3658 -> 3657;
3658 -> 1405;
3658 -> 1403;
3659 -> 3647;
3660 -> 3659;
3660 -> 3647;
3661 -> 3660;
3661 -> 1428;
3661 -> 1400;
3662 -> 3650;
3663 -> 3662;
3663 -> 3650;
3664 -> 3663;
3664 -> 1448;
3664 -> 1400;
3665 -> 3653;
3666 -> 3665;
3666 -> 3653;
3667 -> 3666;
3667 -> 1468;
3667 -> 1400;
3668 -> 1420;
3669 -> 3668;
3669 -> 1420;
3670 -> 3669;
3670 -> 1413;
3671 -> 3670;
3671 -> 1405;
3671 -> 1403;
3672 -> 3660;
3673 -> 3672;
3673 -> 3660;
3674 -> 3673;
3674 -> 1428;
3674 -> 1400;
3675 -> 3663;
3676 -> 3675;
3676 -> 3663;
3677 -> 3676;
3677 -> 1448;
3677 -> 1400;
3678 -> 3666;
3679 -> 3678;
3679 -> 3666;
3680 -> 3679;
3680 -> 1468;
3680 -> 1400;
3681 -> 1420;
3682 -> 3681;
3682 -> 1420;
3683 -> 3682;
3683 -> 1413;
3684 -> 3683;
3684 -> 1405;
3684 -> 1403;
3685 -> 3673;
3686 -> 3685;
3686 -> 3673;
3687 -> 3686;
3687 -> 1428;
3687 -> 1400;
3688 -> 3676;
3689 -> 3688;
3689 -> 3676;
3690 -> 3689;
3690 -> 1448;
3690 -> 1400;
3691 -> 3679;
3692 -> 3691;
3692 -> 3679;
3693 -> 3692;
3693 -> 1468;
3693 -> 1400;
3694 -> 1420;
3695 -> 3694;
3695 -> 1420;
3696 -> 3695;
3696 -> 1413;
3697 -> 3696;
3697 -> 1405;
3697 -> 1403;
3698 -> 3686;
3699 -> 3698;
3699 -> 3686;
3700 -> 3699;
3700 -> 1428;
3700 -> 1400;
3701 -> 3689;
3702 -> 3701;
3702 -> 3689;
3703 -> 3702;
3703 -> 1448;
3703 -> 1400;
3704 -> 3692;
3705 -> 3704;
3705 -> 3692;
3706 -> 3705;
3706 -> 1468;
3706 -> 1400;
3707 -> 1420;
3708 -> 3707;
3708 -> 1420;
3709 -> 3708;
3709 -> 1413;
3710 -> 3709;
3710 -> 1405;
3710 -> 1403;
3711 -> 3699;
3712 -> 3711;
3712 -> 3699;
3713 -> 3712;
3713 -> 1428;
3713 -> 1400;
3714 -> 3702;
3715 -> 3714;
3715 -> 3702;
3716 -> 3715;
3716 -> 1448;
3716 -> 1400;
3717 -> 3705;
3718 -> 3717;
3718 -> 3705;
3719 -> 3718;
3719 -> 1468;
3719 -> 1400;
3720 -> 1420;
3721 -> 3720;
3721 -> 1420;
3722 -> 3721;
3722 -> 1413;
3723 -> 3722;
3723 -> 1405;
3723 -> 1403;
3724 -> 3712;
3725 -> 3724;
3725 -> 3712;
3726 -> 3725;
3726 -> 1428;
3726 -> 1400;
3727 -> 3715;
3728 -> 3727;
3728 -> 3715;
3729 -> 3728;
3729 -> 1448;
3729 -> 1400;
3730 -> 3718;
3731 -> 3730;
3731 -> 3718;
3732 -> 3731;
3732 -> 1468;
3732 -> 1400;
3733 -> 1420;
3734 -> 3733;
3734 -> 1420;
3735 -> 3734;
3735 -> 1413;
3736 -> 3735;
3736 -> 1405;
3736 -> 1403;
3737 -> 3725;
3738 -> 3737;
3738 -> 3725;
3739 -> 3738;
3739 -> 1428;
3739 -> 1400;
3740 -> 3728;
3741 -> 3740;
3741 -> 3728;
3742 -> 3741;
3742 -> 1448;
3742 -> 1400;
3743 -> 3731;
3744 -> 3743;
3744 -> 3731;
3745 -> 3744;
3745 -> 1468;
3745 -> 1400;
3746 -> 1420;
3747 -> 3746;
3747 -> 1420;
3748 -> 3747;
3748 -> 1413;
3749 -> 3748;
3749 -> 1405;
3749 -> 1403;
3750 -> 3738;
3751 -> 3750;
3751 -> 3738;
3752 -> 3751;
3752 -> 1428;
3752 -> 1400;
3753 -> 3741;
3754 -> 3753;
3754 -> 3741;
3755 -> 3754;
3755 -> 1448;
3755 -> 1400;
3756 -> 3744;
3757 -> 3756;
3757 -> 3744;
3758 -> 3757;
3758 -> 1468;
3758 -> 1400;
3759 -> 1420;
3760 -> 3759;
3760 -> 1420;
3761 -> 3760;
3761 -> 1413;
3762 -> 3761;
3762 -> 1405;
3762 -> 1403;
3763 -> 3751;
3764 -> 3763;
3764 -> 3751;
3765 -> 3764;
3765 -> 1428;
3765 -> 1400;
3766 -> 3754;
3767 -> 3766;
3767 -> 3754;
3768 -> 3767;
3768 -> 1448;
3768 -> 1400;
3769 -> 3757;
3770 -> 3769;
3770 -> 3757;
3771 -> 3770;
3771 -> 1468;
3771 -> 1400;
3772 -> 1420;
3773 -> 3772;
3773 -> 1420;
3774 -> 3773;
3774 -> 1413;
3775 -> 3774;
3775 -> 1405;
3775 -> 1403;
3776 -> 3764;
3777 -> 3776;
3777 -> 3764;
3778 -> 3777;
3778 -> 1428;
3778 -> 1400;
3779 -> 3767;
3780 -> 3779;
3780 -> 3767;
3781 -> 3780;
3781 -> 1448;
3781 -> 1400;
3782 -> 3770;
3783 -> 3782;
3783 -> 3770;
3784 -> 3783;
3784 -> 1468;
3784 -> 1400;
3785 -> 1420;
3786 -> 3785;
3786 -> 1420;
3787 -> 3786;
3787 -> 1413;
3788 -> 3787;
3788 -> 1405;
3788 -> 1403;
3789 -> 3777;
3790 -> 3789;
3790 -> 3777;
3791 -> 3790;
3791 -> 1428;
3791 -> 1400;
3792 -> 3780;
3793 -> 3792;
3793 -> 3780;
3794 -> 3793;
3794 -> 1448;
3794 -> 1400;
3795 -> 3783;
3796 -> 3795;
3796 -> 3783;
3797 -> 3796;
3797 -> 1468;
3797 -> 1400;
3798 -> 1420;
3799 -> 3798;
3799 -> 1420;
3800 -> 3799;
3800 -> 1413;
3801 -> 3800;
3801 -> 1405;
3801 -> 1403;
3802 -> 3790;
3803 -> 3802;
3803 -> 3790;
3804 -> 3803;
3804 -> 1428;
3804 -> 1400;
3805 -> 3793;
3806 -> 3805;
3806 -> 3793;
3807 -> 3806;
3807 -> 1448;
3807 -> 1400;
3808 -> 3796;
3809 -> 3808;
3809 -> 3796;
3810 -> 3809;
3810 -> 1468;
3810 -> 1400;
3811 -> 1420;
3812 -> 3811;
3812 -> 1420;
3813 -> 3812;
3813 -> 1413;
3814 -> 3813;
3814 -> 1405;
3814 -> 1403;
3815 -> 3803;
3816 -> 3815;
3816 -> 3803;
3817 -> 3816;
3817 -> 1428;
3817 -> 1400;
3818 -> 3806;
3819 -> 3818;
3819 -> 3806;
3820 -> 3819;
3820 -> 1448;
3820 -> 1400;
3821 -> 3809;
3822 -> 3821;
3822 -> 3809;
3823 -> 3822;
3823 -> 1468;
3823 -> 1400;
3824 -> 1420;
3825 -> 3824;
3825 -> 1420;
3826 -> 3825;
3826 -> 1413;
3827 -> 3826;
3827 -> 1405;
3827 -> 1403;
3828 -> 3816;
3829 -> 3828;
3829 -> 3816;
3830 -> 3829;
3830 -> 1428;
3830 -> 1400;
3831 -> 3819;
3832 -> 3831;
3832 -> 3819;
3833 -> 3832;
3833 -> 1448;
3833 -> 1400;
3834 -> 3822;
3835 -> 3834;
3835 -> 3822;
3836 -> 3835;
3836 -> 1468;
3836 -> 1400;
3837 -> 1420;
3838 -> 3837;
3838 -> 1420;
3839 -> 3838;
3839 -> 1413;
3840 -> 3839;
3840 -> 1405;
3840 -> 1403;
3841 -> 3829;
3842 -> 3841;
3842 -> 3829;
3843 -> 3842;
3843 -> 1428;
3843 -> 1400;
3844 -> 3832;
3845 -> 3844;
3845 -> 3832;
3846 -> 3845;
3846 -> 1448;
3846 -> 1400;
3847 -> 3835;
3848 -> 3847;
3848 -> 3835;
3849 -> 3848;
3849 -> 1468;
3849 -> 1400;
3850 -> 1420;
3851 -> 3850;
3851 -> 1420;
3852 -> 3851;
3852 -> 1413;
3853 -> 3852;
3853 -> 1405;
3853 -> 1403;
3854 -> 3842;
3855 -> 3854;
3855 -> 3842;
3856 -> 3855;
3856 -> 1428;
3856 -> 1400;
3857 -> 3845;
3858 -> 3857;
3858 -> 3845;
3859 -> 3858;
3859 -> 1448;
3859 -> 1400;
3860 -> 3848;
3861 -> 3860;
3861 -> 3848;
3862 -> 3861;
3862 -> 1468;
3862 -> 1400;
3863 -> 1420;
3864 -> 3863;
3864 -> 1420;
3865 -> 3864;
3865 -> 1413;
3866 -> 3865;
3866 -> 1405;
3866 -> 1403;
3867 -> 3855;
3868 -> 3867;
3868 -> 3855;
3869 -> 3868;
3869 -> 1428;
3869 -> 1400;
3870 -> 3858;
3871 -> 3870;
3871 -> 3858;
3872 -> 3871;
3872 -> 1448;
3872 -> 1400;
3873 -> 3861;
3874 -> 3873;
3874 -> 3861;
3875 -> 3874;
3875 -> 1468;
3875 -> 1400;
3876 -> 1420;
3877 -> 3876;
3877 -> 1420;
3878 -> 3877;
3878 -> 1413;
3879 -> 3878;
3879 -> 1405;
3879 -> 1403;
3880 -> 3868;
3881 -> 3880;
3881 -> 3868;
3882 -> 3881;
3882 -> 1428;
3882 -> 1400;
3883 -> 3871;
3884 -> 3883;
3884 -> 3871;
3885 -> 3884;
3885 -> 1448;
3885 -> 1400;
3886 -> 3874;
3887 -> 3886;
3887 -> 3874;
3888 -> 3887;
3888 -> 1468;
3888 -> 1400;
3889 -> 1420;
3890 -> 3889;
3890 -> 1420;
3891 -> 3890;
3891 -> 1413;
3892 -> 3891;
3892 -> 1405;
3892 -> 1403;
3893 -> 3881;
3894 -> 3893;
3894 -> 3881;
3895 -> 3894;
3895 -> 1428;
3895 -> 1400;
3896 -> 3884;
3897 -> 3896;
3897 -> 3884;
3898 -> 3897;
3898 -> 1448;
3898 -> 1400;
3899 -> 3887;
3900 -> 3899;
3900 -> 3887;
3901 -> 3900;
3901 -> 1468;
3901 -> 1400;
3902 -> 1420;
3903 -> 3902;
3903 -> 1420;
3904 -> 3903;
3904 -> 1413;
3905 -> 3904;
3905 -> 1405;
3905 -> 1403;
3906 -> 3894;
3907 -> 3906;
3907 -> 3894;
3908 -> 3907;
3908 -> 1428;
3908 -> 1400;
3909 -> 3897;
3910 -> 3909;
3910 -> 3897;
3911 -> 3910;
3911 -> 1448;
3911 -> 1400;
3912 -> 3900;
3913 -> 3912;
3913 -> 3900;
3914 -> 3913;
3914 -> 1468;
3914 -> 1400;
3915 -> 1420;
3916 -> 3915;
3916 -> 1420;
3917 -> 3916;
3917 -> 1413;
3918 -> 3917;
3918 -> 1405;
3918 -> 1403;
3919 -> 3907;
3920 -> 3919;
3920 -> 3907;
3921 -> 3920;
3921 -> 1428;
3921 -> 1400;
3922 -> 3910;
3923 -> 3922;
3923 -> 3910;
3924 -> 3923;
3924 -> 1448;
3924 -> 1400;
3925 -> 3913;
3926 -> 3925;
3926 -> 3913;
3927 -> 3926;
3927 -> 1468;
3927 -> 1400;
3928 -> 1420;
3929 -> 3928;
3929 -> 1420;
3930 -> 3929;
3930 -> 1413;
3931 -> 3930;
3931 -> 1405;
3931 -> 1403;
3932 -> 3920;
3933 -> 3932;
3933 -> 3920;
3934 -> 3933;
3934 -> 1428;
3934 -> 1400;
3935 -> 3923;
3936 -> 3935;
3936 -> 3923;
3937 -> 3936;
3937 -> 1448;
3937 -> 1400;
3938 -> 3926;
3939 -> 3938;
3939 -> 3926;
3940 -> 3939;
3940 -> 1468;
3940 -> 1400;
3941 -> 1420;
3942 -> 3941;
3942 -> 1420;
3943 -> 3942;
3943 -> 1413;
3944 -> 3943;
3944 -> 1405;
3944 -> 1403;
3945 -> 3933;
3946 -> 3945;
3946 -> 3933;
3947 -> 3946;
3947 -> 1428;
3947 -> 1400;
3948 -> 3936;
3949 -> 3948;
3949 -> 3936;
3950 -> 3949;
3950 -> 1448;
3950 -> 1400;
3951 -> 3939;
3952 -> 3951;
3952 -> 3939;
3953 -> 3952;
3953 -> 1468;
3953 -> 1400;
3954 -> 1420;
3955 -> 3954;
3955 -> 1420;
3956 -> 3955;
3956 -> 1413;
3957 -> 3956;
3957 -> 1405;
3957 -> 1403;
3958 -> 3946;
3959 -> 3958;
3959 -> 3946;
3960 -> 3959;
3960 -> 1428;
3960 -> 1400;
3961 -> 3949;
3962 -> 3961;
3962 -> 3949;
3963 -> 3962;
3963 -> 1448;
3963 -> 1400;
3964 -> 3952;
3965 -> 3964;
3965 -> 3952;
3966 -> 3965;
3966 -> 1468;
3966 -> 1400;
3967 -> 1420;
3968 -> 3967;
3968 -> 1420;
3969 -> 3968;
3969 -> 1413;
3970 -> 3969;
3970 -> 1405;
3970 -> 1403;
3971 -> 3959;
3972 -> 3971;
3972 -> 3959;
3973 -> 3972;
3973 -> 1428;
3973 -> 1400;
3974 -> 3962;
3975 -> 3974;
3975 -> 3962;
3976 -> 3975;
3976 -> 1448;
3976 -> 1400;
3977 -> 3965;
3978 -> 3977;
3978 -> 3965;
3979 -> 3978;
3979 -> 1468;
3979 -> 1400;
3980 -> 1420;
3981 -> 3980;
3981 -> 1420;
3982 -> 3981;
3982 -> 1413;
3983 -> 3982;
3983 -> 1405;
3983 -> 1403;
3984 -> 3972;
3985 -> 3984;
3985 -> 3972;
3986 -> 3985;
3986 -> 1428;
3986 -> 1400;
3987 -> 3975;
3988 -> 3987;
3988 -> 3975;
3989 -> 3988;
3989 -> 1448;
3989 -> 1400;
3990 -> 3978;
3991 -> 3990;
3991 -> 3978;
3992 -> 3991;
3992 -> 1468;
3992 -> 1400;
3993 -> 1420;
3994 -> 3993;
3994 -> 1420;
3995 -> 3994;
3995 -> 1413;
3996 -> 3995;
3996 -> 1405;
3996 -> 1403;
3997 -> 3985;
3998 -> 3997;
3998 -> 3985;
3999 -> 3998;
3999 -> 1428;
3999 -> 1400;
4000 -> 3988;
4001 -> 4000;
4001 -> 3988;
4002 -> 4001;
4002 -> 1448;
4002 -> 1400;
4003 -> 3991;
4004 -> 4003;
4004 -> 3991;
4005 -> 4004;
4005 -> 1468;
4005 -> 1400;
4006 -> 1420;
4007 -> 4006;
4007 -> 1420;
4008 -> 4007;
4008 -> 1413;
4009 -> 4008;
4009 -> 1405;
4009 -> 1403;
4010 -> 3998;
4011 -> 4010;
4011 -> 3998;
4012 -> 4011;
4012 -> 1428;
4012 -> 1400;
4013 -> 4001;
4014 -> 4013;
4014 -> 4001;
4015 -> 4014;
4015 -> 1448;
4015 -> 1400;
4016 -> 4004;
4017 -> 4016;
4017 -> 4004;
4018 -> 4017;
4018 -> 1468;
4018 -> 1400;
4019 -> 1420;
4020 -> 4019;
4020 -> 1420;
4021 -> 4020;
4021 -> 1413;
4022 -> 4021;
4022 -> 1405;
4022 -> 1403;
4023 -> 4011;
4024 -> 4023;
4024 -> 4011;
4025 -> 4024;
4025 -> 1428;
4025 -> 1400;
4026 -> 4014;
4027 -> 4026;
4027 -> 4014;
4028 -> 4027;
4028 -> 1448;
4028 -> 1400;
4029 -> 4017;
4030 -> 4029;
4030 -> 4017;
4031 -> 4030;
4031 -> 1468;
4031 -> 1400;
4032 -> 1420;
4033 -> 4032;
4033 -> 1420;
4034 -> 4033;
4034 -> 1413;
4035 -> 4034;
4035 -> 1405;
4035 -> 1403;
4036 -> 4024;
4037 -> 4036;
4037 -> 4024;
4038 -> 4037;
4038 -> 1428;
4038 -> 1400;
4039 -> 4027;
4040 -> 4039;
4040 -> 4027;
4041 -> 4040;
4041 -> 1448;
4041 -> 1400;
4042 -> 4030;
4043 -> 4042;
4043 -> 4030;
4044 -> 4043;
4044 -> 1468;
4044 -> 1400;
4045 -> 1420;
4046 -> 4045;
4046 -> 1420;
4047 -> 4046;
4047 -> 1413;
4048 -> 4047;
4048 -> 1405;
4048 -> 1403;
4049 -> 4037;
4050 -> 4049;
4050 -> 4037;
4051 -> 4050;
4051 -> 1428;
4051 -> 1400;
4052 -> 4040;
4053 -> 4052;
4053 -> 4040;
4054 -> 4053;
4054 -> 1448;
4054 -> 1400;
4055 -> 4043;
4056 -> 4055;
4056 -> 4043;
4057 -> 4056;
4057 -> 1468;
4057 -> 1400;
4058 -> 1420;
4059 -> 4058;
4059 -> 1420;
4060 -> 4059;
4060 -> 1413;
4061 -> 4060;
4061 -> 1405;
4061 -> 1403;
4062 -> 4050;
4063 -> 4062;
4063 -> 4050;
4064 -> 4063;
4064 -> 1428;
4064 -> 1400;
4065 -> 4053;
4066 -> 4065;
4066 -> 4053;
4067 -> 4066;
4067 -> 1448;
4067 -> 1400;
4068 -> 4056;
4069 -> 4068;
4069 -> 4056;
4070 -> 4069;
4070 -> 1468;
4070 -> 1400;
4071 -> 1420;
4072 -> 4071;
4072 -> 1420;
4073 -> 4072;
4073 -> 1413;
4074 -> 4073;
4074 -> 1405;
4074 -> 1403;
4075 -> 4063;
4076 -> 4075;
4076 -> 4063;
4077 -> 4076;
4077 -> 1428;
4077 -> 1400;
4078 -> 4066;
4079 -> 4078;
4079 -> 4066;
4080 -> 4079;
4080 -> 1448;
4080 -> 1400;
4081 -> 4069;
4082 -> 4081;
4082 -> 4069;
4083 -> 4082;
4083 -> 1468;
4083 -> 1400;
4084 -> 1420;
4085 -> 4084;
4085 -> 1420;
4086 -> 4085;
4086 -> 1413;
4087 -> 4086;
4087 -> 1405;
4087 -> 1403;
4088 -> 4076;
4089 -> 4088;
4089 -> 4076;
4090 -> 4089;
4090 -> 1428;
4090 -> 1400;
4091 -> 4079;
4092 -> 4091;
4092 -> 4079;
4093 -> 4092;
4093 -> 1448;
4093 -> 1400;
4094 -> 4082;
4095 -> 4094;
4095 -> 4082;
4096 -> 4095;
4096 -> 1468;
4096 -> 1400;
4097 -> 1420;
4098 -> 4097;
4098 -> 1420;
4099 -> 4098;
4099 -> 1413;
4100 -> 4099;
4100 -> 1405;
4100 -> 1403;
4101 -> 4089;
4102 -> 4101;
4102 -> 4089;
4103 -> 4102;
4103 -> 1428;
4103 -> 1400;
4104 -> 4092;
4105 -> 4104;
4105 -> 4092;
4106 -> 4105;
4106 -> 1448;
4106 -> 1400;
4107 -> 4095;
4108 -> 4107;
4108 -> 4095;
4109 -> 4108;
4109 -> 1468;
4109 -> 1400;
4110 -> 1420;
4111 -> 4110;
4111 -> 1420;
4112 -> 4111;
4112 -> 1413;
4113 -> 4112;
4113 -> 1405;
4113 -> 1403;
4114 -> 4102;
4115 -> 4114;
4115 -> 4102;
4116 -> 4115;
4116 -> 1428;
4116 -> 1400;
4117 -> 4105;
4118 -> 4117;
4118 -> 4105;
4119 -> 4118;
4119 -> 1448;
4119 -> 1400;
4120 -> 4108;
4121 -> 4120;
4121 -> 4108;
4122 -> 4121;
4122 -> 1468;
4122 -> 1400;
4123 -> 1420;
4124 -> 4123;
4124 -> 1420;
4125 -> 4124;
4125 -> 1413;
4126 -> 4125;
4126 -> 1405;
4126 -> 1403;
4127 -> 4115;
4128 -> 4127;
4128 -> 4115;
4129 -> 4128;
4129 -> 1428;
4129 -> 1400;
4130 -> 4118;
4131 -> 4130;
4131 -> 4118;
4132 -> 4131;
4132 -> 1448;
4132 -> 1400;
4133 -> 4121;
4134 -> 4133;
4134 -> 4121;
4135 -> 4134;
4135 -> 1468;
4135 -> 1400;
4136 -> 1420;
4137 -> 4136;
4137 -> 1420;
4138 -> 4137;
4138 -> 1413;
4139 -> 4138;
4139 -> 1405;
4139 -> 1403;
4140 -> 4128;
4141 -> 4140;
4141 -> 4128;
4142 -> 4141;
4142 -> 1428;
4142 -> 1400;
4143 -> 4131;
4144 -> 4143;
4144 -> 4131;
4145 -> 4144;
4145 -> 1448;
4145 -> 1400;
4146 -> 4134;
4147 -> 4146;
4147 -> 4134;
4148 -> 4147;
4148 -> 1468;
4148 -> 1400;
4149 -> 1420;
4150 -> 4149;
4150 -> 1420;
4151 -> 4150;
4151 -> 1413;
4152 -> 4151;
4152 -> 1405;
4152 -> 1403;
4153 -> 4141;
4154 -> 4153;
4154 -> 4141;
4155 -> 4154;
4155 -> 1428;
4155 -> 1400;
4156 -> 4144;
4157 -> 4156;
4157 -> 4144;
4158 -> 4157;
4158 -> 1448;
4158 -> 1400;
4159 -> 4147;
4160 -> 4159;
4160 -> 4147;
4161 -> 4160;
4161 -> 1468;
4161 -> 1400;
4162 -> 1420;
4163 -> 4162;
4163 -> 1420;
4164 -> 4163;
4164 -> 1413;
4165 -> 4164;
4165 -> 1405;
4165 -> 1403;
4166 -> 4154;
4167 -> 4166;
4167 -> 4154;
4168 -> 4167;
4168 -> 1428;
4168 -> 1400;
4169 -> 4157;
4170 -> 4169;
4170 -> 4157;
4171 -> 4170;
4171 -> 1448;
4171 -> 1400;
4172 -> 4160;
4173 -> 4172;
4173 -> 4160;
4174 -> 4173;
4174 -> 1468;
4174 -> 1400;
4175 -> 1420;
4176 -> 4175;
4176 -> 1420;
4177 -> 4176;
4177 -> 1413;
4178 -> 4177;
4178 -> 1405;
4178 -> 1403;
4179 -> 4167;
4180 -> 4179;
4180 -> 4167;
4181 -> 4180;
4181 -> 1428;
4181 -> 1400;
4182 -> 4170;
4183 -> 4182;
4183 -> 4170;
4184 -> 4183;
4184 -> 1448;
4184 -> 1400;
4185 -> 4173;
4186 -> 4185;
4186 -> 4173;
4187 -> 4186;
4187 -> 1468;
4187 -> 1400;
4188 -> 1420;
4189 -> 4188;
4189 -> 1420;
4190 -> 4189;
4190 -> 1413;
4191 -> 4190;
4191 -> 1405;
4191 -> 1403;
4192 -> 4180;
4193 -> 4192;
4193 -> 4180;
4194 -> 4193;
4194 -> 1428;
4194 -> 1400;
4195 -> 4183;
4196 -> 4195;
4196 -> 4183;
4197 -> 4196;
4197 -> 1448;
4197 -> 1400;
4198 -> 4186;
4199 -> 4198;
4199 -> 4186;
4200 -> 4199;
4200 -> 1468;
4200 -> 1400;
4201 -> 1420;
4202 -> 4201;
4202 -> 1420;
4203 -> 4202;
4203 -> 1413;
4204 -> 4203;
4204 -> 1405;
4204 -> 1403;
4205 -> 4193;
4206 -> 4205;
4206 -> 4193;
4207 -> 4206;
4207 -> 1428;
4207 -> 1400;
4208 -> 4196;
4209 -> 4208;
4209 -> 4196;
4210 -> 4209;
4210 -> 1448;
4210 -> 1400;
4211 -> 4199;
4212 -> 4211;
4212 -> 4199;
4213 -> 4212;
4213 -> 1468;
4213 -> 1400;
4214 -> 1242;
4214 -> 1241;
4215 -> 1243;
4215 -> 1241;
4216 -> 1244;
4216 -> 1241;
4217 -> 1245;
4217 -> 1241;
4218 -> 1246;
4218 -> 1241;
4219 -> 1241;
4220 -> 4214;
4220 -> 4219;
4221 -> 4215;
4221 -> 4219;
4222 -> 4216;
4222 -> 4219;
4223 -> 4217;
4223 -> 4219;
4224 -> 4218;
4224 -> 4219;
4225 -> 4220;
4225 -> 0;
4225 -> 4219;
4226 -> 4223;
4226 -> 4222;
4226 -> 4219;
4227 -> 4225;
4227 -> 4226;
4227 -> 4219;
4228 -> 4227;
4228 -> 4219;
4229 -> 4221;
4229 -> 4228;
4230 -> 4222;
4230 -> 4228;
4231 -> 4224;
4231 -> 4228;
4232 -> 4228;
4233 -> 4229;
4233 -> 4232;
4234 -> 4230;
4234 -> 4232;
4235 -> 4231;
4235 -> 4232;
4236 -> 4232;
4237 -> 4233;
4237 -> 4236;
4237 -> 4232;
4238 -> 4237;
4238 -> 4232;
4239 -> 4238;
4240 -> 4235;
4240 -> 4239;
4240 -> 4238;
4241 -> 4240;
4241 -> 4238;
4242 -> 4234;
4242 -> 4241;
4243 -> 4241;
4244 -> 4242;
4244 -> 4243;
4245 -> 4244;
4245 -> 4243;
4246 -> 4245;
4246 -> 4243;
4247 -> 4243;
4248 -> 4246;
4248 -> 4247;
4249 -> 4246;
4249 -> 4247;
4250 -> 4246;
4250 -> 4247;
4251 -> 4248;
4251 -> 4247;
4252 -> 4249;
4252 -> 4247;
4253 -> 4247;
4254 -> 4251;
4254 -> 4253;
4255 -> 4252;
4255 -> 4253;
4256 -> 4250;
4256 -> 4253;
4257 -> 4254;
4257 -> 4253;
4258 -> 4255;
4258 -> 4253;
4259 -> 4253;
4260 -> 4259;
4260 -> 4257;
4260 -> 4258;
4260 -> 4253;
4261 -> 4259;
4261 -> 4253;
4262 -> 4261;
4262 -> 4260;
4262 -> 4253;
4263 -> 4250;
4263 -> 4262;
4263 -> 0;
4263 -> 4247;
4264 -> 4263;
4264 -> 4250;
4264 -> 4247;
4265 -> 4264;
4265 -> 4243;
4266 -> 4265;
4266 -> 4241;
4267 -> 4266;
4267 -> 4228;
4268 -> 4267;
4268 -> 1241;
4269 -> 4268;
4269 -> 608;
4270 -> 591;
4271 -> 595;
4271 -> 4270;
4271 -> 591;
4272 -> 4271;
4272 -> 591;
4273 -> 4272;
4273 -> 591;
4274 -> 4269;
4274 -> 591;
4275 -> 4274;
4275 -> 396;
4276 -> 4275;
4276 -> 362;
4277 -> 4276;
4277 -> 362;
4278 -> 4277;
4278 -> 355;
4279 -> 4278;
4279 -> 355;
4280 -> 355;
4281 -> 4279;
4281 -> 4280;
4282 -> 337;
4282 -> 4280;
4283 -> 4280;
4284 -> 4281;
4284 -> 4283;
4284 -> 4280;
4285 -> 4284;
4285 -> 4280;
4286 -> 4282;
4286 -> 307;
4286 -> 349;
4286 -> 348;
4286 -> 4280;
4287 -> 4286;
4287 -> 4280;
4288 -> 4282;
4288 -> 349;
4288 -> 348;
4288 -> 307;
4288 -> 4280;
4289 -> 4281;
4289 -> 4288;
4289 -> 4280;
4290 -> 4282;
4290 -> 307;
4290 -> 4280;
4291 -> 355;
4292 -> 4278;
4292 -> 4291;
4293 -> 4292;
4293 -> 4264;
4293 -> 4291;
4294 -> 4293;
4294 -> 0;
4294 -> 355;
4295 -> 4294;
4295 -> 355;
4296 -> 353;
4296 -> 355;
4297 -> 351;
4297 -> 4296;
4298 -> 4296;
4299 -> 4297;
4299 -> 4298;
4300 -> 350;
4300 -> 4298;
4301 -> 360;
4301 -> 4298;
4302 -> 4299;
4302 -> 4300;
4302 -> 4298;
4303 -> 4300;
4303 -> 604;
4303 -> 4302;
4303 -> 4298;
4304 -> 4303;
4305 -> 4304;
4305 -> 4303;
4306 -> 4303;
4307 -> 4303;
4308 -> 4303;
4309 -> 4303;
4310 -> 4303;
4311 -> 4303;
4312 -> 4306;
4312 -> 4303;
4313 -> 4307;
4313 -> 4303;
4314 -> 4308;
4314 -> 4303;
4315 -> 4309;
4315 -> 4303;
4316 -> 4311;
4316 -> 4305;
4316 -> 4312;
4316 -> 4313;
4316 -> 4314;
4316 -> 4315;
4316 -> 4303;
4317 -> 4316;
4317 -> 4303;
4318 -> 4303;
4319 -> 4317;
4319 -> 4318;
4319 -> 4303;
4320 -> 4319;
4320 -> 4303;
4321 -> 4310;
4321 -> 4316;
4321 -> 4320;
4322 -> 4320;
4323 -> 4321;
4323 -> 4322;
4324 -> 4322;
4325 -> 4323;
4325 -> 4321;
4325 -> 4324;
4326 -> 4325;
4326 -> 4321;
4326 -> 4324;
4327 -> 4326;
4327 -> 4324;
4328 -> 4327;
4328 -> 4322;
4329 -> 4322;
4330 -> 4323;
4330 -> 4321;
4330 -> 4329;
4331 -> 4322;
4332 -> 4330;
4332 -> 4331;
4333 -> 4323;
4333 -> 4321;
4333 -> 4331;
4334 -> 4322;
4335 -> 4323;
4335 -> 4334;
4336 -> 4335;
4336 -> 4321;
4336 -> 4332;
4336 -> 4334;
4337 -> 4334;
4338 -> 4335;
4338 -> 4336;
4338 -> 4337;
4339 -> 4334;
4340 -> 4338;
4340 -> 4339;
4340 -> 4334;
4341 -> 4340;
4341 -> 4334;
4342 -> 4334;
4343 -> 4342;
4343 -> 4334;
4344 -> 4341;
4344 -> 4334;
4345 -> 4343;
4345 -> 4334;
4346 -> 4345;
4346 -> 4334;
4347 -> 4336;
4347 -> 4334;
4348 -> 4347;
4348 -> 4334;
4349 -> 4348;
4349 -> 4334;
4350 -> 4336;
4350 -> 4334;
4351 -> 4334;
4352 -> 4350;
4352 -> 4351;
4352 -> 4334;
4353 -> 4352;
4353 -> 4334;
4354 -> 4353;
4355 -> 4350;
4355 -> 4354;
4355 -> 4353;
4356 -> 4355;
4356 -> 4353;
4357 -> 4350;
4357 -> 4334;
4358 -> 4357;
4359 -> 4336;
4359 -> 4334;
4360 -> 4359;
4360 -> 4336;
4360 -> 4334;
4361 -> 4336;
4361 -> 4334;
4362 -> 4334;
4363 -> 4361;
4363 -> 4362;
4364 -> 4362;
4365 -> 4364;
4365 -> 4362;
4366 -> 4362;
4367 -> 4363;
4367 -> 4366;
4367 -> 4362;
4368 -> 4367;
4368 -> 4362;
4369 -> 4368;
4370 -> 4369;
4370 -> 4368;
4371 -> 4370;
4371 -> 4363;
4371 -> 4360;
4371 -> 4368;
4372 -> 4371;
4372 -> 4368;
4373 -> 4365;
4373 -> 4362;
4374 -> 4334;
4375 -> 4373;
4375 -> 4374;
4376 -> 4335;
4376 -> 4374;
4377 -> 4374;
4378 -> 4376;
4378 -> 4360;
4378 -> 4377;
4378 -> 4374;
4379 -> 4378;
4379 -> 4374;
4380 -> 4379;
4381 -> 4380;
4381 -> 4379;
4382 -> 4381;
4382 -> 4334;
4383 -> 4360;
4383 -> 4334;
4384 -> 4382;
4384 -> 4334;
4385 -> 4383;
4385 -> 4334;
4386 -> 4384;
4386 -> 4334;
4387 -> 4335;
4387 -> 4334;
4388 -> 4385;
4388 -> 0;
4388 -> 4334;
4389 -> 4388;
4389 -> 4334;
4390 -> 4389;
4390 -> 4334;
4391 -> 4360;
4391 -> 4334;
4392 -> 4360;
4392 -> 4334;
4393 -> 4334;
4394 -> 4385;
4394 -> 4334;
4395 -> 4385;
4395 -> 4394;
4396 -> 4385;
4396 -> 4395;
4397 -> 4395;
4398 -> 4396;
4398 -> 4397;
4399 -> 4398;
4399 -> 0;
4399 -> 4397;
4400 -> 4398;
4400 -> 0;
4400 -> 4397;
4401 -> 4399;
4401 -> 4400;
4401 -> 4397;
4402 -> 4401;
4402 -> 4397;
4403 -> 4402;
4403 -> 4395;
4404 -> 4391;
4404 -> 4395;
4405 -> 4385;
4405 -> 4395;
4406 -> 4392;
4406 -> 4395;
4407 -> 4395;
4408 -> 4404;
4408 -> 4407;
4409 -> 4405;
4409 -> 4407;
4410 -> 4406;
4410 -> 4407;
4411 -> 4409;
4411 -> 4407;
4412 -> 4408;
4412 -> 4407;
4413 -> 4410;
4413 -> 4407;
4414 -> 4407;
4415 -> 4411;
4415 -> 4414;
4416 -> 4412;
4416 -> 4414;
4417 -> 4413;
4417 -> 4414;
4418 -> 4415;
4418 -> 1263;
4418 -> 4414;
4419 -> 4418;
4419 -> 4414;
4420 -> 4414;
4421 -> 4416;
4421 -> 4420;
4421 -> 4414;
4422 -> 4421;
4422 -> 4414;
4423 -> 4422;
4424 -> 4417;
4424 -> 4423;
4424 -> 4422;
4425 -> 4424;
4425 -> 4422;
4426 -> 1262;
4426 -> 1261;
4426 -> 4415;
4426 -> 4425;
4427 -> 4426;
4427 -> 4425;
4428 -> 4427;
4428 -> 4407;
4429 -> 4428;
4429 -> 4395;
4430 -> 4334;
4431 -> 4386;
4431 -> 4430;
4431 -> 4334;
4432 -> 4431;
4432 -> 4334;
4433 -> 4432;
4433 -> 4334;
4434 -> 4429;
4434 -> 4334;
4435 -> 4434;
4435 -> 4334;
4436 -> 4435;
4436 -> 4322;
4437 -> 4328;
4437 -> 4436;
4437 -> 4322;
4438 -> 4437;
4438 -> 4322;
4439 -> 4436;
4439 -> 4322;
4440 -> 4439;
4440 -> 4320;
4441 -> 4306;
4441 -> 4320;
4442 -> 4307;
4442 -> 4320;
4443 -> 4308;
4443 -> 4320;
4444 -> 4309;
4444 -> 4320;
4445 -> 4440;
4445 -> 4320;
4446 -> 4311;
4446 -> 4439;
4446 -> 4441;
4446 -> 4442;
4446 -> 4443;
4446 -> 4444;
4446 -> 4445;
4446 -> 4320;
4447 -> 4440;
4447 -> 4303;
4448 -> 4303;
4448 -> 4447;
4448 -> 4446;
4449 -> 4448;
4449 -> 4303;
4450 -> 4449;
4450 -> 4303;
4451 -> 4450;
4451 -> 4296;
4452 -> 4451;
4452 -> 4296;
4453 -> 4296;
4454 -> 4452;
4454 -> 4453;
4455 -> 337;
4455 -> 4453;
4456 -> 4453;
4457 -> 4454;
4457 -> 4456;
4457 -> 4453;
4458 -> 4457;
4458 -> 4453;
4459 -> 4455;
4459 -> 4290;
4459 -> 349;
4459 -> 348;
4459 -> 4453;
4460 -> 4459;
4460 -> 4453;
4461 -> 4455;
4461 -> 349;
4461 -> 348;
4461 -> 4290;
4461 -> 4453;
4462 -> 4454;
4462 -> 4461;
4462 -> 4453;
4463 -> 4455;
4463 -> 4290;
4463 -> 4453;
4464 -> 4296;
4465 -> 4451;
4465 -> 4464;
4466 -> 4465;
4466 -> 4448;
4466 -> 4464;
4467 -> 4466;
4467 -> 0;
4467 -> 4296;
4468 -> 4467;
4468 -> 4296;
4469 -> 4448;
4470 -> 4448;
4470 -> 4469;
4471 -> 4470;
4471 -> 4448;
4471 -> 4469;
4472 -> 4471;
4472 -> 4469;
4473 -> 4472;
4473 -> 4448;
4474 -> 4448;
4475 -> 4448;
4476 -> 4474;
4476 -> 4475;
4476 -> 4448;
4477 -> 4476;
4477 -> 4448;
4478 -> 4448;
4479 -> 4478;
4479 -> 4448;
4480 -> 4477;
4480 -> 4448;
4481 -> 4479;
4481 -> 4448;
4482 -> 4481;
4482 -> 4448;
4483 -> 4448;
4484 -> 4483;
4484 -> 4448;
4485 -> 4484;
4485 -> 4448;
4486 -> 4448;
4487 -> 4448;
4488 -> 4486;
4488 -> 4487;
4488 -> 4448;
4489 -> 4488;
4489 -> 4448;
4490 -> 4489;
4491 -> 4486;
4491 -> 4490;
4491 -> 4489;
4492 -> 4491;
4492 -> 4489;
4493 -> 4486;
4493 -> 4448;
4494 -> 4493;
4495 -> 4474;
4496 -> 4495;
4496 -> 4474;
4497 -> 4496;
4497 -> 4474;
4498 -> 4448;
4499 -> 4448;
4500 -> 4498;
4500 -> 4499;
4501 -> 4499;
4502 -> 4501;
4502 -> 4499;
4503 -> 4499;
4504 -> 4500;
4504 -> 4503;
4504 -> 4499;
4505 -> 4504;
4505 -> 4499;
4506 -> 4505;
4507 -> 4506;
4507 -> 4505;
4508 -> 4507;
4508 -> 4500;
4508 -> 4474;
4508 -> 4505;
4509 -> 4508;
4509 -> 4505;
4510 -> 4502;
4510 -> 4499;
4511 -> 4448;
4512 -> 4510;
4512 -> 4511;
4513 -> 4448;
4513 -> 4511;
4514 -> 4511;
4515 -> 4513;
4515 -> 4474;
4515 -> 4514;
4515 -> 4511;
4516 -> 4515;
4516 -> 4511;
4517 -> 4516;
4518 -> 4517;
4518 -> 4516;
4519 -> 4518;
4519 -> 4448;
4520 -> 4519;
4520 -> 4448;
4521 -> 4520;
4521 -> 4448;
4522 -> 4448;
4523 -> 4474;
4523 -> 0;
4523 -> 4448;
4524 -> 4523;
4524 -> 4448;
4525 -> 4524;
4525 -> 4448;
4526 -> 4448;
4527 -> 4474;
4528 -> 4474;
4529 -> 4527;
4529 -> 4528;
4530 -> 4529;
4530 -> 0;
4530 -> 4528;
4531 -> 4529;
4531 -> 0;
4531 -> 4528;
4532 -> 4530;
4532 -> 4531;
4532 -> 4528;
4533 -> 4532;
4533 -> 4528;
4534 -> 4533;
4534 -> 4474;
4535 -> 4474;
4535 -> 1263;
4536 -> 4535;
4536 -> 4474;
4537 -> 4448;
4538 -> 4521;
4538 -> 4537;
4538 -> 4448;
4539 -> 4538;
4539 -> 4448;
4540 -> 4539;
4540 -> 4448;
4541 -> 4473;
4541 -> 4474;
4541 -> 4448;
4542 -> 4541;
4542 -> 4448;
4543 -> 4474;
4543 -> 4448;
4544 -> 4543;
4544 -> 4448;
4545 -> 4544;
4545 -> 4296;
4546 -> 4545;
4546 -> 4296;
4547 -> 4546;
4547 -> 4453;
4548 -> 4547;
4548 -> 4456;
4548 -> 4453;
4549 -> 4548;
4549 -> 4453;
4550 -> 4455;
4550 -> 4463;
4550 -> 349;
4550 -> 348;
4550 -> 4453;
4551 -> 4550;
4551 -> 4453;
4552 -> 4455;
4552 -> 349;
4552 -> 348;
4552 -> 4463;
4552 -> 4453;
4553 -> 4547;
4553 -> 4552;
4553 -> 4453;
4554 -> 4545;
4554 -> 4464;
4555 -> 4554;
4555 -> 4474;
4555 -> 4464;
4556 -> 4555;
4556 -> 0;
4556 -> 4296;
4557 -> 4556;
4557 -> 4296;
4558 -> 4474;
4559 -> 4474;
4559 -> 4558;
4560 -> 4559;
4560 -> 4474;
4561 -> 4474;
4562 -> 4561;
4562 -> 4474;
4563 -> 4560;
4563 -> 4474;
4564 -> 4562;
4564 -> 4474;
4565 -> 4564;
4565 -> 4474;
4566 -> 4474;
4567 -> 4474;
4568 -> 4566;
4568 -> 4567;
4568 -> 4474;
4569 -> 4568;
4569 -> 4474;
4570 -> 4569;
4571 -> 4566;
4571 -> 4570;
4571 -> 4569;
4572 -> 4571;
4572 -> 4569;
4573 -> 4566;
4573 -> 4474;
4574 -> 4573;
4575 -> 4474;
4576 -> 4474;
4577 -> 4575;
4577 -> 4576;
4578 -> 4576;
4579 -> 4578;
4579 -> 4576;
4580 -> 4576;
4581 -> 4577;
4581 -> 4580;
4581 -> 4576;
4582 -> 4581;
4582 -> 4576;
4583 -> 4582;
4584 -> 4583;
4584 -> 4582;
4585 -> 4584;
4585 -> 4577;
4585 -> 4474;
4585 -> 4582;
4586 -> 4585;
4586 -> 4582;
4587 -> 4579;
4587 -> 4576;
4588 -> 4474;
4589 -> 4587;
4589 -> 4588;
4590 -> 4474;
4590 -> 4588;
4591 -> 4588;
4592 -> 4590;
4592 -> 4474;
4592 -> 4591;
4592 -> 4588;
4593 -> 4592;
4593 -> 4588;
4594 -> 4593;
4595 -> 4594;
4595 -> 4593;
4596 -> 4595;
4596 -> 4474;
4597 -> 4596;
4597 -> 4474;
4598 -> 4597;
4598 -> 4474;
4599 -> 4474;
4600 -> 4474;
4600 -> 0;
4601 -> 4600;
4601 -> 4474;
4602 -> 4601;
4602 -> 4474;
4603 -> 4474;
4604 -> 4474;
4605 -> 4598;
4605 -> 4604;
4605 -> 4474;
4606 -> 4605;
4606 -> 4474;
4607 -> 4606;
4607 -> 4474;
4608 -> 4474;
4609 -> 4608;
4609 -> 4474;
4610 -> 4609;
4610 -> 4296;
4611 -> 4610;
4611 -> 4296;
4612 -> 4611;
4612 -> 4453;
4613 -> 4612;
4613 -> 4456;
4613 -> 4453;
4614 -> 4613;
4614 -> 4453;
4615 -> 4612;
4615 -> 4552;
4615 -> 4453;
4616 -> 4610;
4616 -> 4464;
4617 -> 4616;
4617 -> 4464;
4618 -> 4617;
4618 -> 0;
4618 -> 4296;
4619 -> 4618;
4619 -> 4296;
4620 -> 4474;
4621 -> 4620;
4621 -> 4474;
4622 -> 4621;
4622 -> 4474;
4623 -> 4622;
4624 -> 4623;
4624 -> 4622;
4625 -> 4495;
4625 -> 4624;
4625 -> 4474;
4626 -> 4625;
4626 -> 4474;
4627 -> 187;
4627 -> 4626;
4628 -> 4627;
4628 -> 4474;
4629 -> 4628;
4629 -> 4567;
4629 -> 4474;
4630 -> 4629;
4630 -> 4474;
4631 -> 4630;
4632 -> 4628;
4632 -> 4631;
4632 -> 4630;
4633 -> 4632;
4633 -> 4630;
4634 -> 4628;
4634 -> 4633;
4635 -> 4633;
4636 -> 4634;
4636 -> 4635;
4637 -> 4635;
4638 -> 4636;
4638 -> 4637;
4638 -> 4635;
4639 -> 4635;
4640 -> 4636;
4640 -> 4639;
4640 -> 4635;
4641 -> 4638;
4641 -> 4640;
4641 -> 4635;
4642 -> 4635;
4643 -> 4636;
4643 -> 4642;
4643 -> 4635;
4644 -> 4641;
4644 -> 4643;
4644 -> 4635;
4645 -> 4635;
4646 -> 4636;
4646 -> 4645;
4646 -> 4635;
4647 -> 4644;
4647 -> 4646;
4647 -> 4635;
4648 -> 4635;
4649 -> 4636;
4649 -> 4648;
4649 -> 4635;
4650 -> 4647;
4650 -> 4649;
4650 -> 4635;
4651 -> 4635;
4652 -> 4636;
4652 -> 4651;
4652 -> 4635;
4653 -> 4650;
4653 -> 4652;
4653 -> 4635;
4654 -> 4635;
4655 -> 4636;
4655 -> 4654;
4655 -> 4635;
4656 -> 4653;
4656 -> 4655;
4656 -> 4635;
4657 -> 4635;
4658 -> 4636;
4658 -> 4657;
4658 -> 4635;
4659 -> 4636;
4659 -> 4635;
4660 -> 4659;
4660 -> 4635;
4661 -> 4660;
4661 -> 0;
4661 -> 4635;
4662 -> 4658;
4662 -> 4661;
4662 -> 4635;
4663 -> 4656;
4663 -> 4662;
4663 -> 4635;
4664 -> 4663;
4664 -> 4635;
4665 -> 4664;
4665 -> 4633;
4666 -> 4628;
4666 -> 4665;
4667 -> 4665;
4668 -> 4666;
4668 -> 4667;
4669 -> 4667;
4670 -> 4668;
4670 -> 4669;
4670 -> 4667;
4671 -> 4667;
4672 -> 4668;
4672 -> 4671;
4672 -> 4667;
4673 -> 4670;
4673 -> 4672;
4673 -> 4667;
4674 -> 4667;
4675 -> 4668;
4675 -> 4674;
4675 -> 4667;
4676 -> 4673;
4676 -> 4675;
4676 -> 4667;
4677 -> 4667;
4678 -> 4668;
4678 -> 4677;
4678 -> 4667;
4679 -> 4676;
4679 -> 4678;
4679 -> 4667;
4680 -> 4667;
4681 -> 4668;
4681 -> 4680;
4681 -> 4667;
4682 -> 4679;
4682 -> 4681;
4682 -> 4667;
4683 -> 4682;
4683 -> 4667;
4684 -> 4683;
4684 -> 4665;
4685 -> 4628;
4685 -> 4474;
4686 -> 4685;
4687 -> 4620;
4688 -> 4620;
4689 -> 4688;
4689 -> 4620;
4690 -> 4689;
4691 -> 4690;
4691 -> 4689;
4692 -> 4687;
4692 -> 4691;
4692 -> 4620;
4693 -> 4692;
4693 -> 4620;
4694 -> 187;
4694 -> 4693;
4695 -> 4474;
4695 -> 4620;
4696 -> 4695;
4696 -> 4694;
4696 -> 4620;
4697 -> 4620;
4698 -> 4695;
4698 -> 4697;
4699 -> 4698;
4699 -> 4694;
4699 -> 4697;
4700 -> 4699;
4700 -> 4695;
4700 -> 4694;
4700 -> 4620;
4701 -> 4696;
4701 -> 4700;
4701 -> 4620;
4702 -> 4701;
4702 -> 4620;
4703 -> 0;
4705 -> 4703;
4705 -> 4704;
4706 -> 4704;
4707 -> 4705;
4707 -> 4706;
4707 -> 4704;
4710 -> 4708;
4710 -> 4709;
4711 -> 4709;
4712 -> 4710;
4712 -> 4711;
4712 -> 4709;
4713 -> 4709;
4714 -> 4704;
4715 -> 4474;
4715 -> 4620;
4716 -> 4715;
4716 -> 4702;
4716 -> 4620;
4717 -> 4620;
4718 -> 4716;
4718 -> 4717;
4719 -> 4718;
4719 -> 4717;
4720 -> 4717;
4721 -> 4719;
4721 -> 4720;
4721 -> 4717;
4722 -> 4721;
4722 -> 4717;
4723 -> 4722;
4723 -> 4717;
4724 -> 4719;
4724 -> 4717;
4725 -> 4724;
4725 -> 4620;
4726 -> 4620;
4727 -> 4725;
4727 -> 4726;
4727 -> 4620;
4728 -> 4727;
4728 -> 4620;
4729 -> 4728;
4729 -> 4620;
4730 -> 4729;
4730 -> 4620;
4731 -> 4474;
4731 -> 4620;
4732 -> 4731;
4732 -> 4730;
4732 -> 4620;
4733 -> 4620;
4734 -> 4732;
4734 -> 4733;
4735 -> 4733;
4736 -> 4734;
4736 -> 4735;
4736 -> 4733;
4737 -> 4736;
4737 -> 4733;
4738 -> 4737;
4738 -> 4733;
4739 -> 4734;
4739 -> 4620;
4740 -> 4620;
4741 -> 4739;
4741 -> 4740;
4741 -> 4620;
4742 -> 4741;
4742 -> 4620;
4743 -> 4742;
4743 -> 4620;
4744 -> 4743;
4744 -> 4620;
4745 -> 4584;
4745 -> 4577;
4745 -> 4744;
4745 -> 4582;
4746 -> 4745;
4746 -> 4582;
4747 -> 4590;
4747 -> 4744;
4747 -> 4591;
4747 -> 4588;
4748 -> 4747;
4748 -> 4588;
4749 -> 4748;
4750 -> 4749;
4750 -> 4748;
4751 -> 4750;
4751 -> 4474;
4752 -> 4751;
4752 -> 4474;
4753 -> 4752;
4753 -> 4474;
4754 -> 4744;
4754 -> 0;
4754 -> 4474;
4755 -> 4754;
4755 -> 4474;
4756 -> 4755;
4756 -> 4474;
4757 -> 4744;
4758 -> 4744;
4759 -> 4744;
4760 -> 4744;
4761 -> 4757;
4761 -> 4760;
4762 -> 4758;
4762 -> 4760;
4763 -> 4759;
4763 -> 4760;
4764 -> 4762;
4764 -> 1263;
4764 -> 4760;
4765 -> 4764;
4765 -> 4760;
4766 -> 4763;
4766 -> 4761;
4767 -> 1262;
4767 -> 1261;
4767 -> 4762;
4767 -> 4766;
4768 -> 4767;
4768 -> 4744;
4769 -> 4753;
4769 -> 4604;
4769 -> 4474;
4770 -> 4769;
4770 -> 4474;
4771 -> 4770;
4771 -> 4474;
4772 -> 4768;
4772 -> 4474;
4773 -> 4772;
4773 -> 4474;
4774 -> 4773;
4774 -> 4296;
4775 -> 4774;
4775 -> 4296;
4776 -> 4775;
4776 -> 4453;
4777 -> 4776;
4777 -> 4456;
4777 -> 4453;
4778 -> 4777;
4778 -> 4453;
4779 -> 4776;
4779 -> 4552;
4779 -> 4453;
4780 -> 4774;
4780 -> 4464;
4781 -> 4780;
4781 -> 4464;
4782 -> 4781;
4782 -> 0;
4782 -> 4296;
4783 -> 4782;
4783 -> 4296;
4784 -> 272;
4785 -> 4784;
4785 -> 278;
4785 -> 272;
4786 -> 278;
4786 -> 272;
4787 -> 278;
4787 -> 272;
4788 -> 278;
4788 -> 272;
4789 -> 278;
4789 -> 272;
4790 -> 278;
4790 -> 272;
4791 -> 278;
4791 -> 272;
4792 -> 272;
4793 -> 4792;
4793 -> 278;
4793 -> 272;
4794 -> 278;
4794 -> 4793;
4794 -> 272;
4795 -> 4794;
4795 -> 4792;
4795 -> 272;
4796 -> 4795;
4796 -> 278;
4796 -> 272;
4797 -> 272;
4797 -> 264;
4798 -> 4797;
4798 -> 74;
4799 -> 74;
4800 -> 4798;
4800 -> 4799;
4801 -> 4800;
4801 -> 4799;
4802 -> 0;
4802 -> 4799;
4803 -> 4799;
4804 -> 4801;
4804 -> 4803;
4805 -> 4802;
4805 -> 4803;
4806 -> 4800;
4806 -> 4803;
4807 -> 4803;
4808 -> 4806;
4808 -> 4788;
4808 -> 4807;
4808 -> 4803;
4809 -> 4808;
4809 -> 4803;
4810 -> 4804;
4810 -> 4801;
4810 -> 311;
4810 -> 319;
4810 -> 313;
4810 -> 312;
4810 -> 302;
4810 -> 349;
4810 -> 304;
4810 -> 305;
4810 -> 306;
4810 -> 4463;
4810 -> 308;
4810 -> 309;
4810 -> 310;
4810 -> 314;
4810 -> 316;
4810 -> 326;
4810 -> 4785;
4810 -> 4793;
4810 -> 4796;
4810 -> 4788;
4810 -> 4789;
4810 -> 4790;
4810 -> 4791;
4810 -> 4744;
4810 -> 348;
4810 -> 4784;
4810 -> 4795;
4810 -> 4803;
4811 -> 4803;
4812 -> 4810;
4812 -> 4811;
4813 -> 4811;
4814 -> 4812;
4814 -> 4813;
4815 -> 4814;
4815 -> 4810;
4815 -> 4813;
4816 -> 4815;
4816 -> 4813;
4817 -> 4814;
4817 -> 4815;
4817 -> 4813;
4818 -> 4814;
4818 -> 4815;
4818 -> 0;
4818 -> 4813;
4819 -> 4818;
4819 -> 4814;
4819 -> 4813;
4820 -> 4813;
4821 -> 4814;
4821 -> 4820;
4822 -> 4820;
4823 -> 4821;
4823 -> 4822;
4824 -> 4822;
4825 -> 4823;
4825 -> 4824;
4826 -> 4825;
4826 -> 4815;
4826 -> 4824;
4827 -> 4826;
4827 -> 4824;
4828 -> 4824;
4829 -> 4825;
4829 -> 4815;
4829 -> 4828;
4829 -> 4824;
4830 -> 4829;
4830 -> 4824;
4831 -> 4825;
4831 -> 4815;
4831 -> 4819;
4831 -> 4830;
4832 -> 4831;
4832 -> 4830;
4833 -> 4832;
4833 -> 4823;
4833 -> 4822;
4834 -> 4832;
4834 -> 4822;
4835 -> 4834;
4835 -> 4823;
4835 -> 4815;
4835 -> 4833;
4835 -> 4822;
4836 -> 4835;
4836 -> 4822;
4837 -> 4820;
4838 -> 4836;
4838 -> 4837;
4839 -> 4838;
4839 -> 4815;
4839 -> 4837;
4840 -> 4839;
4840 -> 0;
4840 -> 4820;
4841 -> 4840;
4841 -> 4820;
4842 -> 4841;
4842 -> 4813;
4843 -> 4817;
4843 -> 4814;
4843 -> 4813;
4844 -> 4816;
4844 -> 4815;
4844 -> 4819;
4844 -> 4843;
4844 -> 4833;
4844 -> 4813;
4845 -> 4844;
4845 -> 4813;
4846 -> 4816;
4846 -> 4813;
4847 -> 4814;
4847 -> 4844;
4847 -> 4846;
4847 -> 4813;
4848 -> 4811;
4849 -> 4848;
4849 -> 4811;
4850 -> 4811;
4851 -> 4845;
4851 -> 4850;
4852 -> 4849;
4852 -> 4850;
4853 -> 4812;
4853 -> 4850;
4854 -> 4851;
4854 -> 4850;
4855 -> 4852;
4855 -> 4850;
4856 -> 4850;
4857 -> 4854;
4857 -> 4856;
4858 -> 4855;
4858 -> 4856;
4859 -> 4853;
4859 -> 4856;
4860 -> 4856;
4861 -> 4859;
4861 -> 4860;
4862 -> 4860;
4863 -> 4861;
4863 -> 4862;
4864 -> 4863;
4864 -> 4847;
4864 -> 4862;
4865 -> 4864;
4865 -> 4860;
4866 -> 4865;
4867 -> 4866;
4867 -> 4865;
4868 -> 4867;
4868 -> 4856;
4869 -> 4868;
4869 -> 4856;
4870 -> 4869;
4870 -> 4856;
4871 -> 4870;
4871 -> 4856;
4872 -> 4871;
4872 -> 4850;
4873 -> 4850;
4874 -> 4853;
4874 -> 4873;
4875 -> 4873;
4876 -> 4874;
4876 -> 4875;
4877 -> 4875;
4878 -> 4876;
4878 -> 4877;
4879 -> 4878;
4879 -> 4847;
4879 -> 4877;
4880 -> 4879;
4880 -> 4875;
4881 -> 4875;
4882 -> 4876;
4882 -> 4847;
4882 -> 4881;
4882 -> 4875;
4883 -> 4882;
4883 -> 4875;
4884 -> 4880;
4884 -> 4876;
4884 -> 4883;
4885 -> 4876;
4885 -> 4847;
4885 -> 4875;
4886 -> 4876;
4886 -> 4847;
4886 -> 4885;
4886 -> 4875;
4887 -> 4876;
4887 -> 4847;
4887 -> 4875;
4888 -> 4880;
4888 -> 4875;
4889 -> 4876;
4889 -> 4847;
4889 -> 4875;
4890 -> 4886;
4890 -> 4887;
4890 -> 4888;
4890 -> 4889;
4890 -> 4847;
4890 -> 4884;
4890 -> 4885;
4890 -> 4875;
4891 -> 4890;
4891 -> 4875;
4892 -> 4874;
4892 -> 4890;
4892 -> 4873;
4893 -> 4874;
4893 -> 4890;
4893 -> 4873;
4894 -> 4874;
4894 -> 4890;
4894 -> 4873;
4895 -> 4874;
4895 -> 4890;
4895 -> 4873;
4896 -> 4873;
4897 -> 4891;
4897 -> 4896;
4898 -> 4892;
4898 -> 4896;
4899 -> 4893;
4899 -> 4896;
4900 -> 4894;
4900 -> 4896;
4901 -> 4895;
4901 -> 4896;
4902 -> 4896;
4903 -> 4897;
4903 -> 4902;
4903 -> 4896;
4904 -> 4898;
4904 -> 4902;
4904 -> 4896;
4905 -> 4899;
4905 -> 4902;
4905 -> 4896;
4906 -> 4900;
4906 -> 4902;
4906 -> 4896;
4907 -> 4901;
4907 -> 4902;
4907 -> 4896;
4908 -> 4896;
4908 -> 4873;
4909 -> 4908;
4909 -> 4850;
4910 -> 4853;
4910 -> 4890;
4910 -> 4850;
4911 -> 4853;
4911 -> 4890;
4911 -> 4910;
4911 -> 4850;
4912 -> 4911;
4912 -> 4850;
4913 -> 4850;
4914 -> 4850;
4915 -> 4853;
4915 -> 4914;
4916 -> 4915;
4916 -> 4890;
4916 -> 4914;
4917 -> 4916;
4917 -> 4914;
4918 -> 4850;
4919 -> 4917;
4919 -> 4918;
4920 -> 4919;
4920 -> 4890;
4920 -> 4918;
4921 -> 4920;
4921 -> 4850;
4922 -> 4851;
4922 -> 4921;
4923 -> 4852;
4923 -> 4921;
4924 -> 4921;
4925 -> 4922;
4925 -> 4924;
4926 -> 4923;
4926 -> 4924;
4927 -> 4853;
4927 -> 4924;
4928 -> 4924;
4929 -> 4927;
4929 -> 4928;
4930 -> 4924;
4931 -> 4929;
4931 -> 4930;
4932 -> 4930;
4933 -> 4931;
4933 -> 4932;
4934 -> 4933;
4934 -> 4930;
4935 -> 4934;
4935 -> 0;
4935 -> 4924;
4936 -> 4935;
4936 -> 4924;
4937 -> 4936;
4937 -> 4924;
4938 -> 4937;
4939 -> 4927;
4939 -> 4938;
4940 -> 4938;
4941 -> 4939;
4941 -> 4940;
4942 -> 4938;
4943 -> 4941;
4943 -> 4942;
4944 -> 4943;
4944 -> 0;
4944 -> 4938;
4945 -> 4944;
4945 -> 4938;
4946 -> 4945;
4946 -> 4937;
4947 -> 4946;
4948 -> 4927;
4948 -> 4947;
4949 -> 4947;
4950 -> 4947;
4951 -> 4949;
4951 -> 4950;
4952 -> 4948;
4952 -> 4950;
4953 -> 4950;
4954 -> 4951;
4954 -> 4953;
4954 -> 4950;
4955 -> 4954;
4955 -> 4950;
4956 -> 4952;
4956 -> 4890;
4956 -> 4951;
4956 -> 4950;
4957 -> 4956;
4957 -> 4952;
4957 -> 4890;
4957 -> 4950;
4958 -> 4957;
4958 -> 4950;
4959 -> 4950;
4960 -> 4952;
4960 -> 4890;
4960 -> 4959;
4960 -> 4950;
4961 -> 4960;
4961 -> 4950;
4962 -> 4952;
4962 -> 4890;
4962 -> 4951;
4962 -> 4961;
4963 -> 4952;
4963 -> 4890;
4963 -> 4910;
4963 -> 4962;
4963 -> 4961;
4964 -> 4963;
4964 -> 4961;
4965 -> 4947;
4966 -> 4964;
4966 -> 4965;
4967 -> 4966;
4967 -> 0;
4967 -> 4947;
4968 -> 4967;
4968 -> 4947;
4969 -> 4968;
4969 -> 4947;
4970 -> 4969;
4970 -> 4946;
4971 -> 4970;
4972 -> 4927;
4972 -> 4971;
4973 -> 4971;
4974 -> 4972;
4974 -> 4973;
4975 -> 4971;
4976 -> 4974;
4976 -> 4975;
4977 -> 4976;
4977 -> 0;
4977 -> 4971;
4978 -> 4977;
4978 -> 4971;
4979 -> 4978;
4979 -> 4971;
4980 -> 4979;
4980 -> 4970;
4981 -> 4980;
4982 -> 4927;
4982 -> 4981;
4983 -> 4981;
4984 -> 4982;
4984 -> 4983;
4985 -> 4983;
4986 -> 4984;
4986 -> 4985;
4987 -> 4985;
4988 -> 4986;
4988 -> 4890;
4988 -> 4987;
4989 -> 4988;
4989 -> 4890;
4989 -> 4987;
4990 -> 4989;
4990 -> 4985;
4991 -> 4990;
4991 -> 4890;
4991 -> 0;
4991 -> 4983;
4992 -> 4991;
4992 -> 4983;
4993 -> 4981;
4994 -> 4982;
4994 -> 4993;
4995 -> 4994;
4995 -> 4890;
4995 -> 4910;
4995 -> 4993;
4996 -> 4992;
4996 -> 4995;
4996 -> 4981;
4997 -> 4996;
4997 -> 4981;
4998 -> 4997;
4998 -> 4981;
4999 -> 4998;
4999 -> 4980;
5000 -> 4999;
5001 -> 5000;
5001 -> 4999;
5002 -> 4926;
5002 -> 4999;
5003 -> 5002;
5003 -> 4999;
5004 -> 4999;
5005 -> 5001;
5005 -> 5004;
5006 -> 5003;
5006 -> 5004;
5007 -> 4927;
5007 -> 5004;
5008 -> 5004;
5009 -> 5007;
5009 -> 5008;
5010 -> 5004;
5011 -> 5009;
5011 -> 5010;
5012 -> 5011;
5012 -> 0;
5012 -> 5004;
5013 -> 5012;
5013 -> 5004;
5014 -> 5004;
5015 -> 5014;
5015 -> 5004;
5016 -> 5015;
5016 -> 4999;
5017 -> 4924;
5018 -> 5017;
5018 -> 4924;
5019 -> 5018;
5019 -> 4921;
5020 -> 4921;
5021 -> 5019;
5021 -> 5020;
5021 -> 4921;
5022 -> 5021;
5022 -> 4921;
5023 -> 4851;
5023 -> 4850;
5024 -> 4852;
5024 -> 4850;
5025 -> 4909;
5025 -> 4850;
5026 -> 4850;
5027 -> 5023;
5027 -> 5026;
5028 -> 5024;
5028 -> 5026;
5029 -> 5025;
5029 -> 5026;
5030 -> 4853;
5030 -> 5026;
5031 -> 5028;
5031 -> 5026;
5032 -> 5031;
5032 -> 5026;
5033 -> 5032;
5033 -> 5026;
5034 -> 5026;
5035 -> 5033;
5035 -> 5034;
5036 -> 5030;
5036 -> 5034;
5037 -> 5034;
5038 -> 5036;
5038 -> 5037;
5039 -> 5038;
5039 -> 4890;
5039 -> 5037;
5040 -> 5039;
5040 -> 5037;
5041 -> 5034;
5042 -> 5040;
5042 -> 5041;
5043 -> 5042;
5043 -> 4890;
5043 -> 5041;
5044 -> 5043;
5044 -> 5034;
5045 -> 5044;
5045 -> 0;
5045 -> 5034;
5046 -> 5044;
5046 -> 5034;
5047 -> 5034;
5048 -> 5046;
5048 -> 5047;
5049 -> 5048;
5049 -> 5047;
5050 -> 5049;
5051 -> 5050;
5051 -> 5049;
5052 -> 5045;
5052 -> 5051;
5052 -> 5034;
5053 -> 5044;
5053 -> 5034;
5054 -> 5034;
5055 -> 5053;
5055 -> 5054;
5056 -> 5055;
5056 -> 5054;
5057 -> 5056;
5058 -> 5057;
5058 -> 5056;
5059 -> 5058;
5059 -> 5034;
5060 -> 5059;
5060 -> 5034;
5061 -> 5052;
5061 -> 5060;
5061 -> 5034;
5062 -> 5061;
5062 -> 5034;
5063 -> 5044;
5063 -> 0;
5063 -> 5034;
5064 -> 5063;
5064 -> 5034;
5065 -> 5034;
5066 -> 5036;
5066 -> 5065;
5067 -> 5065;
5068 -> 5066;
5068 -> 5067;
5069 -> 5068;
5069 -> 4890;
5069 -> 5067;
5070 -> 5069;
5070 -> 5067;
5071 -> 5065;
5072 -> 5070;
5072 -> 5071;
5073 -> 5071;
5074 -> 5072;
5074 -> 5073;
5075 -> 5074;
5075 -> 4890;
5075 -> 5073;
5076 -> 5075;
5076 -> 5071;
5077 -> 5076;
5077 -> 0;
5077 -> 5065;
5078 -> 5077;
5078 -> 5065;
5079 -> 5078;
5079 -> 5034;
5080 -> 5034;
5081 -> 5036;
5081 -> 5080;
5082 -> 5081;
5082 -> 4890;
5082 -> 5080;
5083 -> 5082;
5083 -> 5080;
5084 -> 5034;
5085 -> 5083;
5085 -> 5084;
5086 -> 5084;
5087 -> 5085;
5087 -> 5086;
5088 -> 5087;
5088 -> 4890;
5088 -> 5086;
5089 -> 5088;
5089 -> 5084;
5090 -> 5089;
5090 -> 5034;
5091 -> 5090;
5091 -> 5034;
5092 -> 5034;
5093 -> 5091;
5093 -> 5092;
5094 -> 5093;
5094 -> 5092;
5095 -> 5094;
5096 -> 5095;
5096 -> 5094;
5097 -> 5090;
5097 -> 0;
5097 -> 5034;
5098 -> 5096;
5098 -> 5097;
5098 -> 5034;
5099 -> 5098;
5099 -> 5034;
5100 -> 5099;
5100 -> 5034;
5101 -> 5100;
5101 -> 5034;
5102 -> 5035;
5102 -> 5034;
5103 -> 5034;
5104 -> 5102;
5104 -> 5103;
5105 -> 5036;
5105 -> 5103;
5106 -> 5103;
5107 -> 5105;
5107 -> 5106;
5108 -> 5107;
5108 -> 4890;
5108 -> 5106;
5109 -> 5108;
5109 -> 5106;
5110 -> 5103;
5111 -> 5103;
5112 -> 5110;
5112 -> 5111;
5113 -> 5105;
5113 -> 5111;
5114 -> 5111;
5115 -> 5112;
5115 -> 5114;
5115 -> 5111;
5116 -> 5115;
5116 -> 5111;
5117 -> 5113;
5117 -> 4890;
5117 -> 5112;
5117 -> 5111;
5118 -> 5117;
5118 -> 5113;
5118 -> 4890;
5118 -> 5111;
5119 -> 5118;
5119 -> 5111;
5120 -> 5111;
5121 -> 5113;
5121 -> 4890;
5121 -> 5120;
5121 -> 5111;
5122 -> 5121;
5122 -> 5111;
5123 -> 5113;
5123 -> 4890;
5123 -> 5112;
5123 -> 5122;
5124 -> 5113;
5124 -> 4890;
5124 -> 4910;
5124 -> 5123;
5124 -> 5122;
5125 -> 5124;
5125 -> 5122;
5126 -> 5103;
5127 -> 5126;
5127 -> 5103;
5128 -> 5103;
5129 -> 5109;
5129 -> 5128;
5130 -> 5125;
5130 -> 5128;
5131 -> 5127;
5131 -> 5128;
5132 -> 5105;
5132 -> 5128;
5133 -> 5129;
5133 -> 5128;
5134 -> 5128;
5135 -> 5133;
5135 -> 5134;
5136 -> 5132;
5136 -> 5134;
5137 -> 5134;
5138 -> 5135;
5138 -> 5137;
5139 -> 5138;
5139 -> 4890;
5139 -> 5137;
5140 -> 5139;
5140 -> 0;
5140 -> 5134;
5141 -> 5134;
5142 -> 5136;
5142 -> 5141;
5143 -> 5142;
5143 -> 4890;
5143 -> 4910;
5143 -> 5141;
5144 -> 5143;
5144 -> 5134;
5145 -> 5140;
5145 -> 5144;
5145 -> 5134;
5146 -> 5145;
5146 -> 5134;
5147 -> 5146;
5147 -> 5128;
5148 -> 5147;
5149 -> 5130;
5149 -> 5148;
5150 -> 5149;
5150 -> 5147;
5151 -> 5129;
5151 -> 5150;
5152 -> 5150;
5153 -> 5151;
5153 -> 5152;
5154 -> 5152;
5155 -> 5153;
5155 -> 5154;
5156 -> 5154;
5157 -> 5155;
5157 -> 5156;
5158 -> 5157;
5158 -> 5154;
5159 -> 5158;
5159 -> 0;
5159 -> 5152;
5160 -> 5159;
5160 -> 5152;
5161 -> 5160;
5161 -> 5150;
5162 -> 5161;
5163 -> 5162;
5163 -> 5161;
5164 -> 5163;
5164 -> 5103;
5165 -> 5103;
5166 -> 5164;
5166 -> 5165;
5166 -> 5103;
5167 -> 5166;
5167 -> 5103;
5168 -> 5164;
5168 -> 5167;
5169 -> 5168;
5169 -> 5034;
5170 -> 5169;
5170 -> 5026;
5171 -> 5027;
5171 -> 5170;
5172 -> 5170;
5173 -> 5171;
5173 -> 5172;
5174 -> 5030;
5174 -> 5172;
5175 -> 5173;
5175 -> 5172;
5176 -> 5172;
5177 -> 5174;
5177 -> 5176;
5178 -> 0;
5178 -> 5176;
5179 -> 5176;
5180 -> 5178;
5180 -> 5179;
5181 -> 5177;
5181 -> 5179;
5182 -> 5181;
5182 -> 4890;
5182 -> 4910;
5182 -> 5179;
5183 -> 5181;
5183 -> 4890;
5183 -> 4910;
5183 -> 5182;
5183 -> 5179;
5184 -> 5183;
5184 -> 5179;
5185 -> 5180;
5185 -> 5179;
5186 -> 5179;
5187 -> 5185;
5187 -> 5186;
5188 -> 5181;
5188 -> 5186;
5189 -> 5186;
5190 -> 5186;
5191 -> 5190;
5191 -> 5186;
5192 -> 5186;
5193 -> 5188;
5193 -> 5192;
5194 -> 5186;
5195 -> 5193;
5195 -> 5194;
5196 -> 5195;
5196 -> 5186;
5197 -> 5196;
5197 -> 5186;
5198 -> 5186;
5199 -> 5197;
5199 -> 5198;
5200 -> 5199;
5200 -> 5198;
5201 -> 5200;
5202 -> 5201;
5202 -> 5200;
5203 -> 5202;
5203 -> 5186;
5204 -> 5196;
5204 -> 5186;
5205 -> 5186;
5206 -> 5204;
5206 -> 5205;
5207 -> 5206;
5207 -> 5205;
5208 -> 5205;
5209 -> 5207;
5209 -> 5208;
5210 -> 5209;
5210 -> 5208;
5211 -> 5208;
5212 -> 5210;
5212 -> 5211;
5213 -> 5212;
5213 -> 5211;
5214 -> 0;
5214 -> 5213;
5215 -> 5214;
5215 -> 0;
5215 -> 5208;
5216 -> 5215;
5216 -> 5208;
5217 -> 5216;
5217 -> 5205;
5218 -> 5217;
5218 -> 5205;
5219 -> 5218;
5219 -> 5205;
5220 -> 5219;
5220 -> 5186;
5221 -> 5196;
5221 -> 0;
5221 -> 5220;
5222 -> 5221;
5222 -> 5220;
5223 -> 5222;
5224 -> 5188;
5224 -> 5223;
5225 -> 5223;
5226 -> 5224;
5226 -> 5225;
5227 -> 5223;
5228 -> 5226;
5228 -> 5227;
5229 -> 5228;
5229 -> 0;
5229 -> 5223;
5230 -> 5229;
5230 -> 5223;
5231 -> 5223;
5232 -> 5231;
5232 -> 5223;
5233 -> 5232;
5233 -> 5222;
5234 -> 5233;
5235 -> 5234;
5235 -> 5233;
5236 -> 5233;
5237 -> 5236;
5237 -> 5233;
5238 -> 5233;
5239 -> 5235;
5239 -> 5238;
5240 -> 5237;
5240 -> 5238;
5241 -> 5188;
5241 -> 5238;
5242 -> 5238;
5243 -> 5241;
5243 -> 5242;
5244 -> 5238;
5245 -> 5243;
5245 -> 5244;
5246 -> 5245;
5246 -> 0;
5246 -> 5238;
5247 -> 5246;
5247 -> 5238;
5248 -> 5238;
5249 -> 5248;
5249 -> 5238;
5250 -> 5249;
5250 -> 5233;
5251 -> 5250;
5252 -> 5250;
5253 -> 5251;
5253 -> 5252;
5254 -> 5253;
5254 -> 0;
5254 -> 5250;
5255 -> 5254;
5255 -> 5250;
5256 -> 5255;
5256 -> 5250;
5257 -> 5196;
5257 -> 0;
5257 -> 5256;
5258 -> 5257;
5258 -> 5256;
5259 -> 5187;
5259 -> 5258;
5260 -> 5258;
5261 -> 5259;
5261 -> 5260;
5262 -> 5188;
5262 -> 5260;
5263 -> 5261;
5263 -> 0;
5263 -> 5260;
5264 -> 5260;
5265 -> 5262;
5265 -> 5264;
5266 -> 5260;
5267 -> 5265;
5267 -> 5266;
5268 -> 5260;
5269 -> 5262;
5269 -> 5268;
5270 -> 5260;
5271 -> 5269;
5271 -> 5270;
5272 -> 5260;
5273 -> 5271;
5273 -> 5272;
5274 -> 5273;
5274 -> 5272;
5275 -> 5272;
5276 -> 5274;
5276 -> 5275;
5277 -> 5276;
5277 -> 5275;
5278 -> 5277;
5279 -> 5278;
5279 -> 5277;
5280 -> 5279;
5280 -> 5272;
5281 -> 5267;
5281 -> 5280;
5281 -> 5260;
5282 -> 5263;
5282 -> 5281;
5282 -> 5260;
5283 -> 5282;
5283 -> 5260;
5284 -> 5283;
5285 -> 5284;
5285 -> 5283;
5286 -> 5285;
5286 -> 5258;
5287 -> 5187;
5287 -> 5286;
5288 -> 5286;
5289 -> 5287;
5289 -> 5288;
5290 -> 5188;
5290 -> 5288;
5291 -> 5289;
5291 -> 5288;
5292 -> 5288;
5293 -> 5291;
5293 -> 5292;
5294 -> 5290;
5294 -> 5292;
5295 -> 5292;
5296 -> 5294;
5296 -> 5295;
5297 -> 5292;
5298 -> 5296;
5298 -> 5297;
5299 -> 5298;
5299 -> 5292;
5300 -> 5299;
5300 -> 5292;
5301 -> 5300;
5302 -> 5294;
5302 -> 5301;
5303 -> 5301;
5304 -> 5302;
5304 -> 5303;
5305 -> 5301;
5306 -> 5304;
5306 -> 5305;
5307 -> 5306;
5307 -> 0;
5307 -> 5301;
5308 -> 5307;
5308 -> 5301;
5309 -> 5308;
5310 -> 5302;
5310 -> 5309;
5311 -> 5309;
5312 -> 5310;
5312 -> 5311;
5313 -> 5309;
5314 -> 5312;
5314 -> 5313;
5315 -> 5314;
5315 -> 0;
5315 -> 5309;
5316 -> 5315;
5316 -> 5309;
5317 -> 5309;
5318 -> 5317;
5318 -> 5309;
5319 -> 5308;
5320 -> 5302;
5320 -> 5319;
5321 -> 5319;
5322 -> 5320;
5322 -> 5321;
5323 -> 5322;
5323 -> 4890;
5323 -> 4910;
5323 -> 5182;
5323 -> 5321;
5324 -> 5323;
5324 -> 5319;
5325 -> 5324;
5325 -> 5319;
5326 -> 5318;
5326 -> 5325;
5326 -> 5308;
5327 -> 5308;
5328 -> 5302;
5328 -> 5327;
5329 -> 5327;
5330 -> 5328;
5330 -> 5329;
5331 -> 5327;
5332 -> 5330;
5332 -> 5331;
5333 -> 5332;
5333 -> 0;
5333 -> 5327;
5334 -> 5333;
5334 -> 5327;
5335 -> 5334;
5335 -> 5327;
5336 -> 5335;
5336 -> 5327;
5337 -> 5326;
5337 -> 5336;
5337 -> 5308;
5338 -> 5337;
5338 -> 5308;
5339 -> 5338;
5340 -> 5339;
5340 -> 5338;
5341 -> 5340;
5341 -> 5300;
5342 -> 5341;
5343 -> 5294;
5343 -> 5342;
5344 -> 5342;
5345 -> 5344;
5345 -> 5342;
5346 -> 5345;
5346 -> 5342;
5347 -> 5342;
5348 -> 5346;
5348 -> 5347;
5349 -> 5343;
5349 -> 5347;
5350 -> 5347;
5351 -> 5348;
5351 -> 5350;
5351 -> 5347;
5352 -> 5351;
5352 -> 5347;
5353 -> 5349;
5353 -> 4890;
5353 -> 5348;
5353 -> 5347;
5354 -> 5353;
5354 -> 5349;
5354 -> 4890;
5354 -> 5347;
5355 -> 5354;
5355 -> 5347;
5356 -> 5349;
5356 -> 4890;
5356 -> 5348;
5357 -> 5342;
5358 -> 5356;
5358 -> 5357;
5359 -> 5358;
5359 -> 0;
5359 -> 5342;
5360 -> 5345;
5360 -> 5342;
5361 -> 5342;
5362 -> 5360;
5362 -> 5361;
5363 -> 5343;
5363 -> 5361;
5364 -> 5361;
5365 -> 5362;
5365 -> 5364;
5365 -> 5361;
5366 -> 5365;
5366 -> 5361;
5367 -> 5363;
5367 -> 4890;
5367 -> 5362;
5367 -> 5361;
5368 -> 5367;
5368 -> 5363;
5368 -> 4890;
5368 -> 5361;
5369 -> 5368;
5369 -> 5361;
5370 -> 5363;
5370 -> 4890;
5370 -> 5362;
5371 -> 5342;
5372 -> 5370;
5372 -> 5371;
5373 -> 5372;
5373 -> 0;
5373 -> 5342;
5374 -> 5359;
5374 -> 5373;
5374 -> 5342;
5375 -> 5374;
5375 -> 5342;
5376 -> 5345;
5376 -> 5342;
5377 -> 5342;
5378 -> 5376;
5378 -> 5377;
5379 -> 5343;
5379 -> 5377;
5380 -> 5377;
5381 -> 5378;
5381 -> 5380;
5381 -> 5377;
5382 -> 5381;
5382 -> 5377;
5383 -> 5379;
5383 -> 4890;
5383 -> 5378;
5383 -> 5377;
5384 -> 5383;
5384 -> 5379;
5384 -> 4890;
5384 -> 5377;
5385 -> 5384;
5385 -> 5377;
5386 -> 5379;
5386 -> 4890;
5386 -> 5378;
5387 -> 5342;
5388 -> 5386;
5388 -> 5387;
5389 -> 5388;
5389 -> 0;
5389 -> 5342;
5390 -> 5389;
5390 -> 5342;
5391 -> 5390;
5391 -> 5341;
5392 -> 5293;
5392 -> 5391;
5393 -> 5391;
5394 -> 5392;
5394 -> 5393;
5395 -> 5294;
5395 -> 5393;
5396 -> 5393;
5397 -> 5395;
5397 -> 5396;
5398 -> 5393;
5399 -> 5397;
5399 -> 5398;
5400 -> 5399;
5400 -> 0;
5400 -> 5393;
5401 -> 5393;
5402 -> 5395;
5402 -> 5401;
5403 -> 5393;
5404 -> 5402;
5404 -> 5403;
5405 -> 5395;
5405 -> 5403;
5406 -> 5400;
5406 -> 5404;
5406 -> 5393;
5407 -> 5406;
5407 -> 5393;
5408 -> 5394;
5408 -> 0;
5408 -> 5393;
5409 -> 5408;
5409 -> 5393;
5410 -> 5393;
5411 -> 5393;
5412 -> 5393;
5413 -> 5395;
5413 -> 5412;
5414 -> 5393;
5415 -> 5413;
5415 -> 5414;
5416 -> 5415;
5416 -> 0;
5416 -> 5393;
5417 -> 5416;
5417 -> 5393;
5418 -> 5417;
5419 -> 5417;
5420 -> 5418;
5420 -> 5419;
5421 -> 5420;
5421 -> 0;
5421 -> 5417;
5422 -> 5421;
5422 -> 5417;
5423 -> 5422;
5423 -> 5417;
5424 -> 5423;
5425 -> 5424;
5425 -> 5423;
5426 -> 5423;
5427 -> 5426;
5427 -> 5423;
5428 -> 5425;
5428 -> 5393;
5429 -> 5393;
5430 -> 5428;
5430 -> 5429;
5431 -> 5395;
5431 -> 5429;
5432 -> 5429;
5433 -> 5430;
5433 -> 5432;
5433 -> 5429;
5434 -> 5433;
5434 -> 5429;
5435 -> 5431;
5435 -> 4890;
5435 -> 5430;
5435 -> 5429;
5436 -> 5435;
5436 -> 5431;
5436 -> 4890;
5436 -> 5429;
5437 -> 5436;
5437 -> 5429;
5438 -> 5393;
5439 -> 5430;
5439 -> 5438;
5440 -> 5439;
5440 -> 0;
5440 -> 5393;
5441 -> 5440;
5441 -> 5393;
5442 -> 5425;
5442 -> 5393;
5443 -> 5393;
5444 -> 5442;
5444 -> 5443;
5445 -> 5395;
5445 -> 5443;
5446 -> 5443;
5447 -> 5444;
5447 -> 5446;
5447 -> 5443;
5448 -> 5447;
5448 -> 5443;
5449 -> 5445;
5449 -> 4890;
5449 -> 5444;
5449 -> 5443;
5450 -> 5449;
5450 -> 5445;
5450 -> 4890;
5450 -> 5443;
5451 -> 5450;
5451 -> 5443;
5452 -> 5393;
5453 -> 5444;
5453 -> 5452;
5454 -> 5453;
5454 -> 0;
5454 -> 5393;
5455 -> 5393;
5456 -> 5425;
5456 -> 5455;
5456 -> 5393;
5457 -> 5393;
5458 -> 5456;
5458 -> 5457;
5459 -> 5395;
5459 -> 5457;
5460 -> 5457;
5461 -> 5458;
5461 -> 5460;
5461 -> 5457;
5462 -> 5461;
5462 -> 5457;
5463 -> 5459;
5463 -> 4890;
5463 -> 5458;
5463 -> 5457;
5464 -> 5463;
5464 -> 5459;
5464 -> 4890;
5464 -> 5457;
5465 -> 5464;
5465 -> 5457;
5466 -> 5393;
5467 -> 5458;
5467 -> 5466;
5468 -> 5467;
5468 -> 0;
5468 -> 5393;
5469 -> 5454;
5469 -> 5468;
5469 -> 5393;
5470 -> 5469;
5470 -> 5393;
5471 -> 5425;
5471 -> 5393;
5472 -> 5393;
5473 -> 5471;
5473 -> 5472;
5474 -> 5395;
5474 -> 5472;
5475 -> 5472;
5476 -> 5473;
5476 -> 5475;
5476 -> 5472;
5477 -> 5476;
5477 -> 5472;
5478 -> 5474;
5478 -> 4890;
5478 -> 5473;
5478 -> 5472;
5479 -> 5478;
5479 -> 5474;
5479 -> 4890;
5479 -> 5472;
5480 -> 5479;
5480 -> 5472;
5481 -> 5393;
5482 -> 5473;
5482 -> 5481;
5483 -> 5482;
5483 -> 0;
5483 -> 5393;
5484 -> 5483;
5484 -> 5393;
5485 -> 5425;
5485 -> 5393;
5486 -> 5393;
5487 -> 5485;
5487 -> 5486;
5488 -> 5395;
5488 -> 5486;
5489 -> 5486;
5490 -> 5487;
5490 -> 5489;
5490 -> 5486;
5491 -> 5490;
5491 -> 5486;
5492 -> 5488;
5492 -> 4890;
5492 -> 5487;
5492 -> 5486;
5493 -> 5492;
5493 -> 5488;
5493 -> 4890;
5493 -> 5486;
5494 -> 5493;
5494 -> 5486;
5495 -> 5393;
5496 -> 5487;
5496 -> 5495;
5497 -> 5496;
5497 -> 0;
5497 -> 5393;
5498 -> 5497;
5498 -> 5393;
5499 -> 5498;
5500 -> 5499;
5500 -> 5498;
5501 -> 5500;
5501 -> 5391;
5502 -> 5293;
5502 -> 5501;
5503 -> 5501;
5504 -> 5502;
5504 -> 5503;
5505 -> 5504;
5505 -> 5501;
5506 -> 0;
5506 -> 5505;
5507 -> 5505;
5508 -> 5506;
5508 -> 5507;
5509 -> 5294;
5509 -> 5507;
5510 -> 5508;
5510 -> 5507;
5511 -> 5507;
5512 -> 5510;
5512 -> 5511;
5513 -> 5509;
5513 -> 5511;
5514 -> 5511;
5515 -> 5514;
5516 -> 5513;
5516 -> 5514;
5517 -> 5514;
5518 -> 5516;
5518 -> 5517;
5519 -> 5517;
5520 -> 5518;
5520 -> 5519;
5521 -> 5520;
5521 -> 5517;
5522 -> 5521;
5523 -> 5522;
5523 -> 5521;
5524 -> 5523;
5524 -> 5514;
5525 -> 5524;
5525 -> 5514;
5526 -> 5515;
5526 -> 5514;
5527 -> 5514;
5528 -> 5526;
5528 -> 5527;
5529 -> 5516;
5529 -> 5527;
5530 -> 5527;
5531 -> 5529;
5531 -> 5530;
5532 -> 5527;
5533 -> 5531;
5533 -> 5532;
5534 -> 5533;
5534 -> 5527;
5535 -> 5534;
5535 -> 0;
5535 -> 5527;
5536 -> 5535;
5536 -> 5527;
5537 -> 5536;
5538 -> 5529;
5538 -> 5537;
5539 -> 5537;
5540 -> 5538;
5540 -> 5539;
5541 -> 5537;
5542 -> 5540;
5542 -> 5541;
5543 -> 5542;
5543 -> 0;
5543 -> 5537;
5544 -> 5543;
5544 -> 5537;
5545 -> 5536;
5546 -> 5537;
5546 -> 5545;
5546 -> 5536;
5547 -> 5546;
5547 -> 5536;
5548 -> 5536;
5549 -> 5529;
5549 -> 5548;
5550 -> 5548;
5551 -> 5549;
5551 -> 5550;
5552 -> 5551;
5552 -> 5548;
5553 -> 5548;
5554 -> 5549;
5554 -> 5553;
5555 -> 5553;
5556 -> 5554;
5556 -> 4890;
5556 -> 5555;
5557 -> 5555;
5558 -> 5557;
5558 -> 5555;
5559 -> 5558;
5559 -> 5554;
5559 -> 5553;
5560 -> 5553;
5561 -> 5560;
5561 -> 5554;
5561 -> 5553;
5562 -> 5553;
5563 -> 5554;
5563 -> 4890;
5563 -> 5562;
5563 -> 5553;
5564 -> 5563;
5564 -> 5553;
5565 -> 5554;
5565 -> 4890;
5565 -> 5553;
5566 -> 5552;
5566 -> 5548;
5567 -> 5566;
5567 -> 5536;
5568 -> 5536;
5569 -> 5529;
5569 -> 5568;
5570 -> 5569;
5570 -> 4890;
5570 -> 4910;
5570 -> 5182;
5570 -> 5559;
5570 -> 5561;
5570 -> 5565;
5570 -> 5568;
5571 -> 5570;
5571 -> 5536;
5572 -> 5571;
5572 -> 5536;
5573 -> 5567;
5573 -> 5536;
5574 -> 5573;
5574 -> 5514;
5575 -> 5574;
5575 -> 5514;
5576 -> 5575;
5576 -> 4890;
5576 -> 4910;
5576 -> 5182;
5576 -> 5559;
5576 -> 5561;
5576 -> 5565;
5576 -> 5514;
5577 -> 5514;
5578 -> 5576;
5578 -> 5577;
5579 -> 5576;
5579 -> 5577;
5580 -> 5578;
5580 -> 5577;
5581 -> 5577;
5582 -> 5581;
5582 -> 5580;
5582 -> 5577;
5583 -> 5581;
5583 -> 5577;
5584 -> 5583;
5584 -> 5582;
5584 -> 5577;
5585 -> 5584;
5585 -> 5514;
5586 -> 5585;
5586 -> 5511;
5587 -> 5586;
5587 -> 5584;
5587 -> 5511;
5588 -> 5586;
5588 -> 5511;
5589 -> 5511;
5590 -> 5513;
5590 -> 5589;
5591 -> 5590;
5591 -> 5584;
5591 -> 5589;
5592 -> 5591;
5592 -> 5589;
5593 -> 5590;
5593 -> 5584;
5593 -> 5589;
5594 -> 5511;
5595 -> 5593;
5595 -> 5594;
5596 -> 5595;
5596 -> 0;
5596 -> 5511;
5597 -> 5596;
5597 -> 5511;
5598 -> 5588;
5598 -> 5511;
5599 -> 5598;
5599 -> 5507;
5600 -> 5507;
5601 -> 5509;
5601 -> 5600;
5602 -> 5601;
5602 -> 5584;
5602 -> 5593;
5602 -> 5600;
5603 -> 5507;
5604 -> 5602;
5604 -> 5603;
5605 -> 5604;
5605 -> 0;
5605 -> 5507;
5606 -> 5605;
5606 -> 5507;
5607 -> 5599;
5607 -> 5507;
5608 -> 5607;
5608 -> 5505;
5609 -> 5608;
5609 -> 5290;
5609 -> 5584;
5609 -> 5593;
5609 -> 5288;
5610 -> 5288;
5611 -> 5609;
5611 -> 5610;
5612 -> 5610;
5613 -> 5611;
5613 -> 5612;
5614 -> 5612;
5615 -> 5613;
5615 -> 5614;
5616 -> 5615;
5616 -> 5612;
5617 -> 5616;
5618 -> 5617;
5618 -> 5616;
5619 -> 5618;
5619 -> 5610;
5620 -> 5619;
5620 -> 5610;
5621 -> 5610;
5622 -> 5621;
5622 -> 5610;
5623 -> 5610;
5624 -> 5623;
5624 -> 5610;
5625 -> 5610;
5626 -> 5625;
5626 -> 5610;
5627 -> 0;
5627 -> 5610;
5628 -> 0;
5628 -> 5610;
5629 -> 5622;
5629 -> 5624;
5629 -> 5626;
5629 -> 5627;
5629 -> 5628;
5629 -> 5611;
5629 -> 5609;
5629 -> 5610;
5630 -> 5610;
5631 -> 5629;
5631 -> 5630;
5632 -> 5629;
5632 -> 5630;
5633 -> 5631;
5633 -> 5630;
5634 -> 5630;
5635 -> 5633;
5635 -> 5634;
5636 -> 5635;
5636 -> 0;
5636 -> 5634;
5637 -> 5635;
5637 -> 0;
5637 -> 5634;
5638 -> 5636;
5638 -> 5637;
5638 -> 5634;
5639 -> 5638;
5639 -> 5634;
5640 -> 5639;
5641 -> 5640;
5641 -> 5639;
5642 -> 5641;
5642 -> 5630;
5643 -> 5630;
5644 -> 5632;
5644 -> 5643;
5645 -> 5644;
5645 -> 5630;
5646 -> 5630;
5647 -> 5645;
5647 -> 5646;
5648 -> 5647;
5648 -> 5631;
5648 -> 5630;
5649 -> 5648;
5649 -> 5630;
5650 -> 5649;
5651 -> 5650;
5651 -> 5629;
5652 -> 5650;
5653 -> 5650;
5653 -> 5629;
5653 -> 5652;
5654 -> 5653;
5654 -> 5650;
5655 -> 5645;
5655 -> 5649;
5656 -> 5629;
5656 -> 5655;
5656 -> 5650;
5656 -> 5610;
5657 -> 5629;
5657 -> 5656;
5657 -> 5630;
5658 -> 5657;
5658 -> 5630;
5659 -> 5656;
5660 -> 5656;
5661 -> 5656;
5661 -> 5660;
5662 -> 5661;
5662 -> 5656;
5663 -> 5656;
5663 -> 5610;
5664 -> 5656;
5664 -> 5610;
5665 -> 5656;
5665 -> 5610;
5666 -> 5663;
5666 -> 5664;
5666 -> 5665;
5666 -> 5611;
5666 -> 5656;
5666 -> 5610;
5667 -> 5610;
5668 -> 5666;
5668 -> 5667;
5669 -> 5666;
5669 -> 5667;
5670 -> 5666;
5670 -> 5667;
5671 -> 5666;
5671 -> 5667;
5672 -> 5666;
5672 -> 5667;
5673 -> 5666;
5673 -> 5667;
5674 -> 5668;
5674 -> 5667;
5675 -> 5669;
5675 -> 5667;
5676 -> 5670;
5676 -> 5667;
5677 -> 5671;
5677 -> 5667;
5678 -> 5672;
5678 -> 5667;
5679 -> 5667;
5680 -> 5678;
5680 -> 5679;
5681 -> 5679;
5682 -> 5681;
5682 -> 5679;
5683 -> 5680;
5683 -> 5666;
5683 -> 5679;
5684 -> 5680;
5684 -> 5666;
5684 -> 5679;
5685 -> 5682;
5685 -> 5679;
5686 -> 5673;
5686 -> 5667;
5687 -> 5674;
5687 -> 5675;
5687 -> 5676;
5687 -> 5677;
5687 -> 5685;
5687 -> 5686;
5687 -> 5666;
5687 -> 5667;
5688 -> 5687;
5688 -> 5667;
5689 -> 5667;
5690 -> 5689;
5690 -> 5667;
5691 -> 5687;
5691 -> 5667;
5692 -> 5687;
5692 -> 5667;
5693 -> 5691;
5693 -> 5667;
5694 -> 5691;
5694 -> 5667;
5695 -> 5688;
5695 -> 5610;
5696 -> 5609;
5696 -> 5610;
5697 -> 5609;
5697 -> 5610;
5698 -> 5609;
5698 -> 5610;
5699 -> 5609;
5699 -> 5610;
5700 -> 5609;
5700 -> 5610;
5701 -> 5696;
5701 -> 5610;
5702 -> 5697;
5702 -> 5610;
5703 -> 5698;
5703 -> 5610;
5704 -> 5699;
5704 -> 5610;
5705 -> 5610;
5706 -> 5704;
5706 -> 5705;
5707 -> 5705;
5708 -> 5707;
5708 -> 5705;
5709 -> 5706;
5709 -> 5695;
5709 -> 5705;
5710 -> 5706;
5710 -> 5695;
5710 -> 5705;
5711 -> 5708;
5711 -> 5705;
5712 -> 5700;
5712 -> 5610;
5713 -> 5701;
5713 -> 5702;
5713 -> 5703;
5713 -> 5711;
5713 -> 5712;
5713 -> 5695;
5713 -> 5610;
5714 -> 5713;
5714 -> 5610;
5715 -> 5610;
5716 -> 5715;
5716 -> 5610;
5717 -> 5713;
5717 -> 5610;
5718 -> 5713;
5718 -> 5610;
5719 -> 5717;
5719 -> 5610;
5720 -> 5717;
5720 -> 5610;
5721 -> 5713;
5721 -> 5630;
5722 -> 5721;
5722 -> 5630;
5723 -> 5714;
5723 -> 5286;
5724 -> 5723;
5724 -> 5186;
5725 -> 5187;
5725 -> 5186;
5726 -> 5186;
5727 -> 5724;
5727 -> 5726;
5728 -> 5725;
5728 -> 5726;
5729 -> 5188;
5729 -> 5726;
5730 -> 5726;
5731 -> 5730;
5731 -> 5726;
5732 -> 5731;
5733 -> 5729;
5733 -> 5732;
5734 -> 5733;
5734 -> 5714;
5734 -> 5732;
5735 -> 5731;
5736 -> 5734;
5736 -> 5735;
5737 -> 5736;
5737 -> 5731;
5738 -> 5731;
5739 -> 5738;
5739 -> 5731;
5740 -> 5731;
5741 -> 5737;
5741 -> 5731;
5742 -> 5731;
5743 -> 5741;
5743 -> 5742;
5744 -> 5743;
5744 -> 5742;
5745 -> 5742;
5746 -> 5744;
5746 -> 5745;
5747 -> 5746;
5747 -> 5745;
5748 -> 5745;
5749 -> 5747;
5749 -> 5748;
5750 -> 5749;
5750 -> 5748;
5751 -> 0;
5751 -> 5750;
5752 -> 5751;
5752 -> 0;
5752 -> 5745;
5753 -> 5752;
5753 -> 5745;
5754 -> 5753;
5754 -> 5742;
5755 -> 5754;
5755 -> 5731;
5756 -> 5737;
5756 -> 5755;
5757 -> 5755;
5758 -> 5756;
5758 -> 5757;
5759 -> 5758;
5759 -> 5757;
5760 -> 5757;
5761 -> 5759;
5761 -> 5760;
5762 -> 5761;
5762 -> 5760;
5763 -> 5762;
5764 -> 5763;
5764 -> 5762;
5765 -> 5764;
5765 -> 5757;
5766 -> 5765;
5766 -> 5755;
5767 -> 5737;
5767 -> 0;
5767 -> 5766;
5768 -> 5767;
5768 -> 5766;
5769 -> 5737;
5769 -> 0;
5769 -> 5768;
5770 -> 5769;
5770 -> 5768;
5771 -> 5770;
5771 -> 5768;
5772 -> 5737;
5772 -> 0;
5772 -> 5771;
5773 -> 5772;
5773 -> 5771;
5774 -> 5773;
5774 -> 5771;
5775 -> 5726;
5776 -> 5729;
5776 -> 5775;
5777 -> 5776;
5777 -> 5714;
5777 -> 5775;
5778 -> 5726;
5779 -> 5777;
5779 -> 5778;
5780 -> 5779;
5780 -> 0;
5780 -> 5726;
5781 -> 5780;
5781 -> 5726;
5782 -> 5781;
5782 -> 5726;
5783 -> 5727;
5783 -> 5726;
5784 -> 5783;
5784 -> 5186;
5785 -> 5784;
5785 -> 5179;
5786 -> 5179;
5787 -> 5179;
5788 -> 5785;
5788 -> 5787;
5789 -> 5179;
5790 -> 5788;
5790 -> 5789;
5791 -> 5790;
5791 -> 5789;
5792 -> 0;
5792 -> 5791;
5793 -> 5792;
5793 -> 5179;
5794 -> 5181;
5794 -> 5714;
5794 -> 5179;
5795 -> 5785;
5795 -> 5179;
5796 -> 5795;
5796 -> 5176;
5797 -> 5172;
5798 -> 5175;
5798 -> 5797;
5799 -> 5796;
5799 -> 5797;
5800 -> 5174;
5800 -> 5797;
5801 -> 5797;
5802 -> 5797;
5803 -> 5800;
5803 -> 5802;
5804 -> 5802;
5805 -> 5803;
5805 -> 5804;
5806 -> 5804;
5807 -> 5805;
5807 -> 5714;
5807 -> 5806;
5808 -> 5807;
5808 -> 5714;
5808 -> 5806;
5809 -> 5808;
5809 -> 5804;
5810 -> 5809;
5810 -> 5714;
5810 -> 0;
5810 -> 5802;
5811 -> 5810;
5811 -> 5802;
5812 -> 5811;
5812 -> 5797;
5813 -> 5812;
5813 -> 5797;
5814 -> 0;
5814 -> 5813;
5815 -> 5813;
5816 -> 5814;
5816 -> 5815;
5817 -> 5800;
5817 -> 5815;
5818 -> 5816;
5818 -> 5815;
5819 -> 5815;
5820 -> 5818;
5820 -> 5819;
5821 -> 5820;
5821 -> 0;
5821 -> 5819;
5822 -> 5820;
5822 -> 0;
5822 -> 5819;
5823 -> 5821;
5823 -> 5822;
5823 -> 5819;
5824 -> 5823;
5824 -> 5819;
5825 -> 5824;
5826 -> 5825;
5826 -> 5824;
5827 -> 5826;
5827 -> 5815;
5828 -> 5815;
5829 -> 5817;
5829 -> 5828;
5830 -> 5829;
5830 -> 5815;
5831 -> 5815;
5832 -> 5830;
5832 -> 5831;
5833 -> 5832;
5833 -> 5816;
5833 -> 5815;
5834 -> 5833;
5834 -> 5815;
5835 -> 5834;
5836 -> 5835;
5836 -> 5714;
5837 -> 5835;
5838 -> 5835;
5838 -> 5714;
5838 -> 5837;
5839 -> 5838;
5839 -> 5835;
5840 -> 5830;
5840 -> 5834;
5841 -> 5840;
5841 -> 5813;
5842 -> 5798;
5842 -> 5797;
5843 -> 5799;
5843 -> 5797;
5844 -> 5841;
5844 -> 5797;
5845 -> 5842;
5845 -> 5843;
5845 -> 5844;
5845 -> 5800;
5845 -> 5714;
5845 -> 5794;
5845 -> 5835;
5845 -> 5797;
5846 -> 5797;
5847 -> 5845;
5847 -> 5846;
5848 -> 5847;
5848 -> 5846;
5849 -> 5846;
5850 -> 5848;
5850 -> 5849;
5851 -> 5849;
5852 -> 5851;
5852 -> 5849;
5853 -> 5850;
5853 -> 5845;
5853 -> 5849;
5854 -> 5850;
5854 -> 5845;
5854 -> 5849;
5855 -> 5852;
5855 -> 5849;
5856 -> 5846;
5857 -> 5856;
5857 -> 5846;
5858 -> 5845;
5858 -> 5846;
5859 -> 5845;
5859 -> 5846;
5860 -> 5858;
5860 -> 5846;
5861 -> 5858;
5861 -> 5846;
5862 -> 5845;
5862 -> 5797;
5863 -> 5862;
5863 -> 5172;
5864 -> 5863;
5864 -> 5170;
5865 -> 5864;
5865 -> 4850;
5866 -> 4853;
5866 -> 5845;
5866 -> 4850;
5867 -> 5029;
5867 -> 4850;
5868 -> 4850;
5869 -> 5867;
5869 -> 5868;
5870 -> 4853;
5870 -> 5868;
5871 -> 5869;
5871 -> 4903;
5871 -> 5868;
5872 -> 5868;
5873 -> 5871;
5873 -> 5872;
5874 -> 5870;
5874 -> 5872;
5875 -> 5874;
5875 -> 5845;
5875 -> 5873;
5875 -> 5872;
5876 -> 5875;
5876 -> 5872;
5877 -> 5874;
5877 -> 5845;
5877 -> 5872;
5878 -> 5872;
5879 -> 5874;
5879 -> 5845;
5879 -> 5877;
5879 -> 5878;
5879 -> 5872;
5880 -> 5879;
5880 -> 5872;
5881 -> 5880;
5882 -> 5881;
5882 -> 5874;
5882 -> 5880;
5883 -> 4810;
5883 -> 5865;
5883 -> 5845;
5883 -> 5866;
5883 -> 5877;
5883 -> 5882;
5883 -> 4803;
5884 -> 5883;
5884 -> 4803;
5885 -> 5884;
5885 -> 4799;
5886 -> 5885;
5886 -> 74;
5887 -> 78;
5887 -> 74;
5888 -> 5886;
5888 -> 5887;
5889 -> 5887;
5890 -> 5888;
5890 -> 5889;
5891 -> 4798;
5891 -> 5889;
5892 -> 5889;
5893 -> 5891;
5893 -> 5892;
5894 -> 5892;
5895 -> 5893;
5895 -> 5894;
5896 -> 5895;
5896 -> 5883;
5896 -> 5894;
5897 -> 5896;
5897 -> 5894;
5898 -> 5894;
5899 -> 5895;
5899 -> 5883;
5899 -> 5898;
5899 -> 5894;
5900 -> 5889;
5901 -> 5899;
5901 -> 5900;
5902 -> 5901;
5902 -> 0;
5902 -> 5889;
5903 -> 5902;
5903 -> 5889;
5904 -> 5890;
5904 -> 5903;
5905 -> 5904;
5905 -> 5887;
5906 -> 5905;
5906 -> 74;
5907 -> 5905;
5907 -> 5883;
5907 -> 5899;
5907 -> 74;
5908 -> 74;
5909 -> 5907;
5909 -> 5908;
5910 -> 5907;
5910 -> 5908;
5911 -> 5907;
5911 -> 5908;
5912 -> 5906;
5912 -> 5908;
5913 -> 5909;
5913 -> 5908;
5914 -> 5910;
5914 -> 5908;
5915 -> 5911;
5915 -> 5908;
5916 -> 5908;
5917 -> 5916;
5917 -> 5913;
5917 -> 5914;
5917 -> 5915;
5917 -> 5907;
5917 -> 5908;
5918 -> 5917;
5918 -> 74;
5919 -> 5918;
5919 -> 66;
5920 -> 5919;
5920 -> 50;
5921 -> 5920;
5921 -> 50;
5922 -> 5921;
5922 -> 5917;
5922 -> 50;
5923 -> 0;
5923 -> 50;
5924 -> 50;
5925 -> 5920;
5925 -> 5924;
5926 -> 5925;
5926 -> 5922;
5926 -> 5924;
5927 -> 5923;
5927 -> 5926;
5927 -> 50;
5928 -> 64;
5928 -> 50;
5929 -> 5920;
5929 -> 5922;
5929 -> 50;
5930 -> 50;
5931 -> 5929;
5931 -> 5930;
5932 -> 5930;
5933 -> 5929;
5933 -> 5932;
5933 -> 50;
5934 -> 5929;
5934 -> 5930;
5935 -> 5929;
5935 -> 5930;
5936 -> 5929;
5936 -> 5930;
5937 -> 5929;
5937 -> 5930;
5938 -> 5935;
5938 -> 5930;
5939 -> 5937;
5939 -> 5933;
5939 -> 5930;
5940 -> 5934;
5940 -> 5939;
5940 -> 5933;
5940 -> 5930;
5941 -> 5936;
5941 -> 5930;
5942 -> 5941;
5943 -> 5937;
5943 -> 5942;
5944 -> 5942;
5944 -> 5941;
5945 -> 5941;
5946 -> 5944;
5946 -> 5945;
5946 -> 5941;
5947 -> 5946;
5947 -> 5941;
5948 -> 5938;
5949 -> 5937;
5949 -> 5948;
5950 -> 5948;
5951 -> 5950;
5951 -> 5948;
5952 -> 5951;
5952 -> 5938;
5953 -> 5938;
5954 -> 5952;
5954 -> 5953;
5954 -> 5938;
5955 -> 5954;
5955 -> 5938;
5956 -> 5930;
5957 -> 5937;
5957 -> 5956;
5958 -> 5956;
5959 -> 5957;
5959 -> 5958;
5960 -> 5959;
5960 -> 5940;
5960 -> 5958;
5961 -> 5956;
5962 -> 5960;
5962 -> 5961;
5963 -> 5962;
5963 -> 5961;
5964 -> 5963;
5965 -> 5964;
5965 -> 5963;
5966 -> 5965;
5966 -> 5956;
5967 -> 5966;
5968 -> 5967;
5968 -> 5966;
5969 -> 5968;
5970 -> 5969;
5970 -> 5968;
5971 -> 5928;
5971 -> 5970;
5971 -> 50;
5972 -> 50;
5973 -> 5920;
5973 -> 50;
5974 -> 50;
5975 -> 5973;
5975 -> 5974;
5976 -> 5975;
5976 -> 5970;
5976 -> 5974;
5977 -> 5974;
5978 -> 5977;
5978 -> 5974;
5979 -> 5974;
5980 -> 5976;
5980 -> 5979;
5981 -> 5978;
5981 -> 5979;
5982 -> 5979;
5983 -> 5982;
5983 -> 5979;
5984 -> 5980;
5984 -> 5979;
5985 -> 5984;
5985 -> 5970;
5985 -> 5979;
5986 -> 5985;
5986 -> 5979;
5987 -> 5986;
5987 -> 5979;
5988 -> 5987;
5988 -> 5979;
5989 -> 5983;
5989 -> 5982;
5989 -> 5979;
5990 -> 5989;
5990 -> 5979;
5991 -> 5990;
5991 -> 5974;
5992 -> 5991;
5992 -> 5989;
5992 -> 50;
5993 -> 5972;
5993 -> 5992;
5993 -> 50;
}